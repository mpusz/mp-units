# Tutorial 13: Incremental Migration from Legacy Code

Large codebases in high-energy physics, aerospace, and scientific computing often use **dimensional
constant libraries** where each package (Geant4, ROOT, CLHEP) defines its own unit system as
multiplicative constants. While better than raw doubles, these systems still allow silent unit
mixing across package boundaries.

This tutorial demonstrates **incremental migration strategies** for introducing **mp-units**
type safety into codebases that use dimensional constants:

- Introduce **mp-units** gradually alongside existing unit systems
- Maintain compatibility with legacy APIs using dimensional constants  
- Create safe boundaries between different unit conventions
- Minimize disruption while maximizing safety gains

The approach mirrors real-world scenarios at CERN and other facilities where multiple subsystems
(simulation, reconstruction, analysis) each have their own unit definitions and must interoperate
during migration.


## Problem Statement: Dimensional Constant Chaos

Consider a high-energy physics experiment integrating three major frameworks:

```cpp
// Each framework defines its own unit system as constants

// Geant4 Units (HEP system: mm, ns, MeV)
namespace G4 {
  constexpr double mm = 1.0;
  constexpr double cm = 10.0 * mm;
  constexpr double MeV = 1.0;
  constexpr double GeV = 1000.0 * MeV;
  constexpr double ns = 1.0;
  constexpr double c_light = 299.792458 * mm/ns;  // Speed of light
}

// ROOT Units (follows Geant3: cm, s, GeV)
namespace ROOT {
  constexpr double cm = 1.0;
  constexpr double m = 100.0 * cm;
  constexpr double GeV = 1.0;
  constexpr double MeV = 0.001 * GeV;
  constexpr double ns = 1.0e-9;
  constexpr double s = 1.0;
}

// CLHEP Units (HEP system: mm, ns, MeV - but different base!)
namespace CLHEP {
  constexpr double millimeter = 1.0;
  constexpr double mm = millimeter;
  constexpr double MeV = 1.0;
  constexpr double ns = 1.0;
  constexpr double c_light = 299.792458 * mm/ns;
}

// Your analysis code: particle tracking
namespace analysis {

struct Particle {
  // Which units? Depends on which framework created it!
  double px, py, pz;   // Momentum in... MeV? GeV? GeV/c?
  double x, y, z;      // Position in... mm? cm?
  double t;            // Time in... ns? s?
  double mass;         // Mass in... MeV/c²? GeV/c²?
};

// Convert particle from Geant4 to ROOT coordinates
Particle g4_to_root(const Particle& p) {
  return Particle{
    .px = p.px * (G4::MeV / ROOT::MeV),      // MeV → GeV (factor 0.001)
    .py = p.py * (G4::MeV / ROOT::MeV),
    .pz = p.pz * (G4::MeV / ROOT::MeV),
    .x = p.x * (G4::mm / ROOT::cm),          // mm → cm (factor 0.1)
    .y = p.y * (G4::mm / ROOT::cm),
    .z = p.z * (G4::mm / ROOT::cm),
    .t = p.t * (G4::ns / ROOT::ns),          // ns → s (factor 1e-9)
    .mass = p.mass * (G4::MeV / ROOT::MeV)
  };
}

}  // namespace analysis
```

**Problems with dimensional constants:**

1. **Silent unit mixing**: `double energy = g4_energy + root_energy;` compiles but mixes MeV + GeV!
2. **Conversion factor errors**: Is `G4::MeV / ROOT::MeV` really 0.001? Easy to get wrong.
3. **No dimensional checking**: `double wrong = position_mm * energy_MeV;` compiles without error
4. **Lost type information**: Function signatures `double compute(double x, double y)` don't show
   which units parameters expect
5. **Framework coupling**: Every package must know every other package's conversion factors

You can't rewrite this overnight—the codebase has:

- 1000+ files calling Geant4/ROOT/CLHEP APIs with dimensional constants
- Millions of events stored assuming current unit conventions
- Python bindings expecting dimensionless doubles scaled by unit constants  
- Third-party code that can't be modified


## Migration Strategy: The Boundary Pattern

The key insight: **mp-units becomes the common language between frameworks.**

**Phase 1: Create interoperability layer** (weeks)
- Define conversion functions from dimensional constants → mp-units
- Define extraction functions from mp-units → dimensional constants
- Document which framework conventions each function uses

**Phase 2: Create type-safe analysis layer** (months)
- New analysis code works entirely in mp-units
- Reads framework data through conversion layer
- Writes results back through extraction layer

**Phase 3: Gradually eliminate conversion overhead** (years)
- Modify frameworks to produce mp-units directly (if possible)
- Or create zero-overhead wrappers using `quantity_cast`
- Eventually frameworks might adopt mp-units internally

Let's implement this pattern.


## Step 1: Create Interoperability Layer

Define conversion functions that make dimensional constant assumptions explicit:

```cpp
#include <mp-units/systems/si.h>
#include <mp-units/systems/hep.h>
#include <mp-units/systems/si/constants.h>

namespace interop {
  using namespace mp_units;
  using namespace mp_units::si::unit_symbols;
  namespace hep = mp_units::hep::unit_symbols;
  
  // ============================================================================
  // Geant4 → mp-units (HEP system: mm, ns, MeV)
  // ============================================================================
  
  inline auto from_g4_position(double g4_mm) {
    return g4_mm * mm;
  }
  
  inline auto from_g4_momentum(double g4_mev_per_c) {
    return g4_mev_per_c * (hep::MeV / si::si_constants<>::speed_of_light_in_vacuum);
  }
  
  inline auto from_g4_energy(double g4_mev) {
    return g4_mev * hep::MeV;
  }
  
  inline auto from_g4_time(double g4_ns) {
    return g4_ns * ns;
  }
  
  inline auto from_g4_mass(double g4_mev_per_c2) {
    return g4_mev_per_c2 * (hep::MeV / pow<2>(si::si_constants<>::speed_of_light_in_vacuum));
  }
  
  // ============================================================================
  // mp-units → Geant4 (extract as mm, MeV, ns)
  // ============================================================================
  
  inline double to_g4_position(quantity<isq::length[mm]> pos) {
    return pos.numerical_value_in(mm);
  }
  
  inline double to_g4_energy(quantity<isq::energy[hep::MeV]> E) {
    return E.numerical_value_in(hep::MeV);
  }
  
  inline double to_g4_time(quantity<isq::time[ns]> t) {
    return t.numerical_value_in(ns);
  }
  
  // ============================================================================
  // ROOT → mp-units (Geant3 system: cm, s, GeV)
  // ============================================================================
  
  inline auto from_root_position(double root_cm) {
    return root_cm * cm;
  }
  
  inline auto from_root_energy(double root_gev) {
    return root_gev * hep::GeV;
  }
  
  inline auto from_root_time(double root_s) {
    return root_s * s;
  }
  
  // ============================================================================
  // mp-units → ROOT (extract as cm, GeV, s)
  // ============================================================================
  
  inline double to_root_position(quantity<isq::length[cm]> pos) {
    return pos.numerical_value_in(cm);
  }
  
  inline double to_root_energy(quantity<isq::energy[hep::GeV]> E) {
    return E.numerical_value_in(hep::GeV);
  }
  
  inline double to_root_time(quantity<isq::time[s]> t) {
    return t.numerical_value_in(s);
  }
  
  // ============================================================================
  // Cross-framework conversions through mp-units
  // ============================================================================
  
  // Geant4 → ROOT (the old way required manual factor: 0.1 for mm→cm)
  inline double g4_to_root_position(double g4_mm) {
    return to_root_position(from_g4_position(g4_mm).in(cm));
  }
  
  // Geant4 → ROOT energy (the old way required manual factor: 0.001 for MeV→GeV)
  inline double g4_to_root_energy(double g4_mev) {
    return to_root_energy(from_g4_energy(g4_mev).in(hep::GeV));
  }
  
}  // namespace interop
```

**Why this helps:**

- **Explicit conversions**: Each function documents which framework convention it assumes
- **Single source of truth**: If ROOT changes from GeV to MeV, update one place
- **Compile-time dimensional checking**: `from_g4_position(energy)` won't compile!
- **Zero-overhead**: All conversions inline away at `-O2`
- **Common language**: mp-units becomes the Rosetta Stone between frameworks


## Step 2: Write Type-Safe Analysis Code

Now write your analysis using mp-units, reading framework data through the interop layer:

```cpp
namespace analysis {
  using namespace mp_units;
  using namespace mp_units::si::unit_symbols;
  namespace hep = mp_units::hep::unit_symbols;
  
  // Type-safe particle representation
  struct TypedParticle {
    quantity<isq::momentum[hep::MeV / si::si_constants<>::speed_of_light_in_vacuum]> px, py, pz;
    quantity<isq::length[mm]> x, y, z;
    quantity<isq::time[ns]> t;
    quantity<isq::mass[hep::MeV / pow<2>(si::si_constants<>::speed_of_light_in_vacuum)]> mass;
    
    // Import from Geant4 data (mm, MeV, ns)
    static TypedParticle from_geant4(
        double g4_px, double g4_py, double g4_pz,
        double g4_x, double g4_y, double g4_z,
        double g4_t, double g4_mass) {
      return TypedParticle{
        .px = interop::from_g4_momentum(g4_px),
        .py = interop::from_g4_momentum(g4_py),
        .pz = interop::from_g4_momentum(g4_pz),
        .x = interop::from_g4_position(g4_x),
        .y = interop::from_g4_position(g4_y),
        .z = interop::from_g4_position(g4_z),
        .t = interop::from_g4_time(g4_t),
        .mass = interop::from_g4_mass(g4_mass)
      };
    }
    
    // Import from ROOT data (cm, GeV, s)
    static TypedParticle from_root(
        double root_px, double root_py, double root_pz,
        double root_x, double root_y, double root_z,
        double root_t, double root_mass) {
      return TypedParticle{
        // ROOT uses GeV/c, convert to MeV/c for consistency
        .px = interop::from_root_energy(root_px).in(hep::MeV / si::si_constants<>::speed_of_light_in_vacuum),
        .py = interop::from_root_energy(root_py).in(hep::MeV / si::si_constants<>::speed_of_light_in_vacuum),
        .pz = interop::from_root_energy(root_pz).in(hep::MeV / si::si_constants<>::speed_of_light_in_vacuum),
        // ROOT uses cm, convert to mm for consistency
        .x = interop::from_root_position(root_x).in(mm),
        .y = interop::from_root_position(root_y).in(mm),
        .z = interop::from_root_position(root_z).in(mm),
        // ROOT uses s, convert to ns for consistency
        .t = interop::from_root_time(root_t).in(ns),
        .mass = interop::from_root_energy(root_mass).in(hep::MeV / pow<2>(si::si_constants<>::speed_of_light_in_vacuum))
      };
    }
  };
  
  // Relativistic energy: E² = (pc)² + (mc²)²
  auto compute_energy(const TypedParticle& p) {
    using c = si::si_constants<>;
    auto p_mag = hypot(p.px, p.py, p.pz);
    auto p_squared = pow<2>(p_mag * c::speed_of_light_in_vacuum);
    auto m_squared = pow<2>(p.mass * pow<2>(c::speed_of_light_in_vacuum));
    return sqrt(p_squared + m_squared);
  }
  
  // Compute transverse momentum
  auto compute_pt(const TypedParticle& p) {
    return hypot(p.px, p.py);
  }
  
  // Compute pseudorapidity (dimensionless)
  double compute_eta(const TypedParticle& p) {
    auto pt = compute_pt(p);
    return 0.5 * std::log((p_mag + p.pz) / (p_mag - p.pz)).numerical_value_in(one);
  }
  
}  // namespace analysis
```

**Benefits vs. dimensional constants:**

      .z = units::from_position(z),
      .t = units::from_time(t),
      .mass = units::from_mass(mass)
    };
  }
};

}  // namespace modern
```

Now implement physics calculations with **compile-time dimensional analysis**:

```cpp
namespace modern {

// Compute kinetic energy with automatic unit checking
units::legacy_energy compute_energy(const TypedParticle& p) {
  auto p_squared = p.px * p.px + p.py * p.py + p.pz * p.pz;
  auto m_squared = p.mass * p.mass;
  
  // mp-units verifies: momentum² + mass² has dimensions of energy²
  return sqrt(p_squared + m_squared);
}

// Propagate with dimensional safety
void propagate(TypedParticle& p, units::legacy_position distance) {
  using namespace mp_units::si::unit_symbols;
  
  auto energy = compute_energy(p);
  
  // Relativistic velocity: v = pc²/E
  auto vx = p.px * pow<2>(c) / energy;
  auto vy = p.py * pow<2>(c) / energy;
  auto vz = p.pz * pow<2>(c) / energy;
  
  // Time to traverse distance
  auto speed = sqrt(vx*vx + vy*vy + vz*vz);
  auto delta_t = distance / speed;  // Automatic unit checking!
  
  // Update position and time
  p.x += vx * delta_t;
  p.y += vy * delta_t;
  p.z += vz * delta_t;
  p.t += delta_t;
}

}  // namespace modern
```

**What we gained:**

- ✅ **Cannot accidentally mix framework units**: `g4_energy + root_energy` won't compile!
- ✅ **Dimensional checking**: `position * energy` detected as error at compile time
- ✅ **Self-documenting**: Function signatures show units expected
- ✅ **Framework-agnostic physics**: Write once, works with any framework's data
- ✅ **No magic conversion factors**: `.in(cm)` is clearer than `* 0.1`


## Step 3: Practical Example - Event Analysis

Real workflow: Geant4 simulates, ROOT stores, analysis code processes:

```cpp
// Geant4 simulation produces particles (in G4 units: mm, MeV, ns)
void simulate_event(std::vector<double>& g4_momenta, 
                    std::vector<double>& g4_positions,
                    std::vector<double>& g4_times) {
  // ... Geant4 simulation fills vectors with doubles ...
  // Convention: momentum in MeV/c, position in mm, time in ns
}

// ROOT stores events (in ROOT units: cm, GeV, s)  
void store_to_root(const std::vector<double>& root_momenta,
                   const std::vector<double>& root_positions,
                   const std::vector<double>& root_times) {
  // ... write to ROOT TTree ...
  // Convention: momentum in GeV/c, position in cm, time in s
}

// Analysis code: type-safe, framework-independent
void analyze_particles() {
  using namespace mp_units;
  using namespace mp_units::si::unit_symbols;
  namespace hep = mp_units::hep::unit_symbols;
  
  // Read from Geant4
  std::vector<double> g4_px, g4_py, g4_pz, g4_x, g4_y, g4_z, g4_t;
  simulate_event(g4_px, g4_x, g4_t);
  
  // Convert to type-safe representation
  std::vector<analysis::TypedParticle> particles;
  for (size_t i = 0; i < g4_px.size(); ++i) {
    particles.push_back(analysis::TypedParticle::from_geant4(
      g4_px[i], g4_py[i], g4_pz[i],
      g4_x[i], g4_y[i], g4_z[i],
      g4_t[i], /* mass */ 105.66  // muon mass in MeV/c²
    ));
  }
  
  // Type-safe analysis
  for (const auto& p : particles) {
    auto energy = analysis::compute_energy(p);
    auto pt = analysis::compute_pt(p);
    
    // Select high-pt muons
    if (pt > 20.0 * hep::GeV / si::si_constants<>::speed_of_light_in_vacuum) {
      // Convert to ROOT units for storage
      std::vector<double> root_data;
      root_data.push_back(interop::to_root_energy(pt.in(hep::GeV)));
      root_data.push_back(interop::to_root_position(p.x.in(cm)));
      root_data.push_back(interop::to_root_time(p.t.in(s)));
      
      store_to_root(root_data, root_data, root_data);
    }
  }
}
```

**Key points:**

- Analysis code is **framework-agnostic** - works with data from any source
- Conversions are **explicit** and **localized** at boundaries
- Physics logic uses **natural units** (can mix MeV, GeV, keV freely)
- **Zero runtime cost** - all conversions inline away


## Step 4: Handling Configuration Files

Configuration files often use dimensional constants. Wrap them safely:

```cpp
namespace config {
  using namespace mp_units;
  using namespace mp_units::si::unit_symbols;
  namespace hep = mp_units::hep::unit_symbols;
  
  struct DetectorConfig {
    quantity<isq::length[mm]> inner_radius;
    quantity<isq::length[mm]> outer_radius;
    quantity<isq::energy[hep::MeV]> energy_threshold;
    
    // Parse from config file that uses G4 conventions
    static DetectorConfig from_file(const std::string& filename) {
      // Pseudocode: read values assuming G4 units
      double inner_mm, outer_mm, threshold_mev;
      // ... parse file ...
      
      return DetectorConfig{
        .inner_radius = interop::from_g4_position(inner_mm),
        .outer_radius = interop::from_g4_position(outer_mm),
        .energy_threshold = interop::from_g4_energy(threshold_mev)
      };
    }
    
    // Export to ROOT-compatible config
    void write_root_format(const std::string& filename) const {
      double inner_cm = interop::to_root_position(inner_radius.in(cm));
      double outer_cm = interop::to_root_position(outer_radius.in(cm));
      double threshold_gev = interop::to_root_energy(energy_threshold.in(hep::GeV));
      // ... write file ...
    }
  };
}
```


## Step 5: Python Bindings

Python bindings often expect raw doubles. Provide clean interfaces:

```cpp
#include <pybind11/pybind11.h>
namespace py = pybind11;

// Expose C++ analysis to Python with explicit unit documentation
PYBIND11_MODULE(analysis_module, m) {
  m.def("compute_energy_mev", 
    [](double px_mev, double py_mev, double pz_mev, double mass_mev) -> double {
      // Convert from Python doubles (MeV convention) to typed quantities
      auto p = analysis::TypedParticle::from_geant4(
        px_mev, py_mev, pz_mev,
        0, 0, 0,  // position not needed for energy
        0,        // time not needed
        mass_mev
      );
      
      // Compute with type safety
      auto energy = analysis::compute_energy(p);
      
      // Extract as MeV for Python
      return interop::to_g4_energy(energy.in(hep::MeV));
    },
    py::arg("px_mev"), py::arg("py_mev"), py::arg("pz_mev"), py::arg("mass_mev"),
    "Compute relativistic energy. All arguments in MeV or MeV/c.");
}
```


## Step 6: Migration Patterns Summary

| Pattern | When to Use | Example |
|---------|-------------|---------|
| **Interop Layer** | Crossing framework boundaries | `from_g4_position()`, `to_root_energy()` |
| **Type-Safe Analysis** | New physics code | `compute_energy()` with quantities |
| **Config Wrappers** | Reading/writing config files | `DetectorConfig::from_file()` |
| **Python Bindings** | Exposing to scripting | Thin wrappers with explicit unit docs |
| **Cross-Framework** | Multiple packages in one codebase | `g4_to_root_position()` through mp-units |


    if (E > 1000 * MeV) {  // Explicitly 1000 MeV - no ambiguity!
      modern::propagate(typed_p, 150 * mm);  // Explicitly 150 mm - no confusion!
    }
    
    p = typed_p.to_legacy();  // Write back to legacy struct
  }

## Best Practices for Dimensional Constant Migration

1. **Create centralized interop layer**
   - One file per framework (`g4_interop.h`, `root_interop.h`)
   - Document conventions clearly: "Geant4 uses mm, MeV, ns"
   - Test conversion factors with known values

2. **Start with highest-risk code**
   - Cross-framework boundaries (Geant4 → ROOT)
   - User-facing APIs (configuration, Python bindings)
   - Physics calculations mixing multiple frameworks

3. **Use consistent internal representation**
   ```cpp
   // Good: pick one internal unit system for analysis
   namespace analysis {
     using position_t = quantity<isq::length[mm]>;  // Always mm internally
     using energy_t = quantity<isq::energy[hep::MeV]>;  // Always MeV internally
   }
   
   // Bad: mixing units within analysis code
   auto pos_cm = ...; auto pos_mm = ...; // Which is which?
   ```

4. **Leverage dimensional analysis**
   ```cpp
   // mp-units catches errors that dimensional constants miss:
   
   // With dimensional constants:
   double bad = G4::mm * ROOT::GeV;  // Compiles! Wrong dimensions!
   
   // With mp-units:
   auto bad = 1*mm * 1*hep::GeV;  // Compile error: length * energy invalid!
   ```

5. **Don't fear conversion overhead**
   - Reality: `.in(cm)` compiles to zero-cost multiplication
   - Validate with compiler explorer or benchmarks
   - Modern optimizers eliminate all abstractions


## Common Pitfalls

❌ **Pitfall 1: Forgetting which framework convention applies**
   ```cpp
   // Bad: assumes Geant4 everywhere
   double position = g4_data * G4::mm;  // What if data came from ROOT (cm)?
   
   // Good: explicit conversions
   auto position = interop::from_g4_position(g4_data);
   ```

❌ **Pitfall 2: Silent dimensional constant mixing**
   ```cpp
   // Dimensional constants allow this error:
   double total = g4_energy + root_energy;  // MeV + GeV!
   
   // mp-units prevents it:
   auto total = g4_qty + root_qty;  // Compile error if units differ!
   ```

❌ **Pitfall 3: Manual conversion factors**
   ```cpp
   // Bad: magic numbers
   double root_cm = g4_mm * 0.1;  // Is 0.1 correct? Hard to verify!
   
   // Good: let mp-units handle it
   double root_cm = interop::g4_to_root_position(g4_mm);
   ```

❌ **Pitfall 4: Assuming all HEP systems are compatible**
   - Geant4, ROOT, CLHEP all use different base units!
   - Even when they seem compatible (both use "MeV"), representation may differ
   - Always go through explicit conversion layer


## Measuring Success

Track your migration with these metrics:

**Code quality metrics:**
- % of cross-framework calls using interop layer (target: 100%)
- % of new analysis functions accepting quantities (target: 100%)
- Number of unit-related bugs found in legacy code (decreases over time)

**Technical metrics:**
```cpp
// Count typed vs. untyped API boundaries
namespace metrics {
  constexpr int typed_boundaries = 45;    // Functions using interop layer
  constexpr int untyped_boundaries = 120; // Functions using raw doubles
  constexpr double migration_pct = 100.0 * typed_boundaries / (typed_boundaries + untyped_boundaries);
  
  static_assert(migration_pct > 25.0, "Migration goal: 25% by Q2 2026");
}
```


## Summary

**Dimensional constant migration strategy:**

1. ✅ **Create interop layer** with `from_framework()` / `to_framework()` functions
2. ✅ **Write new analysis in mp-units** (framework-agnostic)
3. ✅ **Convert at boundaries only** (minimize conversion overhead)
4. ✅ **Use mp-units as common language** between Geant4/ROOT/CLHEP
5. ✅ **Leverage compile-time checking** to catch dimensional errors

**Key advantages over dimensional constants:**

| Dimensional Constants | mp-units |
|----------------------|----------|
| `double total = g4_mev + root_gev;` ✗ Silent error | `auto total = g4_qty + root_qty;` ✓ Compile error if wrong |
| `double wrong = pos_mm * energy_mev;` ✗ Compiles | `auto wrong = pos * energy;` ✓ Dimensional analysis error |
| `double factor = G4::mm / ROOT::cm; // 0.1?` ✗ Manual math | `auto converted = pos.in(cm);` ✓ Automatic conversion |
| Function signatures hide units ✗ | Function signatures show units ✓ |
| Framework-specific ✗ | Framework-agnostic ✓ |

**Next steps:**

- Read [Interoperability with Other Libraries](../../how_to_guides/interoperability_with_other_libraries.md)
  for more patterns
- See [Working with Legacy Interfaces](../../how_to_guides/working_with_legacy_interfaces.md)
  for advanced techniques
- Review [From std::chrono](../../how_to_guides/migration/from_std_chrono.md) for similar
  migration patterns


## References

- [CERN ROOT](https://root.cern/) - Data analysis framework (uses cm, GeV, s)
- [Geant4](https://geant4.web.cern.ch/) - Particle simulation toolkit (uses mm, MeV, ns)
- [CLHEP](https://proj-clhep.web.cern.ch/) - Class library for HEP (uses mm, MeV, ns)
- [HSF Software Forum](https://hepsoftwarefoundation.org/) - HEP software collaboration
