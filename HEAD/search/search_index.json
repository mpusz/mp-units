{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to mp-units!","text":"<p>mp-units is a compile-time enabled feature-rich Modern C++ modular/header-only library that provides compile-time dimensional analysis and unit/quantity manipulation. Its key strengths include safety, performance, and developer experience.</p> <p>It is the first library on the market that, besides being unit-safe and dimension-safe, is also quantity-safe.</p> <p>The library source code is hosted on GitHub with a permissive MIT license.</p> Supported compilers <p>This library tries to provide the best user experience possible with the C++ language. To achieve that, it extensively uses the latest C++ language features.</p> <p>Even though the library benefits from the latest C++ versions (if available), C++20 is enough to compile and use all of the library's functionality.</p> <p>Please refer to C++ compiler support chapter for more details.</p> C++ modulesHeader files <pre><code>#include &lt;iostream&gt;\n#include &lt;print&gt;\nimport mp_units;\n\nusing namespace mp_units;\n\ninline constexpr struct smoot final : named_unit&lt;\"smoot\", mag&lt;67&gt; * usc::inch&gt; {} smoot;\n\nint main()\n{\n  constexpr quantity dist = 364.4 * smoot;\n  std::println(\"Harvard Bridge length = {::N[.1f]} ({::N[.1f]}, {::N[.2f]}) \u00b1 1 \u03b5ar\",\n               dist, dist.in(usc::foot), dist.in(si::metre));\n}\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n#include &lt;mp-units/systems/usc.h&gt;\n#include &lt;print&gt;\n\nusing namespace mp_units;\n\ninline constexpr struct smoot final : named_unit&lt;\"smoot\", mag&lt;67&gt; * usc::inch&gt; {} smoot;\n\nint main()\n{\n  constexpr quantity dist = 364.4 * smoot;\n  std::println(\"Harvard Bridge length = {::N[.1f]} ({::N[.1f]}, {::N[.2f]}) \u00b1 1 \u03b5ar\",\n               dist, dist.in(usc::foot), dist.in(si::metre));\n}\n</code></pre> <p>Output:</p> <pre><code>Harvard Bridge length = 364.4 smoot (2034.6 ft, 620.14 m) \u00b1 1 \u03b5ar\n</code></pre> <p>Try it on Compiler Explorer</p> What is <code>smoot</code>? <p>The smoot (/\u02c8smu\u02d0t/) is a nonstandard unit of length created as part of an MIT fraternity prank. It is named after Oliver R. Smoot, a fraternity pledge to Lambda Chi Alpha, who, in October 1958, lay on the Harvard Bridge (between Boston and Cambridge, Massachusetts) and was used by his fraternity brothers to measure the length of the bridge.</p> <p>One smoot equals Oliver Smoot's height at the time of the prank (five feet and seven inches). The bridge's length was measured to be 364.4 smoots plus or minus one ear, with the \"plus or minus\" intended to express the measurement uncertainty.</p> <p>Oliver Smoot graduated from MIT with the class of 1962, became a lawyer, and later became chairman of the American National Standards Institute (ANSI) and president of the International Organization for Standardization (ISO).</p> <p>More on the smoot unit of length can be found at https://en.wikipedia.org/wiki/Smoot.</p> <p>Important: Help needed!</p> <p>The mp-units library might be the subject of ISO standardization for C++29. More on this can be found in the following ISO C++ proposals:</p> <ul> <li>P1935: A C++ Approach to Physical Units,</li> <li>P2980: A motivation, scope, and plan for a physical quantities and units library,</li> <li>P3045: Quantities and units library.</li> </ul> <p>We are actively looking for parties interested in field-trialing the library.</p>"},{"location":"api_reference/","title":"API Reference - mp-units","text":""},{"location":"release_notes/","title":"Release Notes","text":""},{"location":"release_notes/#mp-units","title":"mp-units","text":""},{"location":"release_notes/#2.5.0","title":"2.5.0 WIP","text":"<ul> <li>(!) feat: representation concepts improved</li> <li>(!) feat: <code>representation_of</code> concept now also accepts a <code>quantity_spec</code> and accepts any representation character for quantity kinds</li> <li>(!) feat: <code>quantity::one()</code> removed</li> <li>(!) feat: <code>Representation</code> concept removed</li> <li>feat: <code>SymbolicArg</code> applied to expression templates</li> <li>feat: <code>per</code> and <code>power</code> made <code>final</code></li> <li>feat: <code>derived_XXX</code> are now constrained with <code>SymbolicConstant</code></li> <li>feat: prime factorization extended to any magnitude (thanks @chiphogg)</li> <li>feat: <code>cartesian_vector</code> added</li> <li>feat: <code>equivalent</code> now accept any units (even non-convertible)</li> <li>feat: text output should fallback to the portable mode when UTF-8 is not used for <code>text_encoding</code></li> <li>feat: precondition added to <code>to_u8string</code></li> <li>feat: text output of scaled units is now enclosed in parenthesis <code>(...)</code> instead of brackets <code>[...]</code></li> <li>feat: <code>abs(quantity)</code> exposed for conforming freestanding implementations</li> <li>feat: proper constraints for <code>kind_of</code></li> <li>feat: missing precondition added for <code>quantity::op/</code></li> <li>feat: <code>quantity_spec</code> conversions improved</li> <li>feat: <code>rankine</code> unit added</li> <li>feat: <code>std::numeric_limits</code> support added</li> <li>feat: <code>scaling_overflows_non_zero_values</code> added to detect conversions overflowing <code>rep</code></li> <li>feat: deprecation messages now provide the release version where the deprecation happened</li> <li>feat: electromagnetism.h updated to IEC80000-6-2022</li> <li>feat: <code>ConvertibleWithNumber</code> introduced to improve convertibility of unit <code>one</code> with raw numbers</li> <li>feat: <code>lerp</code> and <code>midpoint</code> for points added</li> <li>feat: <code>is_value_preserving</code> customization point added</li> <li>feat(example): <code>is_vector</code> specialization no longer needed for <code>si_constants</code></li> <li>(!) refactor: <code>type_list</code> moved to implementation details</li> <li>(!) refactor: from now <code>unit_symbol</code> and <code>dimension_symbol</code> always returns <code>std::string_view</code></li> <li>(!) refactor: <code>text_encoding</code> renamed to <code>character_set</code></li> <li>(!) refactor: <code>Magnitude</code> renamed to <code>UnitMagnitude</code> and <code>magnitude</code> to <code>unit_magnitude</code></li> <li>(!) refactor: <code>unit_magnitude</code> moved to <code>detail</code> namespace</li> <li>(!) refactor: <code>absolute</code> renamed to <code>point</code></li> <li>(!) refactor: <code>power</code> members refactored to be explicitly exposition only</li> <li>(!) refactor: <code>is_XXX</code> customization points for representation types removed</li> <li>(!) refactor: <code>quantity_values</code> renamed to representation values</li> <li>(!) refactor: <code>scalar</code> and <code>complex</code> characters renamed to <code>real_scalar</code> and <code>complex_scalar</code> respectively + concepts refactoring</li> <li>(!) refactor: <code>MagConstant</code> concept renamed to <code>detail::is_mag_constant</code> variable trait</li> <li>refactor: mp_units.core defined in terms of <code>core.h</code></li> <li>refactor: <code>MP_UNITS_NONCONST_TYPE</code> introduced to benefit from the C++23 feature</li> <li>refactor: <code>SymbolicConstant</code> concept refactored</li> <li>refactor: explicit type of <code>op/</code> for <code>quantity</code> and <code>reference</code> replaced with constrained placeholder</li> <li>refactor: private <code>unit_magnitude</code> interface renamed to not use leading <code>_</code></li> <li>refactor: <code>one_of</code> concept removed and replaced with <code>QSProperty</code> in <code>quantity_spec</code></li> <li>refactor: <code>std::is_trivial</code> will be deprecated in C++26</li> <li>refactor: <code>SameQuantitySpec</code> concept removed and replaced with direct comparison</li> <li>refactor: unused <code>SameReference</code> concept removed</li> <li>refactor: <code>type_name_less</code> introduced and used as a default predicate for expression templates</li> <li>refactor: \"expression templates\" renamed to \"symbolic expressions\"</li> <li>refactor: <code>all_are_kinds</code> removed and <code>get_associated_quantity</code> simplified</li> <li>refactor: <code>reference</code> now returns explicit types for <code>inverse</code>, <code>pow</code>, <code>sqrt</code>, and <code>cbrt</code></li> <li>refactor: repeated concept checks removed from <code>get_common_reference</code></li> <li>refactor: <code>std::assignable_from</code> used in <code>ValuePreservingTo</code> concept</li> <li>refactor: <code>quantity</code> constructor refactored to use another constructor with the result of <code>sudo_cast</code></li> <li>refactor: preconditions for quantity operations now use <code>is_neq_zero</code></li> <li>refactor: implicit expression variations used in <code>quantity</code> and <code>quantity_point</code> constraints</li> <li>refactor: <code>inverse()</code> constraints improved</li> <li>refactor: <code>make_quantity_point</code> introduced</li> <li>refactor: <code>point_origin_interface::op+</code> return type unified with the rest of the interfaces</li> <li>refactor: <code>std::convertible_to</code> replaced with <code>std::same_as</code> in <code>basic_fixed_string</code></li> <li>refactor: <code>less</code>, <code>ceil</code>, and <code>round</code> refactored and improved + more unit tests for <code>round</code></li> <li>refactor: <code>math_concepts.h</code> removed and concepts replaced with explicit expression in constraints</li> <li>refactor: <code>visit_format_arg</code> is deprecated in C++26</li> <li>refactor: deprecated literal operators</li> <li>refactor: constraints refactoring</li> <li>(!) fix: <code>electric_current_phasor</code>, <code>voltage_phasor</code>, <code>apparent_power</code> switched to complex character</li> <li>(!) fix: <code>position_vector</code> and <code>displacement</code> moved to a different place in a tree</li> <li>(!) fix: <code>velocity</code> is now defined in terms of <code>displacement</code> instead of <code>position_vector</code></li> <li>fix: missing <code>core.h</code> added to CMake</li> <li>fix: <code>const</code> was leaking to some <code>SymbolicConstant</code>s</li> <li>fix: <code>make_reference</code> should skip only the exact kinds deduced from a unit</li> <li>fix: inconsistencies in <code>get_common_quantity_spec()</code> fixed</li> <li>fix: unused <code>convertible_kinds()</code> argument removed</li> <li>fix: compile-time branch condition fixed in <code>quantity_point::point_for</code></li> <li>fix: <code>inverse(Quantity)</code> fixed for subkinds of <code>dimensionless</code></li> <li>fix: <code>point_origin_interface::op+</code> constraints fixed</li> <li>fix: missing <code>get_common_unit()</code> overload added</li> <li>fix: <code>floor</code> and <code>ceil</code> constraints fixed</li> <li>fix: quantity characters fixed in electromagnetism quantities</li> <li>fix: <code>arg.visit</code> support fixed</li> <li>fix: <code>expr_less</code> now also sorts powers</li> <li>fix: <code>mag_constant</code> workarounds branches for clang fixed</li> <li>fix: checking for clang versions fixed in CMake scripts</li> <li>fix: text stripping in <code>type_name</code> fixed</li> <li>test: lots of tests for complex quantities</li> <li>test: runtime unit tests refactored to have a bigger granularity (less top level tests)</li> <li>test: surface tension replaced with entropy in an fmt test</li> <li>test: test_package now is tested also with C++20 modules</li> <li>test: tests for dimensionless quantities static data members</li> <li>test: a few more natural units tests added</li> <li>test: tests to check if <code>quantity</code> satisfies <code>Scalar</code></li> <li>test: add static tests for concept <code>DimensionOf</code> (thanks @jvocht)</li> <li>test: quantity character concepts tests for quantities added</li> <li>docs: ISQ part 6 released</li> <li>docs: new chapter about our documentation added to the contributing guide</li> <li>docs: directory name updated in the contributing guide</li> <li>docs: mp-units Conan options added to conanfile.txt examples</li> <li>docs: <code>contracts</code> Conan option default value description improved</li> <li>docs: outdated note removed from the \"Text Output\" chapter</li> <li>docs: a paragraph about additional formatting options removed (applicable only to quantity symbols which we do not support)</li> <li>docs: Wroc\u0142aw 2024 meeting report</li> <li>docs: explicit unit conversion example added to the \"Symbols of common units\" chapter</li> <li>docs: \"Bringing Quantity-Safety To The Next Level\" blog post added</li> <li>docs: quantity-safety mentioned in the docs</li> <li>docs: <code>complex</code> character added to the \"Quantity character\" chapter</li> <li>docs: intro to \"Value Conversions\" chapter added</li> <li>docs: \"Scaling overflow prevention\" chapter added</li> <li>docs: \"Concepts\" chapter updated</li> <li>docs: old customization points removed from the \"Character of a Quantity\" chapter</li> <li>docs: clang-19 issues mentioned in a compiler support table</li> <li>docs(ref): document most of <code>mp_units.core</code> (thanks @JohelEGP)</li> <li>build: <code>CheckCacheVarValues</code> CMake module file added</li> <li>build: <code>MP_UNITS_DEV_TIME_TRACE</code> CMake option added</li> <li>build: <code>MP_UNITS_API_NO_CRTP</code> removed from <code>test_package</code> CMake</li> <li>build: require at least CMake 3.31 with Conan</li> <li>build: clang-20 enabled in CI</li> <li>build: clang-19 support removed from conanfile.py</li> <li>build: clang-20.1 workaround added to <code>package_info</code></li> <li>build: update dependencies to gsl-lite/0.42.0, ms-gsl/4.1.0, fmt/11.1.4, and catch2/3.8.0</li> <li>build: suppress warnings for gcc-12 in conanfile</li> <li>ci: CI matrix generation added (thanks @burnpanck)</li> <li>ci: <code>import_std</code> now checks if at least C++23 is being used</li> <li>perf: caching of the results of heavy <code>consteval</code> functions execution added</li> <li>perf: <code>expr_projectable</code> concept removed to improve compilation performance</li> </ul>"},{"location":"release_notes/#2.4.0","title":"2.4.0 November 5, 2024","text":"<ul> <li>(!) feat: <code>phase_velocity</code> and <code>group_velocity</code> aliases removed from ISQ by ISO</li> <li>feat: <code>iec::bit</code> using-declared in <code>iec::unit_symbols</code></li> <li>feat: common unit symbols now use <code>EQUIV{u1, u2, ...}</code> syntax</li> <li>feat: <code>scaled_unit</code> symbol printing improved (<code>[]</code> around the entire unit, small magnitude values do not use a power of <code>10</code> anymore)</li> <li>feat: <code>scaled_unit</code> does not have a priority over <code>derived_unit</code> anymore</li> <li>feat: fractional exponents support added to <code>mag_power</code></li> <li>feat: tag types are now required to be empty</li> <li>feat: magnitude text now obeys formatting parameters and knows how to print constants</li> <li>feat: added support for printing powers of magnitude constants</li> <li>feat: <code>SymbolicConstant</code> concept added</li> <li>feat: <code>common_unit</code> selection algorithm improved to make <code>rev + rad</code> return <code>rad</code></li> <li>feat: litre text symbol changed from <code>l</code> to <code>L</code> to avoid ambiguity with <code>1</code></li> <li>feat: alternative litre unit symbol <code>L</code> added to prevent ambiguities with <code>1</code></li> <li>feat: Unicode unit symbols</li> <li>feat: <code>\u03c0</code> added as an alias for <code>pi</code></li> <li>feat: <code>expr_pow</code> extended to remove redundancy in callers</li> <li>feat: <code>DerivedDimensionExpr</code>, <code>DerivedQuantitySpecExpr</code> and <code>DerivedUnitExpr</code> removed</li> <li>feat: <code>MagnitudeSpecExpr</code> and <code>PowerVBase</code> removed and some functions renamed to limit possible ambiguity in overload resolution</li> <li>feat: <code>std::is_object</code> constraint applied to <code>value_type_t</code></li> <li>feat: <code>quantity_values</code> are now defined on top of <code>std::chrono::duration_values</code></li> <li>feat: from now on truncation is not allowed in compound assignment</li> <li>feat(example): currency example now uses <code>chrono::time_point</code> and has better interfaces</li> <li>feat(example): <code>treat_as_floating_point</code> specializations for examples' types removed</li> <li>(!) refactor: all <code>iec</code> quantity specifications are now deprecated and moved to <code>isq</code></li> <li>(!) refactor: <code>mag_constant</code> now takes a symbol and a value and the class deriving from it must be final</li> <li>(!) refactor: <code>op==(U1, U2)</code> now checks for the same type (old behavior available as <code>equivalent(U1, U2)</code>) + <code>convertible</code> now verifies associated <code>quantity_spec</code> as well</li> <li>(!) refactor: <code>ascii</code> -&gt; <code>portable</code>, <code>unicode</code> -&gt; <code>utf8</code>, 'A' -&gt; 'P'</li> <li>(!) refactor: <code>char_traits</code> removed from <code>fixed_string</code></li> <li>(!) refactor: convertibility traits and concepts refactored to use <code>bool</code> flags instead of wrappers</li> <li>(!) refactor: tag types should not expose their members</li> <li>refactor: <code>convertible(U1, U2)</code> implementation simplified</li> <li>refactor: <code>abs</code> moved to <code>constexpr_math.h</code></li> <li>refactor: <code>unit_symbol_impl</code> simplified</li> <li>refactor: <code>unit_symbol_formatting</code> moved to a dedicated header file</li> <li>refactor: <code>shorten_T</code> removed</li> <li>refactor: magnitude interface cleanup</li> <li>refactor: <code>derived_from_the_same_base_dimension</code> no longer needed</li> <li>refactor: <code>one_of</code> usage removed from the <code>fixed_string</code> deduction guides</li> <li>refactor: <code>quantity.h</code> is not needed in <code>constants.h</code> (<code>unit.h</code> is enough)</li> <li>refactor: <code>SameDimension</code> concept is not needed and can be inlined in <code>DimensionOf</code></li> <li>refactor: framework Unicode symbols are now spelled using their codes</li> <li>refactor: <code>QuantitySpecWithNoSpecifiers</code> removed and <code>kind_of</code> definition simplified</li> <li>refactor: <code>treat_as_floating_point</code> simplified and extended to use <code>std::chrono::treat_as_floating_point_v</code></li> <li>refactor: <code>wrapped_type_t</code> reuses <code>std::indirectly_readable_traits</code></li> <li>refactor: <code>expr_fractions</code> takes direct <code>OneType</code> type now instead of a trait</li> <li>refactor: Unicode symbols description reworked based on the latest SG16 recommendations</li> <li>refactor: <code>Mutable</code> concept applied to <code>quantity</code> and <code>quantity_point</code></li> <li>refactor: <code>explicit</code> cleanup for deduction guides of <code>quantity</code> and <code>quantity_point</code></li> <li>refactor: <code>point_origin_interface::op-</code> cleanup</li> <li>refactor: <code>QuantityLikeImpl</code> refactored to conform to API Reference by @JohelEGP</li> <li>refactor: <code>get_complexity</code> refactored to be 0-based and not account for a number of arguments in a list</li> <li>refactor: <code>get_complexity</code> refactored to returned maximum complexity of an element (instead of the sum of elements)</li> <li>refactor(test): <code>derived_quantity</code> refactored to <code>child_quantity</code></li> <li>fix: missing <code>are_ingredients_convertible</code> overloads added</li> <li>fix: constraints for magnitude added for <code>scaled_unit</code> and fixed <code>common_unit</code> instantiating it incorrectly</li> <li>fix: according to ISO 80000-16 <code>%</code> should always be prefixed with space</li> <li>fix: extraneous space in unit symbol having only denominators removed</li> <li>fix: explicit cast added to <code>less</code> for magnitudes to fix clang-arm64 conversion error</li> <li>fix: <code>common_unit</code> handling fixed for some corner cases</li> <li>fix: math functions constraints fixed</li> <li>fix: <code>operator*(M, U u)</code> fixed for <code>U</code> being <code>scaled_unit</code></li> <li>fix: subsumption of <code>QuantityKindSpec</code> fixed</li> <li>fix: <code>ValuePreservingTo</code> fixed to apply <code>std::remove_cvref_t</code> on <code>FromRep</code></li> <li>fix: compound assignment operations on quantities now behave the same as on the underlying representation types</li> <li>fix: <code>QuantityConvertibleTo</code> used in <code>quantity_point</code> compound assignment</li> <li>fix: <code>convertible_kinds</code> implementation fixed</li> <li>fix(tests): freestanding build fixed</li> <li>test: unit tests for the inverse of <code>mag_constant</code> added</li> <li>test: Unicode symbols used in unit tests</li> <li>test: more <code>std::chrono</code> tests added</li> <li>test: commutativity tests added to ISQ</li> <li>test: one <code>kind_of</code> test added to reference tests</li> <li>test: <code>pow&lt;0&gt;</code> and <code>pow&lt;1&gt;</code> tests added for dimensions</li> <li>test: more <code>get_common_quantity_spec</code> tests added</li> <li>build: setting of some test_package CMake options enabled only for a <code>cxx_modules</code> build</li> <li>ci: <code>sudo apt update</code> added for documentation.yml in hope that it will resolve missing system packages issue</li> <li>ci: MSVC added to the CI</li> <li>ci: the latest not-released docs will use \"HEAD\" as a version from now on</li> <li>ci: documentation action should run on a new tag as well</li> <li>ci: documentation action limited only to commits that change documentation files</li> <li>ci: non-documentation actions should not run on tags</li> <li>docs: missing systems added to the \"Project Structure\" chapter</li> <li>docs: graphs of ISQ kind hierarchies improved</li> <li>docs: category of the ISO meeting reports changed to \"WG21 Updates\"</li> <li>docs: blog comments support added</li> <li>docs: Part 1-5 articles of the ISQ series added</li> <li>docs: \"Symbols of scaled units\" chapter added + minor updates to scaled and common units chapters</li> <li>docs: conan profile updated to present gcc-14 instead of gcc-12 which is no longer supported</li> <li>docs: \"Why derived units order is not preserved from the multiplication?\" chapter added to FAQ</li> <li>docs: \"Many shades of the same unit\" extended with a note about the derived units order</li> <li>docs: API Reference now presents index.html instead of full.hml</li> </ul>"},{"location":"release_notes/#2.3.0","title":"2.3.0 September 27, 2024","text":"<ul> <li>(!) feat: <code>delta</code> and <code>absolute</code> construction helpers</li> <li>(!) feat: Conan and CMake options changed as requested at ConanCenter code review</li> <li>(!) feat: <code>unit_can_be_prefixed</code> removed - from now on all named units can be prefixed</li> <li>feat: formatting functions for units and dimensions marked as <code>constexpr</code> to enable compile-time text formatting</li> <li>feat: <code>qp1.quantity_from(qp2)</code> added</li> <li>feat: non-member <code>swap</code> added for <code>fixed_string</code></li> <li>feat: simplified <code>inplace_vector</code> added</li> <li>feat: text output for angular units improved (space before symbol removed)</li> <li>feat: representation type template parameter added to value conversion functions</li> <li>feat: all tags in the expression templates are now ordered by the type names</li> <li>feat: convertibility of a quantity with a unit <code>one</code> with the raw value added</li> <li>feat: <code>import std;</code> support added</li> <li>feat: compute values for rational magnitude powers (thanks @chiphogg)</li> <li>feat: <code>value_cast&lt;Representation, Unit&gt;()</code> complementary conversion function added</li> <li>feat: <code>hw_voltage</code> example added</li> <li>feat: <code>MP_UNITS_IMPORT_STD</code> and <code>MP_UNITS_MODULES</code> handled properly in <code>test_package.cpp</code></li> <li>feat: <code>complex</code> quantity character added</li> <li>feat: <code>iec::var</code> unit added</li> <li>feat: <code>type_list_unique</code> added</li> <li>feat: <code>for_each</code> on <code>std::tuple</code> added</li> <li>feat: <code>common_unit</code> support added</li> <li>(!) refactor: <code>quantity_point_like_traits</code> now use numerical value instead of the quantity</li> <li>(!) refactor: <code>iec80000</code> system renamed to <code>iec</code></li> <li>(!) refactor: <code>mag_pi</code> is now <code>mag&lt;pi&gt;</code></li> <li>(!) refactor: <code>common_XXX()</code> functions renamed to <code>get_common_XXX()</code></li> <li>refactor: error messages-related improvements</li> <li>refactor: <code>[[nodiscard]]</code> and <code>consteval</code> set for some magnitude-related functions</li> <li>refactor: degree Celsius and Fahrenheit symbols text now use Unicode codepoints</li> <li>refactor: <code>dimension_symbol</code> and <code>units_symbol</code> refactored to use <code>inplace_vector</code></li> <li>refactor: <code>unit_symbol</code> and <code>dimension_symbol</code> refactored for readability and <code>consteval</code></li> <li>refactor: binary operators of <code>quantity</code> and <code>quantity_point</code> are now hidden friends</li> <li>refactor: tag types-related operators are now hidden friends as well</li> <li>refactor: <code>ValuePreservingTo</code> concept added</li> <li>refactor: perfect forwarding interfaces improved</li> <li>refactor: <code>Representation</code> concepts now requires <code>WeaklyRegular</code> instead of <code>std::regular</code></li> <li>refactor: <code>quantity_point</code> default-constructibility removed from the <code>quantity_from</code> constraints</li> <li>refactor: <code>has_common_type_v</code> simplified</li> <li>refactor: <code>is_power_of_quantity_spec</code> and <code>is_power_of_dim</code> variable templates converted to concepts</li> <li>refactor: unnecessary custom versions of <code>is_specialization_of</code> removed</li> <li>refactor: <code>is_derived_from_specialization_of_v</code> added and applied to remove custom traits</li> <li>fix: signatures of capacity functions of <code>fixed_string</code> fixed</li> <li>fix: <code>MP_UNITS_API_NO_CRTP</code> handling fixed</li> <li>fix: <code>MP_UNITS_HOSTED</code> branch added to <code>core.h</code></li> <li>fix: mkdocs dependencies fixed in the gitpod dockerfile</li> <li>fix: <code>MP_UNITS_API_CONTRACTS</code> should have a priority over headers availability</li> <li>fix: <code>si.h</code> and <code>angular.h</code> now properly include <code>hacks.h</code> to define <code>MP_UNITS_HOSTED</code> before its usage</li> <li>fix: quantity scaling between different prefixes improved</li> <li>fix: conversion operator to <code>std::chrono</code> types fixed</li> <li>fix: <code>std::format</code> does not always use <code>Char*</code> as iterators</li> <li>fix: <code>complex_power</code> &amp; co fixed</li> <li>fix: <code>__cpp_deleted_function</code> workaround for clang-19 added</li> <li>test: conversion to chrono unit tests added</li> <li>test: unit tests for creating a quantity from a <code>volatile</code> variable</li> <li>test: increase tolerance for certain math tests to two epsilon by @burnpanck</li> <li>test: <code>std::complex</code>-based quantities tests added</li> <li>build: conanfile bumped to use <code>catch2/3.7.0</code></li> <li>build: conanfile bumped to use <code>fmt/11.0.1</code></li> <li>build: minimum required CMake version bumped to 3.25</li> <li>build: duplicated <code>cmake_minimum_required</code> commands removed</li> <li>build: minimum conan version set to 2.0.15</li> <li>build: MSVC compilation enabled for the library part by @czjhoppe</li> <li>build: Dockerfile updated for gitpod</li> <li>build: <code>generate()</code> in <code>test_package</code> now correctly propagates project's options</li> <li>build: <code>target_include_directories</code> is not needed anymore</li> <li>build: <code>target_compile_features</code> now uses <code>CMAKE_CXX_STANDARD</code></li> <li>build: <code>package_type</code> is dynamically set in conanfile.py depending if we build modules or not</li> <li>build(conan): packaging improved</li> <li>ci: added test for upstream clang on macos-14, as an example for an arm64 platform by @burnpanck</li> <li>style: pre-commit updated to clang-format-18.1.8</li> <li>docs: \"Strong Angular System\" chapter added</li> <li>docs: docs updated to use new spelling for Conan options</li> <li>docs: \"Interface Introduction\" chapter updated</li> <li>docs: St. Louis 2024 report added</li> <li>docs: \"Radians and degrees support\" added</li> <li>docs: Rework of \"Getting Started\" section</li> <li>docs: \"API Reference\" support added (thanks @JohelEGP)</li> <li>docs: \"Generating API reference\" chapter added</li> <li>docs: minor formatting and spelling improvements to the \"CONTRIBUTING.md\"</li> <li>docs: \"Unit symbols\" chapter added</li> <li>docs: examples line numbers fixed</li> <li>docs: \"Text Formatting\" tag removed from avg_speed example</li> <li>docs: line breaks in mermaid graphs fixed</li> <li>docs: 2.3.0 release added</li> </ul>"},{"location":"release_notes/#2.2.1","title":"2.2.1 July 3, 2024","text":"<ul> <li>(!) feat: Conan and CMake options refactored</li> </ul>"},{"location":"release_notes/#2.2.0","title":"2.2.0 June 14, 2024","text":"<ul> <li>(!) feat: C++ modules support added by @JohelEGP</li> <li>(!) feat: New formatting specification implemented</li> <li>(!) feat: <code>has_unit_symbol</code> support removed</li> <li>(!) feat: ABI concerns resolved with introduction of u8 strings for symbols</li> <li>(!) feat: API-related Conan, CMake, and preprocessor options redesigned</li> <li>(!) feat: <code>core.h</code> removed</li> <li>(!) feat: from now on units, dimensions, quantity specifications, and point origins have to be marked as <code>final</code></li> <li>feat: implicit point origins support added</li> <li>feat: unit default point origin support added</li> <li>feat: <code>fma</code>, <code>isfinite</code>, <code>isinf</code>, and <code>isnan</code> math function added by @NAThompson</li> <li>feat: <code>fma</code> for quantity points added</li> <li>feat: <code>quantity_point</code> support added for <code>quantity_cast</code> and <code>value_cast</code></li> <li>feat: <code>value_cast&lt;Unit, Representation&gt;</code> added</li> <li>feat: <code>value_cast&lt;Quantity&gt;(q)</code>, <code>value_cast&lt;Quantity&gt;(qp)</code> and <code>value_cast&lt;QuantityPoint&gt;(qp)</code> added by @burnpanck</li> <li>feat: <code>interconvertible(quantity_spec, quantity_spec)</code> added</li> <li>feat: <code>qp.quantity_from_zero()</code> added</li> <li>feat: <code>value_type</code> type trait added</li> <li>feat: do not print space between a number and <code>percent</code> or <code>per_mille</code></li> <li>feat: <code>ppm</code> parts per million added by @nebkat</li> <li>feat: <code>atan2</code> 2-argument arctangent added by @nebkat</li> <li>feat: <code>fmod</code> floating-point division remainder added by @nebkat</li> <li>feat: <code>remainder</code> IEEE division remainder added by @nebkat</li> <li>feat: <code>std::format</code> support added</li> <li>feat: unit text output support added</li> <li>feat: formatting error messages improved</li> <li>feat: improve types readability by eliminating extraneous <code>()</code> in references, prefixes, and <code>kind_of</code></li> <li>feat: dimension and unit text output added</li> <li>feat: some light and radiation ISQ quantities added</li> <li>feat: allow configuring GSL library use</li> <li>feat: freestanding support added</li> <li>(!) refactor: <code>zero_Fahrenheit</code> renamed to <code>zeroth_degree_Fahrenheit</code></li> <li>(!) refactor: SI-related trigonometric functions moved to the <code>si</code> subnamespace</li> <li>(!) refactor: <code>math.h</code> header file broke up to smaller pieces</li> <li>(!) refactor: <code>fixed_string</code> interface refactored</li> <li>(!) refactor: <code>ReferenceOf</code> does not take a dimension anymore</li> <li>(!) refactor: 'o' replaced with '1' as a modifier for <code>unit_symbol_solidus::one_denominator</code></li> <li>(!) refactor: <code>get_kind()</code> now returns <code>kind_of</code></li> <li>(!) refactor: FMT macros moved to <code>compat_macros.h</code></li> <li>(!) refactor: <code>fixed_string</code> refactored to reflect the latest changes to P3094R2</li> <li>(!) refactor: <code>basic_symbol_text</code> renamed to <code>symbol_text</code></li> <li>(!) refactor: <code>ratio</code> hidden as an implementation detail behind <code>mag_ratio</code></li> <li>(!) refactor: <code>framework.h</code> introduced</li> <li>(!) refactor: type list tools made an implementation detail of the library</li> <li>(!) refactor: header files with the entire system definitions moved up in the directory tree</li> <li>(!) refactor: <code>absolute_point_origin</code> does not use CRTP anymore</li> <li>refactor: system's units do not inherit from one another anymore</li> <li>refactor: all units made <code>final</code></li> <li>refactor: math functions constraints refactored</li> <li>refactor: <code>si_quantities.h</code> added to improve compile-times</li> <li>refactor: <code>validate_ascii_string</code> refactored to <code>is_basic_literal_character_set</code></li> <li>refactor: <code>underlying_type</code> split to <code>wrapped_type</code> and <code>value_type</code> and used in code</li> <li>refactor: code refactored to comply with clang-tidy</li> <li>refactor: remove dependency on <code>&lt;ranges&gt;</code> header and switch to use an iterator-based <code>copy</code> algorithm</li> <li>refactor: <code>terminate</code> replaced with <code>abort</code> and a header file added</li> <li>refactor: most <code>std::remove_const_t</code> removed and some replaced with the GCC-specific workaround</li> <li>refactor: not needed <code>remove_reference_t</code> and <code>remove_cvref_t</code> removed</li> <li>refactor: binary operators of <code>quantity</code> and <code>quantity_point</code> are now hidden friends</li> <li>fix: <code>QuantityLike</code> conversions required <code>Q::rep</code> instead of using one provided by <code>quantity_like_traits</code></li> <li>fix: <code>quantity_spec[Unit]</code> replaced with <code>make_reference</code> in <code>value_cast</code></li> <li>fix: <code>ice_point</code> is now defined with the integral offset from <code>absolute_zero</code></li> <li>fix: performance regression in <code>sudo_cast</code> fixed</li> <li>fix: explicit object parameter support fixed</li> <li>fix: missing <code>version</code> header file added to <code>hacks.h</code></li> <li>fix: <code>quantity_cast</code> to accept lvalue references (thanks @burnpanck)</li> <li>fix: <code>value_cast</code> with lvalue references to <code>quantity_point</code> (thanks @burnpanck)</li> <li>docs: project blog and first posts added</li> <li>docs: project documentation layout refactored</li> <li>docs: \"Interoperability with Other Libraries\" chapter added</li> <li>docs: \"Framework Basics\" chapters updated and cleaned up</li> <li>docs: <code>smoot</code> unit example added to the main page</li> <li>docs: \"Code Example\" chapter renamed to \"Look and Feel\" and reordered in TOC to be after \"Quick Start\"</li> <li>docs: \"Quick Start\" chapter reworked to be simpler and include quantity points</li> <li>docs: \"Quantity points\" chapter extended</li> <li>docs: \"The Affine Space\" chapter updated to reflect the recent design changes</li> <li>docs: \"Working with Legacy interfaces\" chapter added</li> <li>docs: \"Text Output\" chapter updated</li> <li>docs: mkdocs social plugin enabled</li> <li>docs: project logo and custom color scheme added</li> <li>docs: minimum compiler requirements updated</li> <li>docs: unit symbols admonition extended in the \"Quick Start\" chapter</li> <li>docs: Cairo dependency described in the MkDocs section</li> <li>docs: \"hello units\" example updated with dimensions output</li> <li>docs: \"Text Output\" chapter updated with the recent formatting changes</li> <li>docs: formatting grammar language changed to EBNF</li> <li>docs: \"Project structure\" chapter expanded</li> <li>docs: CITATION.cff updated</li> <li>(!) build: Conan and CMake options refactored</li> <li>(!) build: <code>MP_UNITS_AS_SYSTEM_HEADERS</code> renamed to <code>MP_UNITS_BUILD_AS_SYSTEM_HEADERS</code></li> <li>(!) build: <code>MP_UNITS_BUILD_LA</code> and <code>MP_UNITS_IWYU</code> CMake options now have <code>_DEV_</code> in the name</li> <li>build: gsl-lite updated to 0.41.0</li> <li>build: catch2 updated to 3.5.1</li> <li>build: fmt updated to 10.2.1</li> <li>build: gitpod environment updated</li> <li>build: <code>check_cxx_feature_supported</code> added</li> <li>build: IWYU path handling fixed</li> <li>build: IWYU enabled on GCC</li> <li>build: <code>CMAKE_EXPORT_COMPILE_COMMANDS</code> flag enabled for the developer's build</li> <li>build(conan): <code>generate()</code> now set <code>cache_variables</code></li> <li>build(conan): <code>can_run</code> check added before running tests</li> <li>ci: Conan and CMake CI now use different cache names</li> <li>ci: gcc-14 added</li> <li>ci: <code>clang-tidy</code> CI added</li> </ul>"},{"location":"release_notes/#2.1.1","title":"2.1.1 May 16, 2024","text":"<ul> <li>fix: unit tests compilation on gcc-14 fixed</li> <li>fix: explicit <code>this</code> parameter support fixed</li> </ul>"},{"location":"release_notes/#2.1.0","title":"2.1.0 December 9, 2023","text":"<ul> <li>(!) feat: <code>inverse()</code> support added for dimensions, quantity_spec, units, and references             (<code>1 / s</code> will now create <code>quantity</code> and not a <code>Unit</code>)</li> <li>(!) feat: <code>quantity_point</code> does not provide <code>zero()</code> anymore</li> <li>(!) feat: <code>quantity_spec</code> and its kind should not compare equal</li> <li>(!) feat: mutating interface removed from <code>fixed_string</code></li> <li>(!) feat: <code>common_type</code> with a raw value is not needed anymore as for a long time now raw values are   not convertible to the dimensionless quantities</li> <li>(!) feat: <code>symbol_text</code> definition simplified</li> <li>(!) feat: users are now allowed to inherit their own types from absolute point origins</li> <li>(!) feat: interoperability with other libraries redesigned</li> <li>feat: <code>basic_fixed_string(const CharT*, std::integral_constant&lt;std::size_t, N&gt;)</code> constructor added</li> <li>feat: <code>isq::activity</code> added and <code>becquerel</code> definition updated to benefit from it</li> <li>feat: <code>gray</code> and <code>sievert</code> now have correct associated quantity kinds</li> <li>feat: <code>UnitCompatibleWith</code> concept added and applied to <code>in(U)</code> and <code>force_in(U)</code> functions</li> <li>feat: quantities can now be multiplied and divided by units (no parenthesis needed anymore)</li> <li>feat: <code>Magnitude / Unit</code> operator added</li> <li>feat: equality for dimensions now will allow derived classes as well (but not from <code>derived_dimension</code>)</li> <li>feat: <code>zero_Fahrenheit</code> point origin added</li> <li>feat: equivalent point origins handling improved</li> <li>feat(example): unit symbols added to the currency example</li> <li>(!) refactor: <code>unit_symbol&lt;fmt&gt;(U)</code> signature refactored and the resulting text can now also be used at runtime</li> <li>(!) refactor: <code>make_xxx</code> factory functions replaced with two-parameter constructors</li> <li>(!) refactor: <code>unit_symbol</code> changed to <code>consteval</code></li> <li>refactor: <code>in(U)</code> and <code>force_in(U)</code> now return <code>auto</code> to provide better diagnostics on clang</li> <li>refactor: <code>quantity</code> operators constraints refactored</li> <li>refactor: more type members added to <code>fixed_string</code> definition</li> <li>refactor: <code>unit_symbol_formatting</code> enums now use <code>std::int8_t</code> as a representation type</li> <li>fix: symbols of named dimensionless units with the ratio = 1 were not printed</li> <li>fix: iterator is now properly updated for all cases in <code>unit_symbol</code></li> <li>fix: Fahrenheit conversion ratio was inverted</li> <li>fix: <code>CommonlyInvocableQuantities</code> was overconstrained for the current library design</li> <li>fix: <code>are_ingredients_convertible</code> now mandates explicit conversion for <code>To</code> dimensionless quantities</li> <li>fix: <code>quantity_point::point_for(PO)</code> constraints fixed</li> <li>fix(example): <code>latitude</code> and <code>longitude</code> fixed to include <code>0</code> for <code>N</code> and <code>E</code> respectively</li> <li>ci: clang-17 enabled</li> <li>ci: apple-clang-15 enabled</li> <li>ci: Added C++23 builds to the CI matrix</li> <li>docs: \"Getting Started\" chapters updated</li> <li>docs: \"Basic Concepts\" and \"Interface Introduction\" chapters updated</li> <li>docs: \"Design Overview\" chapter added and \"Concepts\" chapter reworked</li> <li>docs: \"Output stream formatting\" chapter updated</li> <li>docs: \"Default formatting\" chapter updated</li> <li>docs: \"Derived unit symbols generation\" chapter added</li> <li>docs: outdated affine space chapter updated</li> <li>docs: <code>CameCase</code> concept identifiers FAQ added</li> <li>docs: <code>gravitational_potential_energy</code> equation fixed on a graph</li> <li>docs: YouTube video link updated to the C++ on Sea 2023</li> <li>docs: ISO papers reference added to docs and README</li> <li>docs: a representation type in a dimensionless quantity FAQ fixed</li> <li>docs: titles added to some important admonitions</li> <li>docs: \"Terms and Definitions\" slightly updated</li> <li>docs: \"canonical unit\" added to glossary and its documentation in code was updated</li> <li>docs: Design overview graph updated</li> </ul>"},{"location":"release_notes/#2.0.0","title":"2.0.0 September 24, 2023","text":"<ul> <li><code>units</code> namespace renamed to <code>mp_units</code> (#317)</li> <li>header files in the <code>&lt;mp-units/...&gt;</code> rather then in <code>&lt;units/...&gt;</code> (#317)</li> <li>the downcasting facility is removed (#383, #211, #32)</li> <li>unified and simplified quantity creation (#274)</li> <li>determining the best way to create a quantity (#413)</li> <li>V2 <code>quantity_point</code> (#414)</li> <li>introduction of <code>quantity_spec</code> to store not only <code>dimension</code> but also additional information about quantities (#405)</li> <li><code>quantity</code> now takes <code>reference</code> object, which aggregates <code>quantity_spec</code> and a <code>unit</code> and a <code>representation</code> type</li> <li>units, prefixes, dimensions, quantity specifications, and references are passed as NTTPs to templates and provide arithmetic operations and comparison</li> <li>expression templates consistently used in all derived types to increase the readability (#351, #166)</li> <li>derived dimensions are now factors of only base dimensions (#281)</li> <li>convertibility of derived quantities (#427)</li> <li>dimensions, quantity specifications, units, and references are now composable, significantly reducing the number of definitions and resulting types</li> <li>heavily simplified unit systems definitions (no need to define unnamed derived units, systems-specific dimensions, aliases for quantities, concepts, UDLs, ... anymore)</li> <li>improved definition of all systems</li> <li>support for ISO 80000 Part 3-6 quantities</li> <li>faster than lightspeed constants (#169)</li> <li>extensions to quantity formatting with <code>fmt</code></li> <li><code>quantity_kind</code> removed</li> <li>improved casting of unit with <code>.in(Unit)</code>, <code>.force_in(Unit)</code> for <code>quantity</code> and <code>quantity_spec</code></li> <li>numerical value accessor safety improved with <code>.numerical_value_in(Unit)</code> and <code>.force_numerical_value_in(Unit)</code></li> <li><code>quantity</code> can no longer be constructed with a raw value (#434)</li> <li>Implicit construction of quantities from a value (#410)</li> <li><code>quantity_point</code> can no longer be constructed with just a <code>quantity</code> and an explicit <code>PointOrigin</code> is always needed</li> <li><code>ceil</code> and <code>floor</code> are dangerous (#432)</li> <li>quecto, ronto, ronna, quetta new SI prefixes support</li> <li>comparison against zero added (#487)</li> <li>documentation rewritten from scratch</li> <li>many smaller changes not possible to address with the previous design (#205, #210, #134)</li> </ul>"},{"location":"release_notes/#0.8.0","title":"0.8.0 June 14, 2023","text":"<ul> <li>(!) refactor: <code>common_quantity</code>, <code>common_quantity_for</code>, <code>common_quantity_point</code>, <code>common_quantity_kind</code>, and <code>common_quantity_point_kind</code> removed</li> <li>(!) refactor: <code>named_derived_unit</code> removed as it was not used</li> <li>(!) refactor: <code>derived_unit</code> renamed to <code>derived_scaled_unit</code></li> <li>(!) refactor: <code>unit</code> renamed to <code>derived_unit</code></li> <li>(!) refactor: <code>U::is_named</code> removed from the unit types and replaced with <code>NamedUnit</code> concept</li> <li>(!) refactor: <code>PrefixFamily</code> support removed</li> <li>(!) refactor: <code>mi(naut)</code> renamed to <code>nmi</code></li> <li>(!) refactor: <code>knot</code> unit helper renamed to <code>kn</code> in FPS</li> <li>(!) refactor: <code>knot</code> text symbol changed from <code>\"knot\"</code> to <code>\"kn\"</code></li> <li>refactor: <code>quantity</code> <code>op+()</code> and <code>op-()</code> reimplemented in terms of <code>reference</code> rather then <code>quantity</code> types</li> <li>refactor(example): <code>glide_computer</code> now use dimensionless quantities with <code>ranged_representation</code> as <code>rep</code></li> <li>feat: HEP system support added (thanks @RalphSteinhagen)</li> <li>feat: <code>floor()</code>, <code>ceil()</code>, and <code>round()</code> support added (thanks @hofbi)</li> <li>feat: <code>std::format</code> support for compliant compilers added</li> <li>feat: conversion helpers from <code>mp-units</code> to <code>std::chrono</code> types added</li> <li>feat: math functions can now be safely used with user-defined types</li> <li>feat: conversion from <code>quantity_point</code> to <code>std::chrono::time_point</code> added</li> <li>feat: <code>nautical_mile_per_hour</code> and <code>knot</code> added to <code>si::international</code> system</li> <li>(!) fix: add <code>quantity_point::origin</code>, like <code>std::chrono::time_point::clock</code></li> <li>fix: enable any prefixes for most of the named units (beside those that use prefixes already)</li> <li>fix: <code>hectare</code> definition fixed to be a prefixed version of <code>are</code> + other units</li> <li>fix: account for different dimensions in <code>quantity_point_cast</code>'s constraint</li> <li>fix: output stream operator now properly handles state</li> <li>fix: <code>fmt</code> algorithms were overconstrained with <code>forward_iterator</code></li> <li>fix: CTAD for aliases fixed</li> <li>fix: <code>derived_ratio</code> calculation</li> <li>fix: <code>fill_t</code> assignment operator fixed</li> <li>fix: improve downcast mode off</li> <li>fix: <code>radioactivity</code> header compilation fixed</li> <li>fix: <code>si::hep::dim_momentum</code> duplicated definition fixed</li> <li>fix: <code>fps</code> can now coexist with <code>international</code> system</li> <li>fix: public headers fixed to be standalone</li> <li>test: standalone public headers tests added</li> <li>(!) build: CMake generator in Conan is no longer obtained from an environment variable</li> <li>(!) build: Required Conan version bumped to 1.48</li> <li>(!) build: Conan 1.48 does not set <code>CMAKE_BUILD_TYPE</code> in the <code>conan_toolchain.cmake</code> anymore</li> <li>build: AppleClang 13 support added (thanks @fdischner)</li> <li>build: most of the <code>conanfile.py</code> refactored to be Conan 2.0 ready</li> <li>build: <code>validate()</code> replaced with <code>configure()</code> to raise errors during <code>conan install</code> in Conan 1.X</li> <li>build: minimum Conan version changed to 1.40</li> <li>build: <code>linear-algebra</code> Conan repo is no needed anymore</li> <li>build: Gitpod support added</li> <li>build: clang-format-15 support added</li> <li>build: export config to local build (#322)</li> <li>build: fix export name of <code>mp-units-system</code></li> <li>build: fmt updated to 8.0.1</li> <li>build: gsl-lite updated to 0.40.0</li> <li>build: catch2 updated to 2.13.9</li> <li>build: doxygen updated to 1.9.4</li> <li>build: linear_algebra/0.7.0 switched to wg21-linear_algebra/0.7.2</li> <li>ci: VS2022, gcc-11, clang-13, clang-14, and AppleClang 13 support added</li> <li>ci: pre-commit support added (thanks @hofbi)</li> <li>docs: Project documentation updated</li> <li>docs: <code>CITATION.cff</code> file added</li> <li>docs: <code>CONTRIBUTING.md</code> updated</li> </ul>"},{"location":"release_notes/#0.7.0","title":"0.7.0 May 11, 2021","text":"<ul> <li>(!) refactor: <code>ScalableNumber</code> renamed to <code>Representation</code></li> <li>(!) refactor: output stream operators moved to the <code>units/quantity_io.h</code> header file</li> <li>(!) refactor: Refactored the library file tree</li> <li>(!) refactor: <code>quantity::count()</code> renamed to <code>quantity::number()</code></li> <li>(!) refactor: <code>data</code> system renamed to <code>isq::iec80000</code> (quantity names renamed too)</li> <li>(!) refactor: <code>*deduced_unit</code> renamed to <code>*derived_unit</code></li> <li>(!) refactor: got rid of a <code>noble_derived_unit</code></li> <li>refactor: quantity (kind) point updated to reflect latest changes to <code>quantity</code></li> <li>refactor: basic concepts, <code>quantity</code> and <code>quantity_cast</code> refactored</li> <li>refactor: <code>abs()</code> definition refactored to be more explicit about the return type</li> <li>feat: quantity (point) kind support added (thanks @johelegp)</li> <li>feat: quantity references support added (thanks @johelegp)</li> <li>feat: quantity aliases support addded</li> <li>feat: interoperability with <code>std::chrono::duration</code> and other units libraries</li> <li>feat: CTAD for dimensionless quantity added</li> <li>feat: <code>modulation_rate</code> support added (thanks @go2sh)</li> <li>feat: SI prefixes for <code>isq::iec80000</code> support added (thanks @go2sh)</li> <li>feat: a possibility to disable quantity UDLs support with <code>UNITS_NO_LITERALS</code> preprocessor define</li> <li>feat: a support to define ISQ derived dimensions in terms of different number or order of components</li> <li>perf: preconditions check do not influence the runtime performance of a Release build</li> <li>perf: <code>quantity_cast()</code> generates less assembly instructions</li> <li>perf: temporary string creation removed from <code>quantity::op&lt;&lt;()</code></li> <li>perf: value initialization for quantity value removed (left with a default initialization)</li> <li>perf: limited the <code>equivalent</code> trait usage</li> <li>perf: limited the C++ Standard Library headers usage</li> <li>perf: rvalue references support added for constructors and getters</li> <li>(!) fix: <code>exp()</code> has sense only for dimensionless quantities</li> <li>(!) fix: <code>dim_torque</code> now properly divides by an angle (instead of multiply) + default unit name change</li> <li>fix: quantity's operators fixed to behave like the underlying types do</li> <li>fix: <code>quantity_cast()</code> fixed to work correctly with representation types not convertible from <code>std::intmax_t</code></li> <li>fix: ambiguous case for empty type list resolved</li> <li>fix: downcasting facility for non-default-constructible types</li> <li>fix: restore user-warnings within the library implementation</li> <li>fix: the text symbol of <code>foot_pound_force</code> and <code>foot_pound_force_per_second</code></li> <li>fix: quantity modulo arithmetics fixed</li> <li>(!) build: Conan testing version is now hosted on Artifactory</li> <li>(!) build: Linear Algebra is now hosted on its Artifactory</li> <li>(!) build: <code>BUILD_DOCS</code> CMake option renamed to <code>UNITS_BUILD_DOCS</code></li> <li>build: doxygen updated to 1.8.20</li> <li>build: catch2 updated to 2.13.4</li> <li>build: fmt updated to 7.1.3</li> <li>build: ms-gsl replaced with gsl-lite/0.38.0</li> <li>build: Conan generator switched to <code>cmake_find_package_multi</code></li> <li>build: Conan CMakeToolchain support added</li> <li>build: CMake scripts cleanup</li> <li>build: ccache support added</li> <li>ci: CI switched from Travis CI to GitHub Actions</li> </ul>"},{"location":"release_notes/#0.6.0","title":"0.6.0 September 13, 2020","text":"<ul> <li>feat: <code>quantity_point</code> support added (thanks @johelegp)</li> <li>feat: Added angle as SI base dimension (thanks @kwikius)</li> <li>feat: <code>si::angular_velocity</code> support added (thanks @mikeford3)</li> <li>feat: FPS system added (thanks @mikeford3)</li> <li>feat: Added support for mathematical function <code>exp(quantity)</code></li> <li>feat: Localization support for text output added (thanks @rbrugo)</li> <li>feat: Added STL random number distribution wrappers (thanks @yasamoka)</li> <li>(!) refactor: Refactored and cleaned up the library file tree</li> <li>(!) refactor: <code>q_*</code> UDL renamed to <code>_q_*</code></li> <li>(!) refactor: UDLs with \"per\" in name renamed from <code>*p*</code> to <code>*_per_*</code></li> <li>(!) refactor: <code>ratio</code> changed to the NTTP kind</li> <li>(!) refactor: <code>exp</code> and <code>Exp</code> renamed to <code>exponent</code> and <code>Exponent</code></li> <li>(!) refactor: <code>Scalar</code> concept renamed to <code>ScalableNumber</code></li> <li>(!) refactor: Dimensionless quantities redesigned to be of a <code>quantity</code> type</li> <li>refactor: <code>math.h</code> function signatures refactored to use a <code>Quantity</code> concept (thanks @kwikius)</li> <li>refactor: <code>[[nodiscard]]</code> added to many functions</li> <li>fix: <code>si::day</code> unit symbol fixed to <code>d</code> (thanks @komputerwiz)</li> <li>fix: <code>si::mole</code> unit symbol fixed to <code>mol</code> (thanks @mikeford3)</li> <li>(!) build: gcc-9 is no longer supported (at least gcc-10 is required)</li> <li>build: Visual Studio 16.7 support added</li> <li>build: linear_algebra updated to 0.7.0/stable</li> <li>build: fmt updated to 7.0.3</li> <li>build: range-v3 updated to 0.11.0</li> <li>build: catch2 updated to 2.13.0</li> <li>build: doxygen updated to 1.8.18</li> <li>build: ms-gsl 3.1.0 dependency added</li> <li>build: Removed the dependency on a git submodule with common CMake scripts</li> </ul>"},{"location":"release_notes/#0.5.0","title":"0.5.0 May 17, 2020","text":"<ul> <li>Major refactoring and rewrite of the library</li> <li>Units are now independent from dimensions</li> <li>Dimensions now depend on units (base or coherent units are provided in a class template)</li> <li>Quantity gets a Dimension template parameter again (as unit does not provide information about   its dimension anymore)</li> <li>Spaceship operator support added</li> <li>Added official CGS system support</li> <li>Added official data information system support</li> <li>Repository file tree cleanup</li> <li><code>ratio</code> refactored to contain <code>Exp</code> template parameter (thanks a lot @oschonrock!)</li> <li>SI fundamental constants added</li> <li><code>q_</code> prefix applied to all the UDLs (thanks @kwikius)</li> <li><code>unknown_unit</code> renamed to <code>unknown_coherent_unit</code></li> <li>Project documentation greatly extended and switched to Sphinx</li> <li>A few more usage examples added</li> <li>ASCII-only output support added (thanks @yasamoka)</li> <li>Representation values formatting extended (thanks @rbrugo)</li> <li>Output streams formatting support added</li> <li>Linear algebra from <code>std::experimental::math</code> support added</li> <li>Named SI units and their dimensions added (thanks @rbrugo</li> <li>libfmt updated to 6.2.0</li> <li>Added absolute functions and epsilon to math.h (thanks @mikeford3)</li> <li>Added a lot of prefixes to named units and introduced <code>alias_unit</code> (thanks @yasamoka)</li> <li>Linking with Conan targets only when they exists (#98)</li> <li>All physical dimensions and units put into <code>physical</code> namespace</li> <li>CMake improvements</li> <li>Velocity renamed to speed</li> </ul> <p>Many thanks to GitHub users @oschonrock, @kwikius, and @i-ky for their support in drafting a new library design.</p>"},{"location":"release_notes/#0.4.0","title":"0.4.0 Nov 17, 2019","text":"<ul> <li>Support for derived dimensions in <code>exp</code> added</li> <li>Added <code>pow()</code> and <code>sqrt()</code> operations on quantities</li> <li><code>units</code> removed from a <code>std::experimental</code> namespace</li> <li>Downcasting facility refactored so the user does not have to write the boilerplate code anymore</li> <li>From now on base dimensions should inherit from <code>base_dimension</code> class template</li> <li>Added unit symbols definitions to <code>base_dimension</code> and derived units</li> <li>Added support for <code>operator&lt;&lt;</code> on <code>quantity</code></li> <li><code>fmt</code> support added</li> <li>Derived unit factory helpers refactored</li> <li>Refactored the way prefixed units are defined</li> </ul>"},{"location":"release_notes/#0.3.1","title":"0.3.1 Sep 18, 2019","text":"<ul> <li>cmcstl2 dependency changed to range-v3 0.9.1</li> </ul>"},{"location":"release_notes/#0.3.0","title":"0.3.0 Sep 16, 2019","text":"<ul> <li>The design as described on CppCon 2019 talk (https://youtu.be/0YW6yxkdhlU)</li> <li>Applied the feedback from the Cologne evening session</li> <li><code>upcasting_traits</code> renamed to <code>downcasting_traits</code></li> <li><code>Dimension</code> template parameter removed from quantity</li> <li><code>units</code> moved to a <code>std::experimental</code> namespace</li> <li>Leading underscore prefix removed from UDLs</li> <li>Added a few more derived dimensions</li> <li><code>meter</code> renamed to <code>metre</code></li> <li>Missing <code>operator*</code> added</li> <li>Predefined dimensions moved to a dedicated directory</li> <li><code>dimension_</code> prefix removed from names of derived dimensions</li> <li>cmcstl2 library updated to 2019.09.19</li> <li><code>base_dimension</code> is a value provided as <code>const&amp;</code> to the <code>exp</code> type</li> <li>integrated with Compiler Explorer</li> <li>gsl-lite dependency removed</li> <li>Fractional dimension exponents support added</li> <li><code>QuantityOf</code> concept introduced</li> <li><code>quantity_cast&lt;U, Rep&gt;()</code> support added</li> </ul>"},{"location":"release_notes/#0.2.0","title":"0.2.0 July 18, 2019","text":"<ul> <li>The design as described on C++Now 2019 talk (https://youtu.be/wKchCktZPHU)</li> <li>Added C++20 features supported by gcc-9.1 (<code>std::remove_cvref_t</code>, down with typename, <code>std::type_identity</code>)</li> <li>Compile-time performance optimizations (<code>type_list</code>, <code>common_ratio</code>, <code>ratio</code>, <code>conditional_t</code>)</li> </ul>"},{"location":"release_notes/#0.1.0","title":"0.1.0 May 18, 2019","text":"<ul> <li>Initial library release</li> <li>Begin semantic versioning</li> <li>The last version to work with gcc-8</li> </ul>"},{"location":"appendix/glossary/","title":"Glossary","text":""},{"location":"appendix/glossary/#iso-definitions","title":"ISO definitions","text":"<p>Note</p> <p>The ISO terms provided below are only a few of many defined in the ISO/IEC Guide 99.</p> <code>quantity</code> <ul> <li>Property of a phenomenon, body, or substance, where the property has a magnitude that can   be expressed by means of a number and a reference.</li> <li>A reference can be a measurement unit, a measurement procedure, a reference material,   or a combination of such.</li> <li>A quantity as defined here is a scalar. However, a vector or a tensor, the components of   which are quantities, is also considered to be a quantity.</li> <li>The concept \u2019quantity\u2019 may be generically divided into, e.g. \u2018physical quantity\u2019,   \u2018chemical quantity\u2019, and \u2018biological quantity\u2019, or \u2018base quantity\u2019   and \u2018derived quantity\u2019.</li> <li>Examples of quantities are: length, radius, wavelength, energy, electric charge, etc.</li> </ul> <code>kind of quantity, kind</code> <ul> <li>Aspect common to mutually comparable quantities.</li> <li>The division of the concept \u2018quantity\u2019 into several kinds is to some extent arbitrary, for example:<ul> <li>the quantities diameter, circumference, and wavelength are generally considered   to be quantities of the same kind, namely, of the kind of quantity called length,</li> <li>the quantities heat, kinetic energy, and potential energy are generally considered   to be quantities of the same kind, namely of the kind of quantity called energy.</li> </ul> </li> <li>Quantities of the same kind within a given system of quantities   have the same quantity dimension. However, quantities   of the same dimension are not necessarily of the same kind.<ul> <li>For example, the quantities moment of force and energy are, by convention, not regarded   as being of the same kind, although they have the same dimension. Similarly for   heat capacity and entropy, as well as for number of entities, relative permeability,   and mass fraction.</li> </ul> </li> </ul> <code>system of quantities</code> <ul> <li>Set of quantities together with a set of non-contradictory equations   relating those quantities.</li> <li>Examples of systems of quantities are: the International System of Quantities,   the Imperial System, etc.</li> </ul> <code>base quantity</code> <ul> <li>Quantity in a conventionally chosen subset of a given   system of quantities, where no quantity in the   subset can be expressed in terms of the others.</li> <li>Base quantities are referred to as being mutually independent since a base quantity   cannot be expressed as a product of powers of the other base quantities.</li> <li>\u2018Number of entities\u2019 can be regarded as a base quantity in any   system of quantities.</li> </ul> <code>derived quantity</code> <ul> <li>Quantity, in a system of quantities, defined in   terms of the base quantities of that system.</li> </ul> <code>International System of Quantities, ISQ</code> <ul> <li>System of quantities based on the seven base quantities:   length, mass, time, electric current, thermodynamic temperature, amount of substance,   and luminous intensity.</li> <li>This system of quantities is published in the ISO 80000 and IEC 80000 series Quantities and units.</li> <li>The International System of Units (SI) is based on the ISQ.</li> </ul> <code>quantity dimension, dimension of a quantity, dimension</code> <ul> <li>Expression of the dependence of a quantity on the base quantities   of a system of quantities as a product of powers of factors corresponding   to the base quantities, omitting any numerical factor.<ul> <li>e.g. in the ISQ, the quantity dimension of force is denoted by \\(\\textsf{dim }F = \\mathsf{LMT}^{\u20132}\\).</li> </ul> </li> <li>A power of a factor is the factor raised to an exponent. Each factor is the dimension   of a base quantity.</li> <li>In deriving the dimension of a quantity, no account is taken of its scalar, vector, or   tensor character.</li> <li>In a given system of quantities:<ul> <li>quantities of the same kind have the same quantity dimension,</li> <li>quantities of different quantity dimensions are always of different kinds,</li> <li>quantities having the same quantity dimension are not necessarily of the same   kind.</li> </ul> </li> <li> <p>Symbols representing the dimensions of the base quantities in the ISQ are:</p> Base quantity Symbol for dimension length \\(\\mathsf{L}\\) mass \\(\\mathsf{M}\\) time \\(\\mathsf{T}\\) electric current \\(\\mathsf{I}\\) thermodynamic temperature \\(\\mathsf{\u0398}\\) amount of substance \\(\\mathsf{N}\\) luminous intensity \\(\\mathsf{J}\\) <p>Thus, the dimension of a quantity \\(Q\\) is denoted by \\(\\textsf{dim }Q = \\mathsf{L}^\u03b1\\mathsf{M}^\u03b2\\mathsf{T}^\u03b3\\mathsf{I}^\u03b4\\mathsf{\u0398}^\u03b5\\mathsf{N}^\u03b6\\mathsf{J}^\u03b7\\) where the exponents, named dimensional exponents, are positive, negative, or zero.</p> </li> </ul> <code>quantity of dimension one, dimensionless quantity</code> <ul> <li>quantity for which all the exponents of the factors corresponding to the     base quantities in its quantity dimension are zero.</li> <li>The term \u201cdimensionless quantity\u201d is commonly used and is kept here for historical     reasons. It stems from the fact that all exponents are zero in the symbolic     representation of the dimension for such quantities.     The term \u201cquantity of dimension one\u201d reflects the convention in which the symbolic     representation of the dimension for such quantities is     the symbol \\(1\\).</li> <li>The measurement units and values of quantities of     dimension one are numbers, but such quantities convey more information than a number.</li> <li>Some quantities of dimension one are defined as the ratios of two     quantities of the same kind.</li> <li>Numbers of entities are quantities of dimension one.</li> </ul> <code>measurement unit, unit of measurement, unit</code> <ul> <li>Real scalar quantity, defined and adopted by convention, with which any other   quantity of the same kind can be compared to express the ratio of the two   quantities as a number.</li> <li>Measurement units are designated by conventionally assigned names and symbols.</li> <li>Measurement units of quantities of the same quantity dimension   may be designated by the same name and symbol even when the quantities are   not of the same kind.<ul> <li>For example, joule per kelvin and J/K are respectively the name and symbol of both a   measurement unit of heat capacity and a measurement unit of entropy, which are generally   not considered to be quantities of the same kind.</li> </ul> </li> <li>However, in some cases special measurement unit names are restricted to be used with   quantities of specific kind only.<ul> <li>For example, the measurement unit \u2018second to the power minus one\u2019   (\\(\\mathsf{1/s}\\)) is called hertz (\\(\\mathsf{Hz}\\)) when used for frequencies and   becquerel (\\(\\mathsf{Bq}\\)) when used for activities of radionuclides. As another example,   the joule (\\(\\mathsf{J}\\)) is used as a unit of energy, but never as a unit of moment of   force, e.g. the newton metre (\\(\\mathsf{N\u00b7m}\\)).</li> </ul> </li> <li>Measurement units of quantities of dimension one are   numbers. In some cases, these measurement units are given special names, e.g. radian,   steradian, and decibel, or are expressed by quotients such as millimole per mole equal   to \\(10^{\u22123}\\) and microgram per kilogram equal to \\(10^{\u22129}\\).</li> </ul> <code>base unit</code> <ul> <li>Measurement unit that is adopted by convention for a base quantity.</li> <li>In each coherent system of units, there is only one base unit   for each base quantity.<ul> <li>e.g. in the SI, the metre is the base unit of length. In the CGS systems,   the centimetre is the base unit of length.</li> </ul> </li> <li>A base unit may also serve for a derived quantity of the same   quantity dimension.</li> <li>For number of entities, the number one, symbol \\(1\\), can be regarded as a base unit in   any system of units.</li> </ul> <code>derived unit</code> <ul> <li>Measurement unit for a derived quantity.</li> <li>For example, the metre per second, symbol m/s, and the centimetre per second, symbol cm/s,   are derived units of speed in the SI. The kilometre per hour, symbol km/h, is a   measurement unit of speed outside the SI but accepted for use with   the SI. The knot, equal to one nautical mile per hour, is a measurement unit of speed   outside the SI.</li> </ul> <code>coherent derived unit</code> <ul> <li>Derived unit that, for a given system of quantities   and for a chosen set of base units, is a product of powers of   base units with no other proportionality factor than one.</li> <li>A power of a base unit is the base unit raised to an exponent.</li> <li>Coherence can be determined only with respect to a particular   system of quantities and a given set of base units.<ul> <li>For example, if the metre, the second, and the mole are base units, the metre per second is   the coherent derived unit of velocity when velocity is defined by the   quantity equation \\(v = \\mathsf{d}r/\\mathsf{d}t\\), and the mole per   cubic metre is the coherent derived unit of amount-of-substance concentration when   amount-of-substance concentration is defined by the quantity equation \\(c = n/V\\). The kilometre per hour and the knot, given as examples of derived units,   are not coherent derived units in such a system of quantities.</li> </ul> </li> <li>A derived unit can be coherent with respect to one   system of quantities but not to another.<ul> <li>For example, the centimetre per second is the coherent derived unit of speed in a CGS system   of units but is not a coherent derived unit in the SI.</li> </ul> </li> <li>The coherent derived unit for every derived quantity of dimension one   in a given system of units is the number one, symbol \\(1\\). The name and   symbol of the measurement unit one are generally not indicated.</li> </ul> <code>system of units</code> <ul> <li>Set of base units and derived units, together with   their multiples and submultiples, defined in accordance with given rules, for a given   system of quantities.</li> </ul> <code>coherent system of units</code> <ul> <li>System of units, based on a given system of quantities,   in which the measurement unit for each derived quantity is   a coherent derived unit.</li> <li>A system of units can be coherent only with respect to a   system of quantities and the adopted base units.</li> <li>For a coherent system of units, numerical value equations have   the same form, including numerical factors, as the corresponding   quantity equations.</li> </ul> <code>off-system measurement unit, off-system unit</code> <ul> <li>Measurement unit that does not belong to a given system of units.</li> <li>For example, the electronvolt (about \\(1.602\\;18 \u00d7 10^{\u201319}\\;\\mathsf{J}\\)) is an   off-system measurement unit of energy with respect to the SI. Day, hour, minute   are off-system measurement units of time with respect to the SI.</li> </ul> <code>International System of Units, SI</code> <ul> <li>System of units, based on the International System of Quantities,   their names and symbols, including a series of prefixes and their names and symbols,   together with rules for their use, adopted by the General Conference on Weights and   Measures (CGPM).</li> </ul> <code>quantity value, value of a quantity, value</code> <ul> <li>Number and reference together expressing magnitude of a quantity.<ul> <li>For example, length of a given rod: \\(5.34\\;\\mathsf{m}\\) or \\(534\\;\\mathsf{cm}\\).</li> </ul> </li> <li>The number can be complex.</li> <li>A quantity value can be presented in more than one way.</li> <li>In the case of vector or tensor quantities, each component has a quantity value.<ul> <li>For example, force acting on a given particle, e.g. in Cartesian components   \\((F_x; F_y; F_z) = (\u221231.5; 43.2; 17.0)\\;\\mathsf{N}\\).</li> </ul> </li> </ul> <code>numerical quantity value, numerical value of a quantity, numerical value</code> <ul> <li>Number in the expression of a quantity value, other than any number serving   as the reference<ul> <li>For example, in an amount-of-substance fraction equal to \\(3\\;\\mathsf{mmol/mol}\\), the numerical   quantity value is \\(3\\) and the unit is \\(\\mathsf{mmol/mol}\\). The unit \\(\\mathsf{mmol/mol}\\) is numerically equal to \\(0.001\\), but this number \\(0.001\\) is not part   of the numerical quantity value, which remains \\(3\\).</li> </ul> </li> </ul> <code>quantity equation</code> <ul> <li>Mathematical relation between quantities in a given system of quantities,   independent of measure\u00adment units.</li> <li>For example, \\(T = (1/2) mv^2\\) where \\(T\\) is the kinetic energy and \\(v\\) the speed   of a specified particle of mass \\(m\\).</li> </ul> <code>unit equation</code> <ul> <li>Mathematical relation between base units,   coher\u00adent derived units or other measurement units.</li> <li>For example, \\(\\mathsf{J} := \\mathsf{kg}\\:\\mathsf{m}^2/\\mathsf{s}^2\\), where, \\(\\mathsf{J}\\),   \\(\\mathsf{kg}\\), \\(\\mathsf{m}\\), and \\(\\mathsf{s}\\) are the symbols for the joule, kilogram,   metre, and second, respectively. (The symbol \\(:=\\) denotes \u201cis by definition equal to\u201d   as given in the ISO 80000 and IEC 80000 series.). \\(1\\;\\mathsf{km/h} = (1/3.6)\\;\\mathsf{m/s}\\).</li> </ul> <code>numerical value equation, numerical quantity value equation</code> <ul> <li>Mathematical relation between numerical quantity values, based on   a given quantity equation and specified measurement units.</li> <li>For example, in the quantity equation for kinetic energy of a particle,   \\(T = (1/2) mv^2\\), if \\(m = 2\\;\\mathsf{kg}\\) and \\(v = 3\\;\\mathsf{m/s}\\),   then \\({T} = (1/2)\\:\u00d7\\:2\\:\u00d7\\:3^2\\) is a numerical value equation giving the numerical value   \\(9\\) of \\(T\\) in joules.</li> </ul>"},{"location":"appendix/glossary/#other-definitions","title":"Other definitions","text":"<p>Info</p> <p>The below terms extend the official ISO glossary and are commonly referred to by the mp-units library.</p> <code>base dimension</code> <ul> <li>A dimension of a base quantity.</li> </ul> <code>derived dimension</code> <ul> <li>A dimension of a derived quantity.</li> <li>Implemented as a symbolic expression being the result of the   dimension equation on base dimensions.</li> </ul> <code>dimension equation</code> <ul> <li>Mathematical relation between dimensions in a given   system of quantities, independent of measure\u00adment units.</li> </ul> <code>quantity kind hierarchy, quantity hierarchy</code> <ul> <li>Quantities of the same kind form a hierarchy that determines their:<ul> <li>convertibility (e.g. every width is a length, but width should not be   convertible to height)</li> <li>common quantity type (e.g. width + height -&gt; length)</li> </ul> </li> </ul> <code>quantity character, character of a quantity, character</code> <ul> <li>Scalars, vectors and tensors are mathematical objects that can be used to denote   certain physical quantities and their values.   They are as such independent of the particular choice of a coordinate system,   whereas each scalar component of a vector or a tensor and each component vector   and component tensor depend on that choice.</li> <li>A vector is a tensor of the first order and a scalar is a tensor of order zero.</li> <li>For vectors and tensors, the components are quantities that can be   expressed as a product of a number and a unit.</li> <li>Vectors and tensors can also be expressed as a numerical value vector or tensor,   respectively, multiplied by a unit.</li> <li>Quantities of different characters support different set of operations.<ul> <li>For example, a quantity can be multiplied by another one only if any   of them has scalar character. Vectors and tensors can't be multiplied or divided,   but they support additional operations like dot and cross products, which   are not available for scalars.</li> </ul> </li> <li>The term \u2019character\u2019 was borrowed from the below quote:</li> </ul> <p>ISO 80000-1_2009</p> <p>In deriving the dimension of a quantity, no account is taken of its scalar, vector, or tensor character.</p> <code>quantity specification, quantity_spec</code> <ul> <li>An entity storing all the information about a specific quantity:<ul> <li>location in a quantity hierarchy</li> <li>quantity equation</li> <li>dimension of a quantity</li> <li>quantity kind</li> <li>quantity character</li> <li>additional constraints (e.g. non-negative)</li> </ul> </li> <li>Dimension of a quantity is not enough to specify all the properties of   a quantity.</li> </ul> <code>unit with an associated quantity, associated unit</code> <ul> <li>Unit that is used to measure quantities of a specific kind in a given   system of units.</li> </ul> <code>quantity reference, reference</code> <ul> <li>According to its definition, quantity can be expressed by means of   a number and a reference</li> <li>In the mp-units library, a reference describes all the required meta-information   associated with a specific quantity (quantity specification and   unit).</li> </ul> <code>canonical representation of a unit, canonical unit</code> <ul> <li>A canonical representation of a unit consists of:<ul> <li>a reference unit being the result of extraction of all the intermediate   derived units,</li> <li>a magnitude being a product of all the prefixes and magnitudes of extracted scaled units.</li> </ul> </li> <li>All units having the same canonical unit are deemed equal.</li> <li>All units having the same reference unit are convertible   (their magnitude may differ and is used during conversion).</li> </ul> <code>reference unit</code> <p>See canonical representation of a unit</p> <code>absolute quantity point origin</code>, <code>absolute point origin</code> <ul> <li>An explicit point on an axis of values of a specific quantity type that serves   as an absolute reference point for all quantity points which definitions   are (explicitly or implicitly) based on it.</li> <li>For example, mean sea level is commonly used as an absolute reference point to measure altitudes.</li> </ul> <code>relative quantity point origin</code>, <code>relative point origin</code> <ul> <li>An explicit, known at compile-time, point on an axis of values of a specific quantity   type serving as a reference for other quantities.</li> <li>For example, an ice point is a quantity point with a value of \\(273.15\\;\\mathsf{K}\\) that   is used as the zero point of a degree Celsius scale.</li> </ul> <code>quantity point origin</code>, <code>point origin</code> <ul> <li>Either an absolute point origin or   a relative point origin.</li> </ul> <code>quantity point</code>, <code>absolute quantity</code> <ul> <li>An absolute quantity with respect to an origin.</li> <li>For example, timestamp (as opposed to duration), altitude (as opposed to height),   absolute temperature (as opposed to temperature difference).</li> </ul>"},{"location":"appendix/references/","title":"References","text":"<code>ISO80000</code> <p>ISO 80000-1:2009(E) \"Quantities and units \u2014 Part 1: General\", International Organization for Standardization.</p> <code>Quincey</code> \"Angles in the SI: a detailed proposal for solving the problem, Quincey, Paul (1 October 2021). <code>SIBrochure</code> <p>The International System of Units (SI), International Bureau of Weights and Measures (20 May 2019), ISBN 978-92-822-2272-0.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2023/09/24/whats-new-in-mp-units-20/","title":"What's new in mp-units 2.0?","text":"<p>After a year of hard work, we've just released mp-units 2.0.0. It can be obtained from GitHub and Conan.</p> <p>The list of the most significant changes introduced by the new version can be found in our Release Notes. We will also describe some of them in this post.</p>"},{"location":"blog/2023/09/24/whats-new-in-mp-units-20/#why-20-if-10-was-never-released","title":"Why 2.0 if 1.0 was never released?","text":"<p>Version 2 of the mp-units project is a huge change and a new quality for the users. We did not want to pretend that 2.0 is an evolutionary upgrade of the previous version of the project. It feels like a different product.</p> <p>We could start a new repo named \"mp-units-v2\" similarly to range-v3 but we decided not to go this path. We kept the same repo and made the scope of the changes and potential breakage explicit with a drastic bump in the project version.</p>"},{"location":"blog/2023/09/24/whats-new-in-mp-units-20/#what-has-changed","title":"What has changed?","text":"<p>The answer is \"nearly everything\". The whole library and its documentation were rewritten nearly from scratch.</p> <p>Here are the significant changes that the users can observe:</p> <ul> <li> <p>Repository name</p> <p>If you didn't notice, the repository name was changed from \"mpusz/units\" to \"mpusz/mp-units\".</p> </li> <li> <p>Header files content and layout</p> <p>Previously, all the header files resided in the include/units directory. Now, they can be found in include/mp-units. The project file tree was significantly changed as well. Many files were moved to different subdirectories or renamed.</p> </li> <li> <p>Namespace</p> <p>Previously, all the definitions were provided in the <code>units</code> namespace, and now they are in the <code>mp_units</code> one.</p> </li> <li> <p>Abstractions, interfaces, definitions</p> <p>The interfaces of all of the types were refactored. We got unit symbols and a new way to construct a <code>quantity</code> and <code>quantity_point</code>. The readability of the generated types was improved thanks to the introduction of expression templates. Nearly all of the template arguments are now passed by values thanks to class NTTP extensions in C++20. As a result, unit definitions are much easier and terser. Also, the V2 has a powerful ability to model systems of quantities and provides definitions for many ISQ quantities.</p> </li> <li> <p>Conan 2.0</p> <p>Also, now we support Conan 2.0, which provides an updated way of handling dependencies.</p> </li> </ul>"},{"location":"blog/2023/09/24/whats-new-in-mp-units-20/#what-is-gone","title":"What is gone?","text":"<p>Some cornerstones of the initial design did not prove in practice and were removed while we moved to version 2.</p>"},{"location":"blog/2023/09/24/whats-new-in-mp-units-20/#the-downcasting-facility","title":"The downcasting facility","text":"<p>The first and the most important of such features was removing the downcasting facility. This feature is still a powerful metaprogramming technique that allows users to map long class template instantiations to nicely named, short, and easy-to-understand user's strong types.</p> <p>Such mapping works perfectly fine for 1-to-1 relationships. However, we often deal with N-to-1 connections in the quantities and units domain. Here are only a few such examples:</p> <ul> <li>work and torque have the same dimension \\(L^2MT^{-2}\\),</li> <li>becquerel and hertz have the same definition of \\(s^{-1}\\),</li> <li>litre and cubic decimetre have the same factor.</li> </ul> <p>In the above examples, multiple entities \"wanted\" to register different names for identical class template instantiations, resulting in compile-time errors. We had to invent some hacks and workarounds to make it work, but we were never satisfied with the outcome.</p> <p>Additionally, this facility could easily lead to ODR violations or provide different results depending on which header files were included in the translation units. This was too vulnerable to be considered a good practice here.</p>"},{"location":"blog/2023/09/24/whats-new-in-mp-units-20/#no-udls-anymore","title":"No UDLs anymore","text":"<p>Over the years, we have learned that UDLs are not a good solution. More information on this subject can be found in the Why don't we use UDLs to create quantities? chapter.</p>"},{"location":"blog/2023/09/24/whats-new-in-mp-units-20/#no-construction-of-a-quantity-from-a-raw-value","title":"No construction of a <code>quantity</code> from a raw value","text":"<p>To improve safety, we no longer allow the construction of quantities from raw values. In the new design, we always need to explicitly specify a unit to create a <code>quantity</code>:</p> <pre><code>quantity q1 = 42 * m;\nquantity&lt;si::metre&gt; = 2 * km;\nquantity q3(42, si::metre);\n</code></pre> <p>The previous approach was reported to be error-prone under maintenance. More on this subject can be found in the Why can't I create a quantity by passing a number to a constructor? chapter.</p>"},{"location":"blog/2023/09/24/whats-new-in-mp-units-20/#new-look-and-feel","title":"New look and feel","text":"<p>Here is a concise example showing you the new look and feel of the library:</p> <pre><code>#include &lt;mp-units/format.h&gt;\n#include &lt;mp-units/systems/isq/isq.h&gt;\n#include &lt;mp-units/systems/si/si.h&gt;\n#include &lt;format&gt;\n\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\n\nquantity&lt;isq::speed[m / s]&gt; avg_speed(quantity&lt;si::metre&gt; d,\n                                      quantity&lt;si::second&gt; t)\n{ return d / t; }\n\nint main()\n{\n  auto speed = avg_speed(220 * km, 2 * h);\n  std::println(\"{}\", speed);  // 30.5556 m/s\n}\n</code></pre> <p>All of the changes we provided, although breaking ones, resulted in much better, easier, and safer abstractions. These offer a new quantity on the market and hopefully will be appreciated by our users.</p> <p>Please check our new documentation to learn about the latest version of the project and find out how to benefit from all the new cool stuff we have here.</p>"},{"location":"blog/2023/12/09/mp-units-210-released/","title":"mp-units 2.1.0 released!","text":"<p>A new product version can be obtained from GitHub and Conan.</p> <p>The list of the most significant changes introduced by the new version can be found in our Release Notes. We will also describe the most important of them in this post.</p>"},{"location":"blog/2023/12/09/mp-units-210-released/#no-more-parenthesis-while-creating-quantities-with-derived-units","title":"No more parenthesis while creating quantities with derived units","text":"<p>The V2 design introduced a way to create a <code>quantity</code> by multiplying a raw value and a unit:</p> <pre><code>quantity q1 = 42 * m;\n</code></pre> <p>However, this meant that when we wanted to create a quantity having a derived unit, we had to put parenthesis around the unit equation or create a custom value of the named unit:</p> <pre><code>quantity q2 = 60 * (km / h);\n\nconstexpr auto kmph = km / h;\nquantity q3 = 60 * kmph;\n\nquantity q4 = 50 * (1 / s);\n</code></pre> <p>With the new version, we removed this restriction, and now we can type:</p> <pre><code>quantity q5 = 60 * km / h;\nquantity q6 = 50 / s;\n</code></pre> <p>As a side effect, we introduced a  breaking change . We can't use the following definition of hertz anymore:</p> <pre><code>inline constexpr struct hertz : named_unit&lt;\"Hz\", 1 / second, kind_of&lt;isq::frequency&gt;&gt; {} hertz;\n</code></pre> <p>and have to type either:</p> <pre><code>inline constexpr struct hertz : named_unit&lt;\"Hz\", one / second, kind_of&lt;isq::frequency&gt;&gt; {} hertz;\n</code></pre> <p>or</p> <pre><code>inline constexpr struct hertz : named_unit&lt;\"Hz\", inverse(second), kind_of&lt;isq::frequency&gt;&gt; {} hertz;\n</code></pre> <p>To be consistent, we applied the same change to the dimensions and quantity specifications definitions. Now, to define a frequency we have to type:</p> C++23C++20Portable <pre><code>inline constexpr struct frequency : quantity_spec&lt;inverse(period_duration)&gt; {} frequency;\n</code></pre> <pre><code>inline constexpr struct frequency : quantity_spec&lt;frequency, inverse(period_duration)&gt; {} frequency;\n</code></pre> <pre><code>QUANTITY_SPEC(frequency, inverse(period_duration));\n</code></pre>"},{"location":"blog/2023/12/09/mp-units-210-released/#make_xxx-factory-functions-replaced-with-two-parameter-constructors","title":"<code>make_xxx</code> factory functions replaced with two-parameter constructors","text":"<p>In the initial version of the V2 framework, if someone did not like the multiply syntax to create a <code>quantity</code> we provided the <code>make_quantity()</code> factory function. A similar approach was used for <code>quantity_point</code> creation.</p> <p>This version removes those ( breaking change ) and introduces two parameter constructors:</p> <pre><code>quantity q(42, si::metre);\nquantity_point qp(q, mean_sea_level);\n</code></pre> <p>The above change encourages a better design and results in a terser code.</p>"},{"location":"blog/2023/12/09/mp-units-210-released/#improved-definitions-of-becquerel-gray-and-sievert","title":"Improved definitions of becquerel, gray, and sievert","text":"<p>In the initial V2 version, we lacked the definitions of the atomic and nuclear physics quantities, which resulted in simplified and unsafe definitions of becquerel, gray, and sievert units. We still do not model most of the quantities from this domain, but we've added the ones that are necessary for the definition of those units.</p> <p>Thanks to the above, the following expressions will not compile:</p> <pre><code>quantity q1 = 1 * Hz + 1 * Bq;\nquantity&lt;si::sievert&gt; q2 = 42 * Gy;\n</code></pre>"},{"location":"blog/2023/12/09/mp-units-210-released/#compatibility-with-other-libraries-redesigned","title":"Compatibility with other libraries redesigned","text":"<p>Another significant improvement in this version was redesigning the way we provide compatibility with other similar libraries. The interfaces of <code>quantity_like_traits</code> and <code>quantity_point_like_traits</code> were changed and extended to provide conversion not only from but also to entities from other libraries ( breaking change ).</p> <p>We've also introduced an innovative approach that allows us to specify if such conversions should happen implicitly or if they need to be forced explicitly.</p> <p>More on this subject can be found in the Interoperability with Other Libraries chapter.</p>"},{"location":"blog/2023/12/09/mp-units-210-released/#point-origins-can-now-be-derived-from-each-other","title":"Point origins can now be derived from each other","text":"<p>Previously, each class derived from <code>absolute_point_origin</code> was considered a unique independent point origin. On the other hand, it was OK to derive multiple classes from the same <code>relative_point_origin</code>, and those were specifying the same point in the domain. We found this confusing and limiting. This is why, in this version, the <code>absolute_point_origin</code> uses a CRTP idiom to be able to detect between points that should be considered different from the ones that should be equivalent.</p> <p>If we derive from the same instantiation of <code>absolute_point_origin</code> we end up with an equivalent point origin. This change allows us to provide different names for the same temperature points:</p> <pre><code>inline constexpr struct absolute_zero : absolute_point_origin&lt;absolute_zero, isq::thermodynamic_temperature&gt; {} absolute_zero;\ninline constexpr struct zeroth_kelvin : decltype(absolute_zero) {} zeroth_kelvin;\n\ninline constexpr struct ice_point : relative_point_origin&lt;absolute_zero + 273.15 * kelvin&gt; {} ice_point;\ninline constexpr struct zeroth_degree_Celsius : decltype(ice_point) {} zeroth_degree_Celsius;\n</code></pre> <p>Please note that this is a  breaking change  as well.</p>"},{"location":"blog/2023/12/09/mp-units-210-released/#unit-symbol-text-can-now-be-properly-used-at-runtime","title":"Unit symbol text can now be properly used at runtime","text":"<p>The interface of the previous definition of <code>unit_symbol</code> function allowed the use of the returned buffer only at compile-time. This was too limiting as users often want to use unit symbols at runtime (e.g., print them to the console). The new version redesigned the interface of this function ( breaking change ) to return a buffer that can be properly used at both compilation and runtime:</p> <pre><code>std::string_view unit1 = unit_symbol(m / s);\nstd::cout &lt;&lt; unit1 &lt;&lt; \"\\n\";     // m/s\nstd::string_view unit2 = unit_symbol&lt;{.solidus = unit_symbol_solidus::never}&gt;(m / s);\nstd::cout &lt;&lt; unit2 &lt;&lt; \"\\n\";     // m s\u207b\u00b9\n</code></pre>"},{"location":"blog/2024/06/14/mp-units-220-released/","title":"mp-units 2.2.0 released!","text":"<p>A new product version can be obtained from GitHub and Conan.</p> <p>Among other features, this release provides long-awaited support for C++20 modules, redesigns and enhances text output formatting, and greatly simplifies quantity point usage. This post describes those and a few other smaller interesting improvements, while a much longer list of the most significant changes introduced by the new version can be found in our Release Notes.</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#c20-modules-and-project-structure-cleanup","title":"C++20 modules and project structure cleanup","text":"<p>GitHub Issue #7 was our oldest open issue before this release. Not anymore. After 4.5 years, we finally closed it, even though the C++ modules' support is still really limited.</p> <p>Info</p> <p>To benefit from C++ modules, we need at least:</p> <ul> <li>CMake 3.29.3</li> <li>Ninja 1.11</li> <li>clang-17</li> </ul> <p>In the upcoming months, hopefully, the situation will improve with the bug fixes in CMake, gcc-14, and MSVC.</p> <p>Note</p> <p>More requirements for C++ modules support can be found in the CMake's documentation.</p> <p>To enable the compilation and distribution of C++ modules, a <code>cxx_modules</code> Conan or <code>MP_UNITS_BUILD_CXX_MODULES</code> CMake option has to be enabled.</p> <p>With the above, the following C++ modules will be provided:</p> <pre><code>flowchart TD\n    mp_units --- mp_units.systems --- mp_units.core</code></pre> C++ Module CMake Target Contents <code>mp_units.core</code> <code>mp-units::core</code> Core library framework and systems-independent utilities <code>mp_units.systems</code> <code>mp-units::systems</code> All the systems of quantities and units <code>mp_units</code> <code>mp-units::mp-units</code> Core + Systems <p>The easiest way to use them is just to <code>import mp_units;</code> at the beginning of your translation unit (see the Quick Start chapter for some usage examples).</p> <p>Note</p> <p>C++20 modules support still have some issues when imported from the installed CMake target. See the following GitLab issue for more details.</p> <p>In this release, we also highly limited the number of CMake targets ( breaking change ). Now, they correspond exactly to the C++ modules they provide. This means that many smaller partial targets were removed. We also merged text output targets with the core library's definition.</p> <p>The table below specifies where we can now find the contents of previously available CMake targets:</p> Before Now <code>mp-units::utility</code> <code>mp-units::core</code> <code>mp-units::core-io</code> <code>mp-units::core</code> <code>mp-units::core-fmt</code> <code>mp-units::core</code> <code>mp-units::{system_name}</code> <code>mp-units::systems</code> <p>While we were enabling C++ modules, we also had to refactor our header files slightly ( breaking change ). Some had to be split into smaller pieces (e.g., math.h), while others had to be moved to a different subdirectory (e.g., chrono.h).</p> <p>In version 2.2, the following headers have a new location or contents:</p> Header File C++ Module Contents mp-units/math.h <code>mp_units.core</code> System-independent functions only mp-units/systems/si/math.h <code>mp_units.systems</code> Trigonometric functions using <code>si::radian</code> mp-units/systems/angular/math.h <code>mp_units.systems</code> Trigonometric functions using <code>angular::radian</code> mp-units/systems/si/chrono.h <code>mp_units.systems</code> <code>std::chrono</code> compatibility traits <p>Benefiting from this opportunity, we also cleaned up core and systems definitions ( breaking change ).</p> <p>Regarding the library's core, we removed <code>core.h</code> and exposed only one header <code>framework.h</code> that provides all of the library's framework so the user does not have to enumerate files like <code>unit.h</code>, <code>quantity.h</code>, and <code>quantity_point.h</code> anymore. Those headers are not gone, they were put to the <code>mp-units/framework</code> subheader. So they are still there if you really need them.</p> <p>Regarding the changes in systems definitions, we moved the wrapper header files with the entire system definition to the <code>mp-units/systems</code> subdirectory. Additionally, they now also include <code>framework.h</code>, so a system include is enough to use the library. Thanks to that our users don't have to write tedious code like the below anymore:</p> NowBefore <pre><code>#include &lt;mp-units/systems/cgs.h&gt;\n#include &lt;mp-units/systems/international.h&gt;\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n\n// ...\n</code></pre> <pre><code>#include &lt;mp-units/quantity_point.h&gt;\n#include &lt;mp-units/systems/cgs/cgs.h&gt;\n#include &lt;mp-units/systems/international/international.h&gt;\n#include &lt;mp-units/systems/isq/isq.h&gt;\n#include &lt;mp-units/systems/si/si.h&gt;\n\n// ...\n</code></pre> <p>Additionally, we merged all of the compatibility-related macros into one header file <code>mp-units/compat_macros.h</code>. This header file should be explicitly included before importing C++ modules if we want to benefit from the Wide Compatibility tools.</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#better-control-over-the-librarys-api","title":"Better control over the library's API","text":"<p>With this release, nearly all of the Conan and CMake build options were refactored with the intent of providing better control over the library's API.</p> <p>Previously, the library used the latest available feature set supported by a specific compiler. For example, <code>quantity_spec</code> definitions would use CRTP on an older compiler or provide a simpler API on a newer one thanks to the C++23 <code>this</code> deduction feature. This could lead to surprising results where the same code written by the user would compile fine on one compiler but not the other.</p> <p>From this release, all API extensions have their corresponding configuration options in Conan and CMake. With this, a user has full control over the API exposed by the library. Those options expose three values:</p> <ul> <li><code>True</code> - The feature is always enabled (the configuration error will happen if the compiler does   not support this feature)</li> <li><code>False</code> - The feature is disabled, and an older alternative is always used.</li> <li><code>Auto</code> - The feature is automatically enabled if the compiler supports it (old behavior).</li> </ul> <p>Additionally, some CMake options were renamed to better express the impact on our users ( breaking change ). For example, now CMake options include:</p> <ul> <li><code>MP_UNITS_API_*</code> - options affecting the library's API,</li> <li><code>MP_UNITS_BUILD_*</code> - options affecting the build process,</li> <li><code>MP_UNITS_DEV_*</code> - options primarily useful for the project developers or people who want to   compile our unit tests and examples.</li> </ul>"},{"location":"blog/2024/06/14/mp-units-220-released/#configurable-contracts-checking","title":"Configurable contracts checking","text":"<p>Before this release, the library always depended on gsl-lite to perform runtime contract and asserts checking. In this release we introduced new options to control if contract checking should be based on gsl-lite, ms-gsl, or may be completely disabled.</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#freestanding-support","title":"Freestanding support","text":"<p>From this release it is possible to configure the library in the freestanding mode. This limits the functionality and interface of the library to be compatible with the freestanding implementations.</p> <p>Info</p> <p>To learn more, please refer to the Build options chapter.</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#simplified-quantity-point-support","title":"Simplified quantity point support","text":"<p>This release significantly simplifies the usage of quantity points and affine space abstractions in general.</p> <p>Previously, the user always had to define an explicit point origin even if the domain being modeled does not have such an explicit origin. Now, in such cases, we can benefit from the implicit point origins. For example:</p> NowBefore <pre><code>quantity_point price_usd{100 * USD};\n</code></pre> <pre><code>constexpr struct zero final : absolute_point_origin&lt;currency&gt; {} zero;\n\nquantity_point price_usd = zero + 100 * USD;\n</code></pre> <p>As we can see above, the new design allows direct-initializing <code>quantity_point</code> class template from a <code>quantity</code>, but only if the former one is defined in terms of the implicit point origin. Otherwise, an explicit origin still always has to be provided during initialization.</p> <p>Also, we introduced the possibility of specifying a default point origin in the unit definition. With that, we could provide proper temperature scales without forcing the user to always use the origins explicitly. Also, a new member function, <code>.quantity_from_zero(),</code> was introduced that always returns the quantity from the unit's specific point origin or from the implicit point origin otherwise.</p> NowBefore <pre><code>quantity_point temp{20 * deg_C};\nstd::cout &lt;&lt; \"Temperature: \" &lt;&lt; temp &lt;&lt; \" (\"\n          &lt;&lt; temp.in(deg_F).quantity_from_zero() &lt;&lt; \", \"\n          &lt;&lt; temp.in(K).quantity_from_zero() &lt;&lt; \")\\n\";\n</code></pre> <pre><code>quantity_point temp = si::zeroth_degree_Celsius + 20 * deg_C;\nstd::cout &lt;&lt; \"Temperature: \" &lt;&lt; temp &lt;&lt; \" (\"\n          &lt;&lt; temp.in(deg_F).quantity_from(usc::zeroth_degree_Fahrenheit) &lt;&lt; \", \"\n          &lt;&lt; temp.in(K).quantity_from(si::zeroth_kelvin) &lt;&lt; \")\\n\";\n</code></pre> <p>More information about the new design can be found in The Affine Space chapter.</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#unified-temperature-point-origins-names","title":"Unified temperature point origins names","text":"<p>By omission, we had the following temperature point origins in the library:</p> <ul> <li><code>si::zero_kelvin</code> (for <code>si::kelvin</code>),</li> <li><code>si::zeroth_degree_Celsius</code> (for <code>si::degree_Celsius</code>),</li> <li><code>usc::zero_Fahrenheit</code> (for <code>usc::degree_Fahrenheit</code>).</li> </ul> <p>With this release, the last one was renamed to <code>usc::zeroth_degree_Fahrenheit</code> to be consistently named with its corresponding unit and with the <code>si::zeroth_degree_Celsius</code> ( breaking change ).</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#changes-to-units-definitions","title":"Changes to units definitions","text":"<p>There were several known issues when units were deriving from each other (e.g., #512 and #537). We could either highly complicate the framework to allow these which could result in much longer compilation times or disallow inheriting from units at all. We chose the second option.</p> <p>With this release all of of the units must be marked as <code>final</code>. To enforce this we have changed the definition of the <code>Unit&lt;T&gt;</code> concept, which now requires type <code>T</code> to be <code>final</code> ( breaking change ).</p> <p>WG21 Study Group 16 (Unicode) raised concerns about potential ABI issues when different translation units are compiled with different ordinary literal encodings. Those issues were resolved with a change to units definitions ( breaking change ). It affects only units that specify both Unicode and ASCII symbols. The new design requires the Unicode symbol to be provided as a UTF-8 literal.</p> <p>This also means that the <code>basic_symbol_text</code> has fixed character types for both symbols. This is why it was renamed to <code>symbol_text</code> ( breaking change ).</p> NowBefore <pre><code>inline constexpr struct ohm final : named_unit&lt;symbol_text{u8\"\u03a9\", \"ohm\"}, volt / ampere&gt; {} ohm;\n</code></pre> <pre><code>inline constexpr struct ohm : named_unit&lt;basic_symbol_text{\"\u03a9\", \"ohm\"}, volt / ampere&gt; {} ohm;\n</code></pre> <p>Note</p> <p>On C++20-compliant compilers it should be enough to type the following in the unit's definition:</p> <pre><code>inline constexpr struct ohm final : named_unit&lt;{u8\"\u03a9\", \"ohm\"}, volt / ampere&gt; {} ohm;\n</code></pre>"},{"location":"blog/2024/06/14/mp-units-220-released/#changes-to-dimension-quantity-specification-and-point-origins-definitions","title":"Changes to dimension, quantity specification, and point origins definitions","text":"<p>Similarly to units, now also all dimensions, quantity specifications, and point origins have to be marked <code>final</code> ( breaking change ).</p> NowBefore <pre><code>inline constexpr struct dim_length final : base_dimension&lt;\"L\"&gt; {} dim_length;\ninline constexpr struct length final : quantity_spec&lt;dim_length&gt; {} length;\n\ninline constexpr struct absolute_zero final : absolute_point_origin&lt;isq::thermodynamic_temperature&gt; {} absolute_zero;\ninline constexpr auto zeroth_kelvin  = absolute_zero;\ninline constexpr struct kelvin final : named_unit&lt;\"K\", kind_of&lt;isq::thermodynamic_temperature&gt;, zeroth_kelvin&gt; {} kelvin;\n\ninline constexpr struct ice_point final : relative_point_origin&lt;quantity_point{273'150 * milli&lt;kelvin&gt;}&gt; {} ice_point;\ninline constexpr auto zeroth_degree_Celsius = ice_point;\ninline constexpr struct degree_Celsius final : named_unit&lt;symbol_text{u8\"\u2103\", \"`C\"}, kelvin, zeroth_degree_Celsius&gt; {} degree_Celsius;\n</code></pre> <pre><code>inline constexpr struct dim_length : base_dimension&lt;\"L\"&gt; {} dim_length;\ninline constexpr struct length : quantity_spec&lt;dim_length&gt; {} length;\n\ninline constexpr struct absolute_zero : absolute_point_origin&lt;absolute_zero, isq::thermodynamic_temperature&gt; {} absolute_zero;\ninline constexpr struct zeroth_kelvin : decltype(absolute_zero) {} zeroth_kelvin;\ninline constexpr struct kelvin : named_unit&lt;\"K\", kind_of&lt;isq::thermodynamic_temperature&gt;, zeroth_kelvin&gt; {} kelvin;\n\ninline constexpr struct ice_point : relative_point_origin&lt;quantity_point{273'150 * milli&lt;kelvin&gt;}&gt; {} ice_point;\ninline constexpr struct zeroth_degree_Celsius : decltype(ice_point) {} zeroth_degree_Celsius;\ninline constexpr struct degree_Celsius : named_unit&lt;symbol_text{u8\"\u2103\", \"`C\"}, kelvin, zeroth_degree_Celsius&gt; {} degree_Celsius;\n</code></pre> <p>Please also note, that the <code>absolute_point_origin</code> does not use CRTP idiom anymore ( breaking change ).</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#improved-text-output","title":"Improved text output","text":"<p>With this release, we can print not only whole quantities but also just their units or dimensions. Also, we fixed the <code>std::format</code> support so users can now enjoy full C++20 compatibility and don't have to use fmtlib anymore.</p> <p>We have also changed the grammar for quantities formatting ( breaking change ). It introduces the composition of underlying formatters that finally allows us to properly format user-defined representation types (assuming they have <code>std::format</code> support). Additionally, thanks to a new <code>%?</code> token, we can provide a custom format string that will properly print quantity of any unit.</p> <p>Here is a small preview of what is now available:</p> <pre><code>using namespace mp_units::si::unit_symbols;\nusing namespace mp_units::international::unit_symbols;\nquantity q = (90. * km / h).in(mph);\n\nstd::cout &lt;&lt; \"Number: \" &lt;&lt; q.numerical_value_in(mph) &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Unit: \" &lt;&lt; q.unit &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Dimension: \" &lt;&lt; q.dimension &lt;&lt; \"\\n\";\nstd::println(\"{::N[.2f]}\", q);\nstd::println(\"{:.4f} in {} of {}\", q.numerical_value_in(mph), q.unit, q.dimension);\nstd::println(\"{:%N in %U of %D:N[.4f]}\", q);\n</code></pre> <pre><code>Number: 55.9234\nUnit: mi/h\nDimension: LT\u207b\u00b9\n55.92 mi/h\n55.9234 in mi/h of LT\u207b\u00b9\n55.9234 in mi/h of LT\u207b\u00b9\n</code></pre> <p>More on this subject can be found in the updated Text Output chapter.</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#improved-casts","title":"Improved casts","text":"<p>We added a new conversion function. <code>value_cast&lt;Unit, Representation&gt;</code> forces the conversion of both a unit and representation type in one step and always ensures that the best precision is provided.</p> <p>Also, we have finally added proper implementations of <code>value_cast</code> and <code>quantity_cast</code> for quantity points.</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#even-better-error-messages","title":"Even better error messages","text":"<p>This release made a few small refactorings that, without changing the user-facing API, allowed us to improve the readability of the generated types that can be observed in the compilation errors.</p> <p>Example 1 (clang):</p> NowBefore <pre><code>error: no matching function for call to 'time_to_goal'\n   26 |   const quantity ttg = time_to_goal(half_marathon_distance, pace);\n      |                        ^~~~~~~~~~~~\nnote: candidate template ignored: constraints not satisfied [with distance:auto = quantity&lt;kilo_&lt;metre&gt;{}, double&gt;,\n                                                                  speed:auto = quantity&lt;derived_unit&lt;second, per&lt;kilo_&lt;metre&gt;&gt;&gt;{}, double&gt;]\n   13 | QuantityOf&lt;isq::time&gt; auto time_to_goal(QuantityOf&lt;isq::length&gt; auto distance,\n      |                            ^\nnote: because 'QuantityOf&lt;quantity&lt;derived_unit&lt;si::second, per&lt;si::kilo_&lt;si::metre&gt; &gt; &gt;{{{}}}&gt;, isq::speed&gt;' evaluated to false\n   14 |                                         QuantityOf&lt;isq::speed&gt; auto speed)\n      |                                         ^\nnote: because 'QuantitySpecOf&lt;std::remove_const_t&lt;decltype(quantity&lt;derived_unit&lt;second, per&lt;kilo_&lt;metre&gt; &gt; &gt;{{{}}}, double&gt;::quantity_spec)&gt;, struct speed{{{}}}&gt;' evaluated to false\n   61 | concept QuantityOf = Quantity&lt;Q&gt; &amp;&amp; QuantitySpecOf&lt;std::remove_const_t&lt;decltype(Q::quantity_spec)&gt;, QS&gt;;\n      |                                     ^\nnote: because 'implicitly_convertible(kind_of_&lt;derived_quantity_spec&lt;isq::time, per&lt;isq::length&gt; &gt; &gt;{}, struct speed{{{}}})' evaluated to false\n  147 |   QuantitySpec&lt;T&gt; &amp;&amp; QuantitySpec&lt;decltype(QS)&gt; &amp;&amp; implicitly_convertible(T{}, QS) &amp;&amp;\n      |                                                                         ^\n1 error generated.\nCompiler returned: 1\n</code></pre> <pre><code>error: no matching function for call to 'time_to_goal'\n   26 |   const quantity ttg = time_to_goal(half_marathon_distance, pace);\n      |                        ^~~~~~~~~~~~\nnote: candidate template ignored: constraints not satisfied [with distance:auto = quantity&lt;kilo_&lt;metre{{}}&gt;{}, double&gt;,\n                                                                  speed:auto = quantity&lt;derived_unit&lt;second, per&lt;kilo_&lt;metre{{}}&gt;&gt;&gt;{}, double&gt;]\n   13 | QuantityOf&lt;isq::time&gt; auto time_to_goal(QuantityOf&lt;isq::length&gt; auto distance,\n      |                            ^\nnote: because 'QuantityOf&lt;quantity&lt;derived_unit&lt;si::second, per&lt;si::kilo_&lt;si::metre{{}}&gt; &gt; &gt;{{{}}}&gt;, isq::speed&gt;' evaluated to false\n   14 |                                         QuantityOf&lt;isq::speed&gt; auto speed)\n      |                                         ^\nnote: because 'QuantitySpecOf&lt;std::remove_const_t&lt;decltype(quantity&lt;derived_unit&lt;second, per&lt;kilo_&lt;metre{{}}&gt; &gt; &gt;{{{}}}, double&gt;::quantity_spec)&gt;, struct speed{{{}}}&gt;' evaluated to false\n   61 | concept QuantityOf = Quantity&lt;Q&gt; &amp;&amp; QuantitySpecOf&lt;std::remove_const_t&lt;decltype(Q::quantity_spec)&gt;, QS&gt;;\n      |                                     ^\nnote: because 'implicitly_convertible(kind_of_&lt;derived_quantity_spec&lt;isq::time, per&lt;isq::length&gt; &gt;{{}, {{}}}&gt;{}, struct speed{{{}}})' evaluated to false\n  147 |   QuantitySpec&lt;T&gt; &amp;&amp; QuantitySpec&lt;decltype(QS)&gt; &amp;&amp; implicitly_convertible(T{}, QS) &amp;&amp;\n      |                                                                         ^\n1 error generated.\nCompiler returned: 1\n</code></pre> <p>Example 2 (gcc):</p> NowBefore <pre><code>error: no matching function for call to 'Box::Box(quantity&lt;reference&lt;isq::height, si::metre&gt;(), int&gt;, quantity&lt;reference&lt;horizontal_length, si::metre&gt;(), int&gt;,\n                                                  quantity&lt;reference&lt;isq::width, si::metre&gt;(), int&gt;)'\n   27 | Box my_box(isq::height(1 * m), horizontal_length(2 * m), isq::width(3 * m));\n      |                                                                           ^\nnote: candidate: 'Box::Box(quantity&lt;reference&lt;horizontal_length, si::metre&gt;()&gt;, quantity&lt;reference&lt;isq::width, si::metre&gt;()&gt;,\n                                          quantity&lt;reference&lt;isq::height, si::metre&gt;()&gt;)'\n   19 |   Box(quantity&lt;horizontal_length[m]&gt; l, quantity&lt;isq::width[m]&gt; w, quantity&lt;isq::height[m]&gt; h):\n      |   ^~~\nnote:   no known conversion for argument 1 from 'quantity&lt;reference&lt;isq::height, si::metre&gt;(),int&gt;'\n        to 'quantity&lt;reference&lt;horizontal_length, si::metre&gt;(),double&gt;'\n   19 |   Box(quantity&lt;horizontal_length[m]&gt; l, quantity&lt;isq::width[m]&gt; w, quantity&lt;isq::height[m]&gt; h):\n      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n</code></pre> <pre><code>error: no matching function for call to 'Box::Box(quantity&lt;reference&lt;isq::height(), si::metre()&gt;(), int&gt;, quantity&lt;reference&lt;horizontal_length(), si::metre()&gt;(), int&gt;,\n                                                  quantity&lt;reference&lt;isq::width(), si::metre()&gt;(), int&gt;)'\n   27 | Box my_box(isq::height(1 * m), horizontal_length(2 * m), isq::width(3 * m));\n      |                                                                           ^\nnote: candidate: 'Box::Box(quantity&lt;reference&lt;horizontal_length(), si::metre()&gt;()&gt;, quantity&lt;reference&lt;isq::width(), si::metre()&gt;()&gt;,\n                                          quantity&lt;reference&lt;isq::height(), si::metre()&gt;()&gt;)'\n   19 |   Box(quantity&lt;horizontal_length[m]&gt; l, quantity&lt;isq::width[m]&gt; w, quantity&lt;isq::height[m]&gt; h):\n      |   ^~~\nnote:   no known conversion for argument 1 from 'quantity&lt;reference&lt;isq::height(), si::metre()&gt;(),int&gt;'\n        to 'quantity&lt;reference&lt;horizontal_length(), si::metre()&gt;(),double&gt;'\n   19 |   Box(quantity&lt;horizontal_length[m]&gt; l, quantity&lt;isq::width[m]&gt; w, quantity&lt;isq::height[m]&gt; h):\n      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n</code></pre>"},{"location":"blog/2024/06/14/mp-units-220-released/#mathh-header-changes","title":"math.h header changes","text":"<p>This release provided lots of changes to the mp_units/math.h header file.</p> <p>First, we got several outstanding contributions:</p> <ul> <li><code>fma</code>, <code>isfinite</code>, <code>isinf</code>, and <code>isnan</code> math functions were added by @NAThompson,</li> <li><code>ppm</code>, <code>atan2</code>, <code>fmod</code>, and <code>remainder</code> were added by @nebkat.</li> </ul> <p>Thanks!</p> <p>Additionally, we changed the namespace for trigonometric functions using SI units. Now they are inside of the <code>mp_units::si</code> subnamespace and not in <code>mp_units::isq</code> like it was the case before ( breaking change ).</p> <p>Also, the header itself was split into smaller pieces that improve C++20 modules definitions.</p>"},{"location":"blog/2024/06/14/mp-units-220-released/#ratio-made-an-implementation-detail-of-the-library","title":"<code>ratio</code> made an implementation detail of the library","text":"<p>We decided not to expose <code>ratio</code> and associated interfaces in the public part of the library ( breaking change ). Standardization of it could be problematic as we have <code>std::ratio</code> already.</p> <p>Alternatively, as in the public interface it was always only used with <code>mag</code>, we introduced a new helper called <code>mag_ratio</code> to provide the magnitude of the unit defined in terms of a rational conversion factor. Here is a comparison of the code with previous and current definitions:</p> NowBefore <pre><code>inline constexpr struct yard final : named_unit&lt;\"yd\", mag_ratio&lt;9'144, 10'000&gt; * si::metre&gt; {} yard;\ninline constexpr struct foot final : named_unit&lt;\"ft\", mag_ratio&lt;1, 3&gt; * yard&gt; {} foot;\n</code></pre> <pre><code>inline constexpr struct yard : named_unit&lt;\"yd\", mag&lt;ratio{9'144, 10'000}&gt; * si::metre&gt; {} yard;\ninline constexpr struct foot : named_unit&lt;\"ft\", mag&lt;ratio{1, 3}&gt; * yard&gt; {} foot;\n</code></pre>"},{"location":"blog/2024/09/27/mp-units-230-released/","title":"mp-units 2.3.0 released!","text":"<p>A new product version can be obtained from GitHub and Conan.</p> <p>This release fine-tunes many key features of the library. This post describes the most interesting improvements, while a much longer list of the changes introduced by the new version can be found in our Release Notes.</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#cmake-and-conan-options-changed","title":"CMake and Conan options changed","text":"<p>During the review on the ConanCenter, we got feedback that we should improve the handling of options for which value is automatically determined based on the current configuration. Instead of explicitly setting the <code>auto</code> value, we defer the choice between <code>True</code>/<code>False</code> until the configuration stage and set it there once all the settings are known. <code>auto</code> value for such option was removed ( breaking change ).</p> <p>If you didn't set any value at the command line for such options, everything stays the same for you. However, some changes are needed if you explicitly used <code>auto</code> like below:</p> <pre><code>conan install . -o 'mp-units:std_format=auto' -s compiler.cppstd=23 -b missing\n</code></pre> <p>Now you have to either skip such an option to keep automatic deduction:</p> <pre><code>conan install . -s compiler.cppstd=23 -b missing\n</code></pre> <p>or set it explicitly to <code>True</code> or <code>False</code> to force a specific configuration:</p> <pre><code>conan install . -o 'mp-units:std_format=True' -s compiler.cppstd=23 -b missing\n</code></pre>"},{"location":"blog/2024/09/27/mp-units-230-released/#msvc-compiler-support","title":"MSVC compiler support","text":"<p>The MSVC compiler has the most bugs in the C++20 support from all our compilers. However, with this release, we could apply many workarounds to the library's code to make it work. \ud83c\udf89</p> <p>Please note those workarounds were only applied to the library's code and not to our unit tests and examples. Trying to build the entire project on MSVC will inevitably fail to compile unless the MSVC bugs are resolved. MSVC developers still have some work to do.</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#representation-type-template-parameter-added-to-value-conversion-functions","title":"Representation type template parameter added to value conversion functions","text":"<p>Previously, changing a representation type was only possible with a <code>value_cast&lt;NewRep&gt;(q)</code> non-member function while a change of unit was supported by all <code>value_cast&lt;NewU&gt;(q)</code>, <code>q.in(NewU)</code>, and <code>q.force_in(NewU)</code>. The rationale for it was that passing an explicit type to a member function template requires a <code>template</code> disambiguator when we are dealing with a dependent name (e.g., <code>quantity</code> type is determined based on a template parameter).</p> <p>During a discussion in LEWGI at the St. Louis WG21 Meeting, we decided to provide such additional overloads despite possible issues when a dependent name is used. In such case, a user needs to provide a <code>template</code> disambiguator or switch back to using <code>value_cast</code>:</p> <pre><code>// non-dependent name\nauto f(quantity&lt;m, int&gt; q)             { return q.in&lt;double&gt;(km); }\nauto g(quantity&lt;m, int&gt; q)             { return value_cast&lt;double, km&gt;(q); }\n\n// dependent name\nauto h(QuantityOf&lt;isq::length&gt; auto q) { return q.template in&lt;double&gt;(km); }\nauto i(QuantityOf&lt;isq::length&gt; auto q) { return value_cast&lt;double, km&gt;(q); }\n</code></pre> <p>The table below provides all the value conversion functions in mp-units that may be run on <code>x</code> being the instance of either <code>quantity</code> or <code>quantity_point</code>:</p> Forcing Representation Unit Member function Non-member function No Same <code>u</code> <code>x.in(u)</code> No <code>T</code> Same <code>x.in&lt;T&gt;()</code> No <code>T</code> <code>u</code> <code>x.in&lt;T&gt;(u)</code> Yes Same <code>u</code> <code>x.force_in(u)</code> <code>value_cast&lt;u&gt;(x)</code> Yes <code>T</code> Same <code>x.force_in&lt;T&gt;()</code> <code>value_cast&lt;T&gt;(x)</code> Yes <code>T</code> <code>u</code> <code>x.force_in&lt;T&gt;(u)</code> <code>value_cast&lt;u, T&gt;(x)</code> or <code>value_cast&lt;T, u&gt;(x)</code>"},{"location":"blog/2024/09/27/mp-units-230-released/#quantity-reference-specifiers","title":"Quantity reference specifiers","text":"<p>The features described in this chapter directly solve an issue raised on std-proposals reflector. As it was reported, the code below may look correct, but it provides an invalid result:</p> <pre><code>quantity Volume = 1.0 * m3;\nquantity Temperature = 28.0 * deg_C;\nquantity n_ = 0.04401 * kg / mol;\nquantity R_boltzman = 8.314 * N * m / (K * mol);\nquantity mass = 40.0 * kg;\nquantity Pressure = R_boltzman * Temperature.in(K) * mass / n_ / Volume;\nstd::cout &lt;&lt; Pressure &lt;&lt; \"\\n\";\n</code></pre> <p>The problem is related to the accidental usage of a <code>quantity</code> rather than <code>quantity_point</code> for <code>Temperature</code>. This means that after conversion to kelvins, we will get <code>28 K</code> instead of the expected <code>301.15 K</code>, corrupting all further calculations.</p> <p>A correct code should use a <code>quantity_point</code>:</p> <pre><code>quantity_point Temperature(28.0 * deg_C);\n</code></pre> <p>This might be an obvious thing for domain experts, but new users of the library may not be aware of the affine space abstractions and how they influence temperature handling.</p> <p>After a lengthy discussion on handling such scenarios, we decided to:</p> <ul> <li>make the above code deprecated ( breaking change ),</li> <li>provide an alternative way to create a <code>quantity</code> with the <code>delta</code> quantity construction helper.</li> </ul> <p>Here are the main points of this new design:</p> <ol> <li>All references/units that specify point origin in their definition (i.e., <code>si::kelvin</code>, \u00a0 \u00a0<code>si::degree_Celsius</code>, and <code>usc::degree_Fahrenheit</code>) are excluded from the multiply syntax  ( breaking change ).</li> <li> <p>A new <code>delta</code> quantity construction helper is introduced:</p> <ul> <li><code>delta&lt;m&gt;(42)</code> results with a <code>quantity&lt;si::metre, int&gt;</code>,</li> <li><code>delta&lt;deg_C&gt;(5)</code> results with a <code>quantity&lt;si::deg_C, int&gt;</code>.</li> </ul> </li> <li> <p>A new <code>absolute</code> quantity point construction helper is introduced:</p> <ul> <li><code>absolute&lt;m&gt;(42)</code> results with a <code>quantity_point&lt;si::metre, zeroth_point_origin&lt;kind_of&lt;isq::length&gt;&gt;{}, int&gt;</code>,</li> <li><code>absolute&lt;deg_C&gt;(5)</code> results with a <code>quantity&lt;si::metre, si::ice_point, int&gt;</code>.</li> </ul> </li> </ol> <p>Info</p> <p>Please note that <code>si::kelvin</code> is also excluded from the multiply syntax to prevent the following surprising issues:</p> NowBefore <pre><code>quantity q = delta&lt;K&gt;(300);\nquantity_point qp = absolute&lt;K&gt;(300);\nstatic_assert(q.in(deg_C) != qp.in(deg_C).quantity_from_zero());\n</code></pre> <pre><code>quantity q(300 * K);\nquantity_point qp(300 * K);\nstatic_assert(q.in(deg_C) != qp.in(deg_C).quantity_from_zero());\n</code></pre> <p>We believe that the code enforced with new utilities makes it much easier to understand what happens here.</p> <p>With such changes to the interface design, the offending code will not compile as initially written. Users will be forced to think more about what they write. To enable the compilation, the users have to create explicitly:</p> <ul> <li> <p>a <code>quantity_point</code> (the intended abstraction in this example) with any of the below syntaxes:</p> <pre><code>quantity_point Temperature = absolute&lt;deg_C&gt;(28.0);\nauto Temperature = absolute&lt;deg_C&gt;(28.0);\nquantity_point Temperature(delta&lt;deg_C&gt;(28.0));\n</code></pre> </li> <li> <p>a <code>quantity</code> (an incorrect abstraction in this example) with:</p> <pre><code>quantity Temperature = delta&lt;deg_C&gt;(28.0);\nauto Temperature = delta&lt;deg_C&gt;(28.0);\n</code></pre> </li> </ul> <p>Thanks to the new design, we can immediately see what happens here and why the result might be incorrect in the second case.</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#quantity_point_like_traits-are-based-on-numerical-value-instead-of-a-quantity","title":"<code>quantity_point_like_traits</code> are based on numerical value instead of a quantity","text":"<p>In this release, we decided to fine-tune the traits that customize the conversion between custom quantity point types and the ones provided with mp-units ( breaking change ).</p> <p>Previously, such type traits were based on the <code>quantity</code> type. This was inconsistent with <code>quantity_like_traits</code>, that is working on raw values. Also, there are cases where a custom quantity point abstraction is not modelled with a quantity type. In such cases, the previous approach required additional types to be introduced for no good reason.</p> NowBefore <pre><code>template&lt;&gt;\nstruct mp_units::quantity_point_like_traits&lt;Timestamp&gt; {\n  static constexpr auto reference = si::second;\n  static constexpr auto point_origin = default_point_origin(reference);\n  using rep = decltype(Timestamp::seconds);\n\n  static constexpr convert_implicitly&lt;rep&gt; to_numerical_value(Timestamp ts)\n  {\n    return ts.seconds;\n  }\n\n  static constexpr convert_explicitly&lt;Timestamp&gt; from_numerical_value(rep v)\n  {\n    return Timestamp(v);\n  }\n};\n</code></pre> <pre><code>template&lt;&gt;\nstruct mp_units::quantity_point_like_traits&lt;Timestamp&gt; {\n  static constexpr auto reference = si::second;\n  static constexpr auto point_origin = default_point_origin(reference);\n  using rep = decltype(Timestamp::seconds);\n\n  static constexpr convert_implicitly&lt;quantity&lt;reference, rep&gt;&gt; to_quantity(Timestamp ts)\n  {\n    return ts.seconds * si::second;\n  }\n\n  static constexpr convert_explicitly&lt;Timestamp&gt; from_quantity(quantity&lt;reference, rep&gt; q)\n  {\n    return Timestamp(q.numerical_value_ref_in(si::second));\n  }\n};\n</code></pre> <p>Note</p> <p>The old behavior is deprecated and will be removed in future releases.</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#magpi","title":"<code>mag&lt;pi&gt;</code>","text":"<p>With this release, we introduced a new strongly-typed constant to create a magnitude involving scaling by <code>pi</code>. The solution used before was not consistent with magnitudes of integral values and also was leaking a floating-point value of <code>std::numbers::pi_v&lt;long double&gt;</code> to the resulting magnitude type. With the new approach, this is no longer the case, and the user-facing interface is more consistent:</p> NowBefore <pre><code>inline constexpr struct degree final : named_unit&lt;{u8\"\u00b0\", \"deg\"}, mag&lt;pi&gt; / mag&lt;180&gt; * si::radian&gt; {} degree;\n</code></pre> <pre><code>inline constexpr struct degree final : named_unit&lt;{u8\"\u00b0\", \"deg\"}, mag_pi / mag&lt;180&gt; * si::radian&gt; {} degree;\n</code></pre> <p>Note</p> <p>The old <code>mag_pi</code> helper is marked as deprecated and will be removed in future releases.</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#common-units","title":"Common units","text":"<p>Adding or subtracting two quantities of different units will force the library to find a common unit for those. This is to prevent data truncation. For the cases when one of the units is an integral multiple of the another, the resulting quantity will use a \"smaller\" one in its result. For example:</p> <pre><code>static_assert((1 * kg + 1 * g).unit == g);\nstatic_assert((1 * km + 1 * mm).unit == mm);\nstatic_assert((1 * yd + 1 * mi).unit == yd);\n</code></pre> <p>However, in many cases an arithmetic on quantities of different units will result in a yet another unit. This happens when none of the source units is an integral multiple of another. In such cases, the library returns a special type that denotes that we are dealing with a common unit of such an equation.</p> <p>Previously we returned a scaled unit calculated against our arbitrarily appointed reference unit. This resulted often in a long and messy type exposing the prime-factorized magnitude of the unit (implementation detail). In this release, we introduced a new <code>common_unit</code> wrapper for such cases:</p> NowBefore <pre><code>quantity q = 1 * km + 1 * mi;  // quantity&lt;common_unit&lt;international::mile, si::kilo_&lt;si::metre&gt;&gt;{}, int&gt;\n</code></pre> <pre><code>quantity q = 1 * km + 1 * mi;  // quantity&lt;scaled_unit&lt;magnitude&lt;power_v&lt;2, 3&gt;{}, power_v&lt;5, -3&gt;{}&gt;{}, si::metre&gt;{}, int&gt;\n</code></pre> <p>Note</p> <p>A user should never explicitly instantiate a <code>common_unit</code> class template. The library's framework will do it based on the provided quantity equation.</p> <p>Such units need special printing rules for their symbols. As they represent a minimum set of common units resulting from the addition or subtraction of multiple quantities, from this release, we print all of them as a scaled version of the source unit. Previously we were printing them relative to some arbitrary reference unit (implementation detail) that often was not spelled by the user at all in the source code. For example the following:</p> <pre><code>std::cout &lt;&lt; 1 * km + 1 * mi &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; 1 * nmi + 1 * mi &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; 1 * km / h + 1 * m / s &lt;&lt; \"\\n\";\n</code></pre> <p>will print:</p> NowBefore <pre><code>40771 ([1/25146] mi = [1/15625] km)\n108167 ([1/50292] mi = [1/57875] nmi)\n23 ([1/5] km/h = [1/18] m/s)\n</code></pre> <pre><code>40771 [8/125] m\n108167 [4/125] m\n23 [1/18] m/s\n</code></pre> <p>Thanks to the above, it might be easier for the user to reason about the magnitude of the resulting unit and its impact on the value stored in the quantity.</p> <p>Info</p> <p>In order to provide <code>common_unit</code> strong type unit wrapper we had to rename all the <code>common_XXX()</code> functions to <code>get_common_XXX()</code> ( breaking change ).</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#superpowers-of-the-unit-one","title":"Superpowers of the unit <code>one</code>","text":"<p>In this release, we also added a long-awaited change. From now on a quantity of a unit <code>one</code> can be:</p> <ul> <li>implicitly constructed from the raw value,</li> <li>explicitly converted to a raw value,</li> <li>compared to a raw value.</li> </ul> NowBefore <pre><code>quantity&lt;one&gt; inc(quantity&lt;one&gt; q) { return q + 1; }\nvoid legacy(double) { /* ... */ }\n\nif (auto q = inc(42); q != 0)\n  legacy(static_cast&lt;int&gt;(q));\n</code></pre> <pre><code>quantity&lt;one&gt; inc(quantity&lt;one&gt; q) { return q + 1 * one; }\nvoid legacy(double) { /* ... */ }\n\nif (auto q = inc(42 * one); q != 0 * one)\n  legacy(q.numerical_value_in(one));\n</code></pre> <p>This property also expands to usual arithmetic operators.</p> <p>With the above change, we can now achieve the same results in a terser way:</p> NowBefore <pre><code>static_assert(10 * km / (5 * km) == 2);\nconst quantity gain = 1. / index;\n</code></pre> <pre><code>static_assert(10 * km / (5 * km) == 2 * one);\nconst quantity gain = 1. / index * one;\n</code></pre> <p>Note</p> <p>Those rules do not apply to all the dimensionless quantities. It would be unsafe and misleading to allow such operations on units with a magnitude different than <code>1</code> (e.g., <code>percent</code> or <code>radian</code>).</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#import-std-support","title":"<code>import std;</code> support","text":"<p>This release brings experimental support for <code>import std;</code>. The only compiler that supports it for now is clang-18+. Until all the compilers start to support it and CMake removes the experimental tag from this feature, we will also keep it experimental.</p> <p>As all of the C++ compilers are buggy for now, it is not allowed to bring the same definitions through the <code>import std;</code> and regular header files. This applies not only to the current project but also to all its dependencies. This is why, in order to use it with mp-units, we need to disable all the dependencies as well (enforced with <code>conanfile.py</code>). It means that we have to use <code>std::format</code> (instead of fmtlib) and remove functions contract checking.</p> <p>With the above assumptions, we can refactor our smoot example to:</p> <pre><code>import mp_units;\nimport std;\n\nusing namespace mp_units;\n\ninline constexpr struct smoot final : named_unit&lt;\"smoot\", mag&lt;67&gt; * usc::inch&gt; {} smoot;\n\nint main()\n{\n  constexpr quantity dist = 364.4 * smoot;\n  std::println(\"Harvard Bridge length = {::N[.1f]} ({::N[.1f]}, {::N[.2f]}) \u00b1 1 \u03b5ar\",\n               dist, dist.in(usc::foot), dist.in(si::metre));\n}\n</code></pre>"},{"location":"blog/2024/09/27/mp-units-230-released/#unit_can_be_prefixed-removed","title":"<code>unit_can_be_prefixed</code> removed","text":"<p>Previously, the <code>unit_can_be_prefixed</code> type trait was used to limit the possibility to prefix some units that are officially known as non-prefixable (e.g., hour, minute).</p> <p>It turned out that it is not easy to determine whether some units can be prefixed. For example, for degree Celsius, the ISO 80000-5 standard explicitly states:</p> <p>Prefixes are not allowed in combination with the unit \u00b0C.</p> <p>On the other hand this NIST page says:</p> <p>Prefix symbols may be used with the unit symbol \u00baC and prefix names may be used with the unit name \u201cdegree Celsius.\u201d For example, 12 m\u00baC (12 millidegrees Celsius) is acceptable.</p> <p>It seems that it is also a common engineering practice.</p> <p>To prevent such issues, we decided to simplify the library's design and remove the <code>unit_can_be_prefixed</code> type trait ( breaking change ).</p> <p>From now on, every named unit in the library can be prefixed with the SI or IEC prefix.</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#iec80000-system-renamed-to-iec","title":"<code>iec80000</code> system renamed to <code>iec</code>","text":"<p>As we mentioned IEC already, in this release, we decided to rename the name of the system and its corresponding namespace from <code>iec80000</code> to <code>iec</code> ( breaking change ). This involves renaming of a defining header file and of the namespace it provides.</p> <p>With this change it should be easier to type the namespace name. This name is also more correct for some quantities and units that are introduced by IEC but not necessarily in the ISO/IEC 80000 series of documents (e.g., <code>iec::var</code>).</p> <p>Note</p> <p>The old <code>iec80000</code> namespace in iec8000.h is marked as deprecated and will be removed in future releases.</p>"},{"location":"blog/2024/09/27/mp-units-230-released/#error-messages-related-improvements","title":"Error messages-related improvements","text":"<p>The readability of compile-time error messages is always a challenge for generic C++ libraries. However, for quantities and units library, generating readable errors is the most important requirement. If you do not make errors, you do not need such a library in your project .</p> <p>This is why we put lots of effort into improving here. Besides submitting compiler bugs to improve on their part, we also try to do our best here.</p> <p>Some compilers do not present the type resulting from calling a function within a template argument. This ends up with statements like <code>get_quantity_spec(si::second{})</code> in the error message. Some less experienced users of the library may not know what this mean, and then why the conversion error happens.</p> <p>To improve this, we injected additional helper concepts into the definitions. It results with a bit longer but a more readable error in the end.</p> <p>For example:</p> NowBefore <pre><code>error: no matching member function for call to 'in'\n   15 | const quantity time_to_goal = (distance * speed).in(s);\n      |                               ~~~~~~~~~~~~~~~~~~~^~\nnote: candidate template ignored: constraints not satisfied [with ToU = struct second]\n  221 |   [[nodiscard]] constexpr QuantityOf&lt;quantity_spec&gt; auto in(ToU) const\n      |                                                          ^\nnote: because 'detail::UnitCompatibleWith&lt;si::second, unit, quantity_spec&gt;' evaluated to false\n  219 |   template&lt;detail::UnitCompatibleWith&lt;unit, quantity_spec&gt; ToU&gt;\n      |            ^\nnote: because '!AssociatedUnit&lt;si::second&gt;' evaluated to false\n  164 |   (!AssociatedUnit&lt;U&gt; || UnitOf&lt;U, QS&gt;) &amp;&amp; detail::UnitConvertibleTo&lt;FromU, U{}&gt;;\n      |    ^\nnote: and 'UnitOf&lt;si::second, kind_of_&lt;derived_quantity_spec&lt;power&lt;isq::length, 2&gt;, per&lt;isq::time&gt; &gt; &gt;{}&gt;' evaluated to false\n  164 |   (!AssociatedUnit&lt;U&gt; || UnitOf&lt;U, QS&gt;) &amp;&amp; detail::UnitConvertibleTo&lt;FromU, U{}&gt;;\n      |                          ^\nnote: because 'detail::QuantitySpecConvertibleTo&lt;get_quantity_spec(si::second{}), kind_of_&lt;derived_quantity_spec&lt;power&lt;isq::length, 2&gt;, per&lt;isq::time&gt; &gt; &gt;{}&gt;' evaluated to false\n  141 |                  detail::QuantitySpecConvertibleTo&lt;get_quantity_spec(U{}), QS&gt; &amp;&amp;\n      |                  ^\nnote: because 'implicitly_convertible(kind_of_&lt;struct time&gt;{}, kind_of_&lt;derived_quantity_spec&lt;power&lt;isq::length, 2&gt;, per&lt;isq::time&gt; &gt; &gt;{})' evaluated to false\n  151 |   implicitly_convertible(From, To);\n      |   ^\n1 error generated.\nCompiler returned: 1\n</code></pre> <pre><code>error: no matching member function for call to 'in'\n   15 | const quantity time_to_goal = (distance * speed).in(s);\n      |                               ~~~~~~~~~~~~~~~~~~~^~\nnote: candidate template ignored: constraints not satisfied [with U = struct second]\n  185 |   [[nodiscard]] constexpr QuantityOf&lt;quantity_spec&gt; auto in(U) const\n      |                                                          ^\nnote: because 'detail::UnitCompatibleWith&lt;si::second, unit, quantity_spec&gt;' evaluated to false\n  183 |   template&lt;detail::UnitCompatibleWith&lt;unit, quantity_spec&gt; U&gt;\n      |            ^\nnote: because '!AssociatedUnit&lt;si::second&gt;' evaluated to false\n  207 |   (!AssociatedUnit&lt;U&gt; || UnitOf&lt;U, QS&gt;)&amp;&amp;(detail::have_same_canonical_reference_unit(U{}, U2));\n      |    ^\nnote: and 'UnitOf&lt;si::second, kind_of_&lt;derived_quantity_spec&lt;power&lt;isq::length, 2&gt;, per&lt;isq::time&gt; &gt; &gt;{}&gt;' evaluated to false\n  207 |   (!AssociatedUnit&lt;U&gt; || UnitOf&lt;U, QS&gt;)&amp;&amp;(detail::have_same_canonical_reference_unit(U{}, U2));\n      |                          ^\nnote: because 'implicitly_convertible(get_quantity_spec(si::second{}), kind_of_&lt;derived_quantity_spec&lt;power&lt;length, 2&gt;, per&lt;time&gt; &gt; &gt;{})' evaluated to false\n  187 |   implicitly_convertible(get_quantity_spec(U{}), QS) &amp;&amp;\n      |   ^\n1 error generated.\nCompiler returned: 1\n</code></pre> <p>Note</p> <p>The above error messages were stripped a bit of the additional information (file name, namespace name, nested curlies) to provide better readability.</p>"},{"location":"blog/2024/11/05/mp-units-240-released/","title":"mp-units 2.4.0 released!","text":"<p>A new product version can be obtained from GitHub and Conan.</p> <p>This release was unexpected. We planned a significant new feature to happen next, but while preparing for it, and also while writing API Reference documentation, we made so many vital fixes and improvements that we decided that they deserve a dedicated release first.</p> <p>This post describes the most significant improvements while a much longer list of the changes introduced by the new version can be found in our Release Notes.</p>"},{"location":"blog/2024/11/05/mp-units-240-released/#isq-quantities-cleanup","title":"ISQ quantities cleanup","text":"<p>Initially, we kept quantities defined in \"IEC 80000-13: Information science and technology\" in a standalone <code>iec80000</code> namespace, which was renamed to <code>iec</code> in the previous release. It turned out that this was incorrect. Those quantities are also a part of the ISQ. This is why, in this release, we moved all of them to the <code>isq</code> namespace ( breaking change ).</p> <p>From now on, <code>iec</code> namespace does not provide any quantities and serves purely as a system of units definition. It contains binary prefixes (based on the powers of two) and some units introduced by IEC (e.g., <code>var</code>, <code>erlang</code>, <code>bit</code>, or <code>`baud</code>).</p> <p>Note</p> <p>The quantities in <code>iec</code> namespace are now deprecated and will be removed in future releases.</p> <p>Also, it turns out that the latest ISO 80000-3 revision makes a small cleanup to the <code>phase_speed</code> and <code>group_speed</code> quantities. Those were always defined as scalar quantities but also had alternative names <code>phase_velocity</code> and <code>group_velocity</code>. This is misleading as velocity is typically considered a vector quantity. It is why those <code>XXX_velocity</code> aliases were removed from the ISO standard and from mp-units library ( breaking change ).</p>"},{"location":"blog/2024/11/05/mp-units-240-released/#units-equality","title":"Units equality","text":"<p>Previously we assumed that units like <code>J</code>, <code>N m</code>, and <code>kg m\u00b2/s\u00b2</code> are equal. In some cases, this might not be entirely correct. Some quantities require a specific derived unit instead of a unit with a special name. For example:</p> <ul> <li><code>N m</code> should be used for moment of force (instead of <code>J</code>),</li> <li><code>V A</code> should be used for apparent power (instead of <code>W</code>).</li> </ul> <p>This is why, starting from this release units like <code>J</code>, <code>N m</code>, and <code>kg m\u00b2/s\u00b2</code> will not compare equal ( breaking change ). However, they are deemed equivalent:</p> <pre><code>static_assert(equivalent(J, N * m));\nstatic_assert(equivalent(W, V * A));\n</code></pre>"},{"location":"blog/2024/11/05/mp-units-240-released/#portable-text-output","title":"Portable text output","text":"<p>From the very beginning, the text output of symbols could be formatted in two different ways:</p> <ul> <li>Unicode,</li> <li>portable using so-called ASCII alternatives.</li> </ul> <p>mp-units used the terms \"Unicode\" or \"ASCII\" and 'U' or 'A' formatting options for them. Even though those terms are widely understood in the C++ community, they are technically incorrect.</p> <p>During the recent SG16 meeting, we looked for proper alternatives and ended up with the \"portable\" and \"UTF-8\" terms ( breaking change ).</p> <p>From now on, we will provide the following:</p> <ul> <li><code>text_encoding::utf8</code>, <code>symbol_text&lt;N, M&gt;::utf8()</code>, and <code>U</code> formatting option,</li> <li><code>text_encoding::portable</code>, <code>symbol_text&lt;N, M&gt;::portable()</code>, and <code>P</code> formatting option.</li> </ul> <p>Note</p> <p>The old identifiers and formatting options are now deprecated and will be removed in future releases.</p>"},{"location":"blog/2024/11/05/mp-units-240-released/#char_traits-removed-from-fixed_string","title":"<code>char_traits</code> removed from <code>fixed_string</code>","text":"<p>During the same SG16 meeting, the room was strongly against providing <code>char_traits</code> for <code>fixed_string</code>. This is why <code>char_traits</code> support was removed in this release ( breaking change ).</p>"},{"location":"blog/2024/11/05/mp-units-240-released/#improved-units-text-output","title":"Improved units' text output","text":"<p>In the previous release, we introduced common unit abstraction. Initially, all its components were printed in parenthesis which contained a list of all the scaled units separated with <code>=</code>. After some feedback, we decided to change it to a new syntax.</p> <p>For example, the following:</p> <pre><code>std::cout &lt;&lt; 1 * km + 1 * mi &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; 1 * nmi + 1 * mi &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; 1 * km / h + 1 * m / s &lt;&lt; \"\\n\";\n</code></pre> <p>will print:</p> NowBefore <pre><code>40771 EQUIV{[1/25146 mi], [1/15625 km]}\n108167 EQUIV{[1/50292 mi], [1/57875 nmi]}\n23 EQUIV{[1/5 km/h], [1/18 m/s]}\n</code></pre> <pre><code>40771 ([1/25146] mi = [1/15625] km)\n108167 ([1/50292] mi = [1/57875] nmi)\n23 ([1/5] km/h = [1/18] m/s)\n</code></pre> <p>As we can see above, the scaled units output changed as well. Now, the entire scaled unit is encapsulated within <code>[...]</code> brackets to better denote its scope.</p> <p>Additionally, small magnitudes of scaled units do not use the power of <code>10</code>, and also scaled units do not have a composition priority over the derived units anymore.</p> <p>As a result of those changes, the following:</p> <pre><code>constexpr Unit auto L_per_100km = L / (mag&lt;100&gt; * km);\nstd::cout &lt;&lt; 6.7 * L_per_100km &lt;&lt; \"\\n\";\n</code></pre> <p>prints:</p> NowBefore <pre><code>6.7 L/[100 km]\n</code></pre> <pre><code>6.7 \u00d7 10\u207b\u00b2 l/km\n</code></pre> <p>One more change that we can see above is that litre now use 'L' instead of 'l' for its symbol. The latter one too often is confused with the number <code>1</code>.</p> <p>The next improvement adds proper formatting support for magnitudes. All of the formatting options that were working before for the unit symbols now also work for magnitudes.</p> <p>For example:</p> <pre><code>using enum text_encoding;\nusing enum unit_symbol_solidus;\nusing usf = unit_symbol_formatting;\n\nstatic_assert(unit_symbol(mag&lt;1&gt; / (mag&lt;2&gt; * mag&lt;pi&gt;)*metre) == \"[2\u207b\u00b9 \ud835\udf0b\u207b\u00b9 m]\");\nstatic_assert(unit_symbol&lt;usf{.solidus = always}&gt;(mag&lt;1&gt; / (mag&lt;2&gt; * mag&lt;pi&gt;)*metre) == \"[1/(2 \ud835\udf0b) m]\");\nstatic_assert(unit_symbol&lt;usf{.encoding = portable, .solidus = always}&gt;(mag&lt;1&gt; / (mag&lt;2&gt; * mag&lt;pi&gt;)*metre) ==\n              \"[1/(2 pi) m]\");\n</code></pre> <p>As we can see above, the library also learned how to print magnitude symbols. This required a change in the <code>mag_constant</code> definition. Now, it takes a magnitude symbol and has to be <code>final</code> like for other similar types in the library ( breaking change ):</p> <pre><code>inline constexpr struct pi final : mag_constant&lt;symbol_text{u8\"\u03c0\", \"pi\"}, std::numbers::pi_v&lt;long double&gt;&gt; {} pi;\ninline constexpr auto \u03c0 = pi;\n</code></pre>"},{"location":"blog/2024/11/05/mp-units-240-released/#unicode-identifiers","title":"Unicode identifiers","text":"<p>The example above introduced something interesting: a <code>\u03c0</code> identifier for a variable. With the latest changes to the C++ language, we can officially use Unicode symbols as identifiers in the C++ code.</p> <p>In this release, we've added Unicode identifiers support not only for <code>\u03c0</code> magnitude constant but also for unit symbols.</p> <p>Now we can type the following:</p> With UTF-8 glyphsPortable <pre><code>quantity resistance = 60 * k\u03a9;\nquantity capacitance = 100 * \u00b5F;\n</code></pre> <pre><code>quantity resistance = 60 * kohm;\nquantity capacitance = 100 * uF;\n</code></pre> <p>This might make the source code easier to understand, but typing those identifiers can be tricky. Sometimes, the best solution to type it might be a copy-paste approach. If we do not like this idea, we can still use old portable identifiers for those as well.</p>"},{"location":"blog/2024/11/05/mp-units-240-released/#convertibility-with-quantitylike-and-quantitypointlike-entities","title":"Convertibility with <code>QuantityLike</code> and <code>QuantityPointLike</code> entities","text":"<p>In this release, we decided to fine-tune further the traits that customize the conversion between custom quantity and quantity point types and the ones provided with mp-units ( breaking change ).</p> <p>Previously, <code>to_numerical_value</code> and <code>from_numerical_value</code> returned a type wrapped in a special tag type describing the conversion type (explicit or implicit).</p> <p>This was a novel and experimental approach. Finally, we decided not to do it and used a bit more verbose but a more standard solution. From now on, we need to provide two additional static data members of type <code>bool</code>:</p> <ul> <li><code>explicit_import</code> - <code>true</code> means that the conversion to the mp-units abstraction is explicit,</li> <li><code>explicit_export</code> - <code>true</code> means that the conversion from the mp-units abstraction is   explicit.</li> </ul> NowBefore <pre><code>template&lt;&gt;\nstruct mp_units::quantity_point_like_traits&lt;Timestamp&gt; {\n  static constexpr auto reference = si::second;\n  static constexpr auto point_origin = default_point_origin(reference);\n  static constexpr bool explicit_import = false;\n  static constexpr bool explicit_export = true;\n  using rep = decltype(Timestamp::seconds);\n\n  static constexpr rep to_numerical_value(Timestamp ts)\n  {\n    return ts.seconds;\n  }\n\n  static constexpr Timestamp from_numerical_value(rep v)\n  {\n    return Timestamp(v);\n  }\n};\n</code></pre> <pre><code>template&lt;&gt;\nstruct mp_units::quantity_point_like_traits&lt;Timestamp&gt; {\n  static constexpr auto reference = si::second;\n  static constexpr auto point_origin = default_point_origin(reference);\n  using rep = decltype(Timestamp::seconds);\n\n  static constexpr convert_implicitly&lt;rep&gt; to_numerical_value(Timestamp ts)\n  {\n    return ts.seconds;\n  }\n\n  static constexpr convert_explicitly&lt;Timestamp&gt; from_numerical_value(rep v)\n  {\n    return Timestamp(v);\n  }\n};\n</code></pre>"},{"location":"blog/2024/11/05/mp-units-240-released/#symbolic-constants-implementation-should-be-implementation-defined","title":"Symbolic constants implementation should be implementation-defined","text":"<p>In the process of writing API Reference, we decided to hide all the metadata associated with symbolic constants - tag types used to define units, dimensions, quantity specification, etc. ( breaking change ).</p> <p>All the types and values exposed by such types are needed only in the implementation details of the library. Users should not need them. Hiding those and making them implementation-defined gives other vendors the freedom to choose different ways to implement features of this library in their codebases.</p> <p>Important</p> <p>Based on Hyrum's Law some users may depend on this information already, and this release will break their code.</p> <p>If that is the case for you, we would love to hear about your use case and its rationale. It may mean that we should either:</p> <ul> <li>extend the library's functionality to support your use case out of the box and keep those   members hidden,</li> <li>restore public visibility of such members and enforce this in the API Reference so that all   the users of various library implementations may use them in the same way as you.</li> </ul>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/","title":"Bringing Quantity-Safety To The Next Level","text":"<p>All quantities and units libraries need to be unit-safe. Most of the libraries on the market do this correctly. Some of them are also dimension-safe, which adds another level of protection for their users.</p> <p>mp-units is probably the only library on the market that additionally is quantity-safe. This gives a new quality and possibilities. I've described the major idea behind it, implementation details, and benefits to the users in the series of posts about the International System of Quantities.</p> <p>However, this is only the beginning. We've always planned more and worked on the extensions in our free time. In this post, I will describe:</p> <ul> <li>What a quantity character is?</li> <li>The importance of using proper representation types for the quantities.</li> <li>The power of providing character-specific operations for the quantities.</li> <li>Discuss implementation challenges and possible solutions.</li> </ul>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#quantity-characters","title":"Quantity characters","text":"<p>A quantity character determines the properties and operations that can be performed on the numerical value of a quantity.</p> <p>Quantities defined by the ISQ may be of the following characters:</p> <ul> <li>real scalar (e.g., time, width, speed, apparent power),</li> <li>complex scalar (e.g., voltage phasor, complex power, impedance),</li> <li>vector (e.g., displacement, velocity, force),</li> <li>tensor (e.g., moment of inertia, stress, strain).</li> </ul> <p>From the beginning, mp-units V2 was meant to properly support quantities of various characters. By default, all quantity types are scalars, but we can set any other quantity character in a <code>quantity_spec</code> definition. For example:</p> <pre><code>inline constexpr struct displacement final : quantity_spec&lt;length, quantity_character::vector&gt; {} displacement;\n</code></pre> <p>Character of derived quantities is inherited from the quantity equation taking into account the operations and their ingredients. For example the below velocity quantity will automatically get a vector character without the need to explicitly state it in the definition:</p> <pre><code>inline constexpr struct velocity final : quantity_spec&lt;displacement / duration&gt; {} velocity;\n</code></pre> <p>Similarly, the below will yield a speed quantity of a scalar character:</p> <pre><code>inline constexpr struct speed final : quantity_spec&lt;magnitude(velocity)&gt; {} speed;\n</code></pre>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#representation-types","title":"Representation types","text":"<p>mp-units V2 requires providing representation types compatible with a specific character set in its <code>quantity_spec</code> definition:</p> <pre><code>template&lt;Reference auto R, RepresentationOf&lt;get_quantity_spec(R)&gt; Rep = double&gt;\nclass quantity;\n</code></pre> <p>For example, this allows us to check that vector representation type is used to construct a velocity quantity and to ensure that speed gets a scalar:</p> <pre><code>quantity q = vector{1, 2, 3} * m / s;\nquantity velocity = isq::velocity(q);\n// quantity speed = isq::speed(q);     // Compile-time error\n</code></pre> <p>Another example here may be a complex power quantity that should use a representation type modeling a complex number, but apparent power, active power, and reactive power should get scalars.</p> <p>As we can see above, in the case of <code>q</code>, we can use any representation type with a quantity kind that just specify a unit (simple quantities). However, we need to provide a compatible representation type when we want to use strongly-typed quantities and be quantity-safe.</p> <p>Such checks already prevent many simple but common errors of mixing similar quantities in a specific domain.</p> <p>Info</p> <p>It is a common engineering practice to use fundamental types for vector quantities when we know the direction of the vector. For example, in many cases, we use <code>double</code> to express velocity or acceleration. In such cases, negative values mean moving backward or decelerating. This is why we also decided to allow such use cases in the library. A scalar representation type that provides <code>abs()</code> member or non-member function or works with <code>std::abs()</code> is considered a one-dimensional vector type:</p> <pre><code>quantity speed = isq::speed(60 * km / h);\nquantity velocity = isq::velocity(60 * km / h);\n</code></pre>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#character-specific-operations","title":"Character-specific operations","text":"<p>Checking the representation type is only the first step in bringing additional safety. The real power comes with implementing character-specific operations.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#current-state-of-the-art","title":"Current state of the art","text":"<p>Most units libraries on the market (not only for C++) provide only regular arithmetic operations for scalars and don't constrain them for quantities of other characters. They also do not offer any character-specific operations.</p> <p>For example, let's look closer into vector quantities. Most of the libraries on the market will happily accept the following or similar code:</p> <pre><code>auto force = get_force();\nauto length = get_length();\nauto work = force * length;\n</code></pre> <p>They will also accept the following line:</p> <pre><code>auto moment_of_force = force * length;\n</code></pre> <p>Does it mean that moment of force and work are the same quantities? Of course not! It is just how naive most libraries are today.</p> <p>But first, to defend them, I must admit that the behavior above is partially OK. <code>force * length</code> could yield some specific quantity, but it is definitely not work or moment of force.</p> <p>There are two problems here:</p> <ol> <li>Libraries on the market are not aware of the characters of the quantities being used in the equation.    This means they can't prevent scalar arithmetic operations from being performed on vector quantities.    This typically leads to compile-time errors when a proper linear algebra representation type is    used in a quantity, as most linear algebra libraries will not overload <code>operator*</code> for vectors,    and those that do, treat it as a dot product, which returns a scalar.</li> <li>None of the libraries allows us to constrain the return type of such multiplication with    a specific quantity type to specify exactly what we want to achieve. Most of them allow for replacing    <code>auto</code> with a type that describes just a unit, or, at best, the dimension. This means that all of    them are unit-safe, and some are also dimension-safe. However, this is not helpful here and does    not allow the library to do any additional compile-time checks on the resulting quantities.    The fact that we named the results as <code>work</code> or <code>moment_of_force</code> does not mean anything to    the compiler or the library being used.</li> </ol> <p>This isn't good.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#benefits-of-quantity-safe-library","title":"Benefits of quantity-safe library","text":"<p>As we've stated in the beginning, mp-units, besides being unit-safe and dimension-safe, is also quantity-safe. Let's see what it means.</p> <p>Note</p> <p>The features described below are planned for the next major release of the library and are not available on the master branch as of today.</p> <p>First, we repeat what other libraries did:</p> <pre><code>quantity force = get_force();\nquantity length = get_length();\nquantity q1 = force * length;\n</code></pre> <p>The code compiles as long as <code>length</code> is a scalar quantity with a scalar representation type. We can always multiply or divide a vector quantity (e.g., force) by a scalar one.</p> <p>However, things stop compiling when we want to convert the obtained result to a specific quantity type:</p> <pre><code>// quantity moment_of_force = isq::moment_of_force(q1);  // Compile-time error\n// quantity work = isq::work(q1);                        // Compile-time error\n</code></pre> <p>Neither moment of force nor work quantity can be created from a scalar length. We need very specific vector quantities of kind length to do that:</p> <pre><code>quantity displacement = get_displacement();\nquantity position_vector = get_position_vector();\n</code></pre> <p>Now, if we try to multiply the variables as before, we will end up with a compilation error:</p> <pre><code>// quantity q2 = force * displacement;                   // Compile-time error\n// quantity q3 = force * position_vector;                // Compile-time error\n</code></pre> <p>Multiplication on vectors is mathematically not defined. We have to use proper operations:</p> <pre><code>quantity q2 = scalar_product(force, displacement);\nquantity q3 = scalar_product(force, position_vector);\nquantity q4 = vector_product(force, displacement);\nquantity q5 = vector_product(force, position_vector);\n</code></pre> <p>All of the above compile and result in some quantities. After that, we can try to convert those results to our required quantities:</p> <pre><code>quantity work = isq::work(q2).in[J];\n// quantity work = isq::work(q3);                        // Compile-time error\n// quantity work = isq::work(q4);                        // Compile-time error\n// quantity work = isq::work(q5);                        // Compile-time error\n</code></pre> <p>Important</p> <p>It is essential to realize that just like multiplication and division are for scalars, vector and scalar products are for vectors. We never want to accept a quantity that accidentally was created with multiplication instead of division of its arguments or with the scalar product instead of a vector product, right?</p> <p>So we are done with work. Let's create a moment of force quantity as well. It might be surprising to many that none of the following code compiles:</p> <pre><code>// quantity moment_of_force = isq::moment_of_force(q2);  // Compile-time error\n// quantity moment_of_force = isq::moment_of_force(q3);  // Compile-time error\n// quantity moment_of_force = isq::moment_of_force(q4);  // Compile-time error\n// quantity moment_of_force = isq::moment_of_force(q5);  // Compile-time error\n</code></pre> <p>Do you know why it does not compile? Please try to think about it for a minute and figure out what is the problem before checking the answer below.</p> !!! Spoiler alert !!! <p>Vector product is anti-commutative. Similarly to the division for scalars, for a vector product it is important to decide which quantity we put on the left and right-hand side of the operation.</p> <p>To make it compile, we need to reverse the arguments of a <code>vector_product()</code> operation:</p> <pre><code>quantity q6 = vector_product(position_vector, force);\nquantity moment_of_force = isq::moment_of_force(q6);\n</code></pre> <p>Do you start to see the need for such checks at compile-time already? </p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#explicit-conversions-are-not-really-needed","title":"Explicit conversions are not really needed","text":"<p>You may be worried by the fact that we needed explicit quantity conversions above and that the code without them compiled fine. It might look like a safety pitfall, but it is really not an issue.</p> <p>The code above used a <code>quantity</code> CTAD placeholder which works a bit like <code>auto</code>. It accepts any quantity and deduced proper type for it. And all of the above operations resulted in some quantities, but often not the ones we were interested in.</p> <p>In the production code, we deal with strong types in many places (members in classes, function arguments and return types, etc.). In generic code, we should use concepts to constrain template parameters. This will be enough to guarantee quantity-safety.</p> <p>For example:</p> <pre><code>void func1(quantity&lt;isq::work[J]&gt; w);\nvoid func2(QuantityOf&lt;isq::moment_of_force&gt; auto mof);\n\nfunc1(q2);\nfunc2(q6);\n// func1(q6);  // Compile-time error\n// func2(q2);  // Compile-time error\n</code></pre>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#peeking-under-the-hood","title":"Peeking under the hood","text":"<p>Let's look at the definitions of work and moment of force quantities to understand how and why the above works:</p> <pre><code>inline constexpr struct work final : quantity_spec&lt;scalar_product(force, displacement)&gt; {} work;\ninline constexpr struct moment_of_force final : quantity_spec&lt;vector_product(position_vector, force)&gt; {} moment_of_force;\n</code></pre> <p><code>scalar_product()</code> and <code>vector_product()</code> functions are overloaded not only for <code>quantity</code> but also for <code>quantity_spec</code> types. The results of such operations are symbolic expressions that identify those operations. When used as a quantity recipe in a <code>quantity_spec</code> definition, they tell the library which derived quantities may be implicitly converted to our quantity.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#what-do-other-libraries-do","title":"What do other libraries do?","text":"<p>I am probably not wrong in stating that none of the major C++ units libraries on the market provides vector or complex operations on quantities. This is why none of them will work when a proper representation type will be provided to a quantity. Trying to do any operations on a quantity with a linear algebra vector as its representation type will fail to compile.</p> <p>This is also mostly true for other programming languages. A great exception, and in fact the only library that I know which provides such operations, is Python's Pint (thanks to NumPy support).</p> <p>As other libraries do not support quantities of a vector type, they require users to create homogenous vectors of quantities and do all of the linear algebra operations with a 3rd party library. This approach can't be quantity-safe!</p> <p>In such scenarios, the units library can't detect if an external linear algebra library performs a scalar or vector product operation. It only observes the individual multiplications on scalar ingredients of an external vector type. This is actually why such multiplication operations are provided in other units libraries in the first place.</p> <p>Let's compare those approaches:</p> Quantity-SafeAlso Quantity-SafeOther units libraries <pre><code>quantity displacement_1 = isq::displacement(la::vector{1, 2, 3} * m);\nquantity displacement_2 = isq::displacement(la::vector{2, 1, 0} * m);\nquantity displacement = displacement_1 + displacement_2;\nquantity force = isq::force(la::vector{42, 42, 42} * N);\nquantity work = isq::work(scalar_product(force, displacement));\n</code></pre> <pre><code>quantity displacement_1 = la::vector{1, 2, 3} * m;\nquantity displacement_2 = la::vector{2, 1, 0} * m;\nquantity displacement = displacement_1 + displacement_2;\nquantity force = la::vector{42, 42, 42} * N;\nquantity&lt;isq::work[J]&gt; work = scalar_product(force, displacement);\n</code></pre> <pre><code>la::vector&lt;quantity&lt;si::metre&gt;&gt; displacement_1 = la::vector{1 * m, 2 * m, 3 * m};\nla::vector&lt;quantity&lt;si::metre&gt;&gt; displacement_2 = la::vector{2 * m, 1 * m, 0 * m};\nla::vector&lt;quantity&lt;si::metre&gt;&gt; displacement = displacement_1 + displacement_2;\nla::vector&lt;quantity&lt;si::newton&gt;&gt; force = la::vector{42 * N, 42 * N, 42 * N};\nquantity&lt;si::joule&gt; work = la::scalar_product(force, displacement);\n</code></pre> <p>Of course, someone could argue that incorrect use of a vector product operation above would also be safe as it will not compile as the return type differs. Yes, it is true. However, please remember that there are more cases where errors may happen.</p> <p>For example, an external linear algebra library will not protect us from providing arguments to a vector product in an invalid order.</p> <p>Also, our <code>work</code> quantity will never be able to detect if what we are trying to assign to it is a result of a scalar product of two vector quantities of displacement and force, or maybe just some naive multiplication of scalar quantities that accidentally matched the dimensionality of the expected result.</p> <p>Please also remember that the quantity characters are not only about linear algebra. For example, in the case of complex quantities, we want to ensure that only:</p> <ul> <li>the real part of a complex power is assigned to an active power,</li> <li>the imaginary part of a complex power is assigned to an reactive power,</li> <li>the modulus of a complex power is assigned to an apparent power.</li> </ul> <p>Mixing the above is a fatal error in power systems engineering.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#implementation-challenges","title":"Implementation challenges","text":"<p>I had planned to implement the above features for a few years now but never had enough time to do it. Now, I am close to finishing the work. However, I've discovered a few interesting issues on the way, and I have to solve them before putting my code on the mainline and releasing the next mp-units version.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#modeling-magnitudes","title":"Modeling magnitudes","text":"<p>Let's dig in a bit more into proper modelling of position vector and displacement quantities. First, we have to think to which scalar quantities their magnitude should convert to:</p> <ul> <li>a magnitude of a position vector is equivalent to a radial distance quantity,</li> <li>a magnitude of a displacement is a special case of a distance quantity.</li> </ul> <p>Taking the above into account, we should refactor our tree of quantities of kind length into the following:</p> <pre><code>flowchart TD\n    length[\"&lt;b&gt;length&lt;/b&gt;&lt;br&gt;[m]\"]\n    length --- width[\"&lt;b&gt;width&lt;/b&gt; / &lt;b&gt;breadth&lt;/b&gt;\"]\n    length --- height[\"&lt;b&gt;height&lt;/b&gt; / &lt;b&gt;depth&lt;/b&gt; / &lt;b&gt;altitude&lt;/b&gt;\"]\n    width --- thickness[\"&lt;b&gt;thickness&lt;/b&gt;\"]\n    width --- diameter[\"&lt;b&gt;diameter&lt;/b&gt;\"]\n    width --- radius[\"&lt;b&gt;radius&lt;/b&gt;\"]\n    radius --- radius_of_curvature[\"&lt;b&gt;radius_of_curvature&lt;/b&gt;\"]\n    length --- path_length[\"&lt;b&gt;path_length&lt;/b&gt;\"]\n    path_length --- distance[\"&lt;b&gt;distance&lt;/b&gt;\"]\n    distance --- displacement[\"&lt;b&gt;displacement&lt;/b&gt;&lt;br&gt;{vector}\"]\n    distance --- radial_distance[\"&lt;b&gt;radial_distance&lt;/b&gt;\"]\n    radial_distance --- position_vector[\"&lt;b&gt;position_vector&lt;/b&gt;&lt;br&gt;{vector}\"]\n    length --- wavelength[\"&lt;b&gt;wavelength&lt;/b&gt;\"]</code></pre> <p>Having the above, we can look a bit closer into how velocity and speed are defined in the ISQ:</p> <p>ISO 80000-3: Space and time</p> <p>velocity - vector quantity giving the rate of change of a position vector.</p> <p>speed - magnitude of the velocity.</p> <p>Change of a position vector is nothing else than a displacement. This means that velocity and speed can be defined as follows:</p> <pre><code>inline constexpr struct velocity final : quantity_spec&lt;displacement / duration&gt; {} velocity;\ninline constexpr struct speed final : quantity_spec&lt;magnitude(velocity)&gt; {} speed;\n</code></pre> <p>This is compatible with the ISQ definitions. However, we should check what it means from the engineering point of view. Let's assume that we want to calculate speed directly from a distance traveled and duration, without using any vector quantities like displacement or velocity:</p> <pre><code>quantity&lt;isq::distance[m]&gt; distance = 42 * m;\nquantity&lt;isq::duration[s]&gt; duration = 2 * s;\n// quantity&lt;isq::speed[m / s]&gt; speed = distance / duration;  // Compile-time error\n</code></pre> <p>The above does not compile because distance quantity is not implicitly convertible to magnitude(displacement). This is the same case as stating that not every length is a distance. We need to cast here explicitly. To fix it, we can do any of the below:</p> <pre><code>quantity&lt;isq::speed[m / s]&gt; speed1 = isq::speed(distance / duration);\nquantity&lt;isq::speed[m / s]&gt; speed2 = magnitude(isq::displacement)(distance) / duration;\n</code></pre> <p>Also, the following will work:</p> <pre><code>quantity length_kind = 42 * m;\nquantity&lt;isq::speed[m / s]&gt; speed3 = length_kind / duration;\n</code></pre> <p>If we do not specify a specific quantity type and just use an SI unit, then we deal with the kind of quantity. Such quantity can behave like any quantity from the hierarchy tree with the same character, so it is also the same as <code>magnitude(isq::displacement)</code>.</p> <p>Question</p> <p>Is it good enough from the engineering and usability point of views? If you would like to share your thoughts, please provide your comments below the article.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#more-about-displacement-and-position-vector","title":"More about displacement and position vector","text":"<p>As we've stated above, a change of position vector is a displacement. Let's try to calculate it here:</p> <pre><code>quantity pos1 = isq::position_vector(vector{1, 2} * m);\nquantity pos2 = isq::position_vector(vector{2, 3} * m);\nquantity q7 = pos2 - pos1;\n// quantity&lt;isq::displacement[m], vector&gt; displacement = q7;  // Compile-time error\n// quantity displacement = isq::displacement(q7);             // Compile-time error\nquantity displacement = quantity_cast&lt;isq::displacement&gt;(q7);\n</code></pre> <p>Again, the above might be surprising and considered a usability issue. Let me describe why the code behaves like that.</p> <p>As of today, the result of an addition or subtraction of two quantities is their common quantity type. When subtracting two position vectors we end up with a position vector. Looking at the above hierarchy tree, we can easily see that position vector and displacement are on different branches. This prevents implicit and explicit conversions between those. The only one allowed to force such a conversion is an explicit cast.</p> <p>If we think more about it, this makes a lot of sense. Position vector is not a special case of displacement or vice versa. Those should not be convertible. We do not want the code to compile when we accidentally pass a position vector to the numerator of the equation for velocity, right? What does calculating the velocity for a position vector mean?</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#affine-spaces-within-quantity-trees","title":"Affine spaces within quantity trees","text":"<p>Also, let's look at the type of variable <code>q7</code>. We know that subtracting two quantities of the same type results in a quantity of the same type. This is also the case when we do it for position vectors. We will see the same resulting type when we add two position vectors as well. But wait... What does it actually mean to add two position vectors?</p> <p>Looks familiar? Yes, we can clearly see that we are dealing with yet another case of the affine space. This time, it is hidden within the quantities hierarchy tree. This also means that adding a position vector and a displacement should result in a position vector. Let's try to do it:</p> <pre><code>quantity q8 = pos1 + displacement;                       // Often a compile-time error\n</code></pre> <p>Unfortunately, this often fails on the very first step, even before assigning the result to the position vector quantity. The reason for this is that in the hierarchy tree, the first common node for position vector and displacement is distance, which is a scalar quantity. Trying to use a vector representation type for a scalar quantity yields an error as a result of already existing checks described in the Representation types chapter.</p> <p>However, the code will compile if we use the same representation type for scalar and vector quantity (e.g., <code>int</code> or <code>double</code> may be used as a vector representation type for a well-known axis). In this case, we will end up with:</p> <pre><code>// quantity&lt;isq::position_vector[m], vector&gt; pos3 = q8;       // Compile-time error\nquantity&lt;isq::position_vector[m], vector&gt; pos3 = isq::position_vector(q8);\n</code></pre> <p>We need to convert a distance explicitly to a position vector quantity to move \"down\" over a branch in a hierarchy tree.</p> <p>It is important to note that there are more quantities that may behave the same. For example, altitude/height and time/duration may also form similar affine spaces. More similar examples can be found in other hierarchy trees.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#extending-arithmetic-on-quantity-specifications","title":"Extending arithmetic on quantity specifications","text":"<p>mp-units provided support for multiplication and division of <code>quantity_spec</code> from the beginning. It was needed to obtain derived quantities. Adding support for quantity characters also added special operations (e.g., <code>magnitude()</code>, <code>scalar_product()</code>, etc.) on <code>quantity_spec</code> arguments. If we want to support such affine space abstractions, we must also add support for addition and subtraction, which may yield different results.</p> <p>For example:</p> <pre><code>static_assert(isq::length + isq::length == isq::length);\nstatic_assert(isq::height + isq::width == isq::length);\nstatic_assert(isq::altitude + isq::height == isq::altitude);\nstatic_assert(isq::height + isq::altitude == isq::altitude);\n\nstatic_assert(isq::length - isq::length == isq::length);\nstatic_assert(isq::height - isq::width == isq::length);\nstatic_assert(isq::altitude - isq::height == isq::altitude);\nstatic_assert(isq::altitude - isq::altitude == isq::height);\n</code></pre> <p>Also, some operations should not compile. For example:</p> <pre><code>// auto qs1 = isq::altitude + isq::altitude;  // Compile-time error\n// auto qs2 = isq::height - isq::altitude;    // Compile-time error\n</code></pre>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#defining-affine-space-abstractions-in-a-quantity_spec","title":"Defining affine space abstractions in a <code>quantity_spec</code>","text":"<p>We can add support for the above by adding <code>point_for&lt;QuantitySpec&gt;</code> attribute to the <code>quantity_spec</code> definition:</p> <pre><code>inline constexpr struct height final : quantity_spec&lt;length&gt; {} height;\ninline constexpr struct altitude final : quantity_spec&lt;length, point_for&lt;height&gt;&gt; {} altitude;\ninline constexpr struct displacement final : quantity_spec&lt;distance, quantity_character::vector&gt; {} displacement;\ninline constexpr struct position_vector final : quantity_spec&lt;radial_distance, point_for&lt;displacement&gt;, quantity_character::vector&gt; {} position_vector;\n</code></pre> <p>Thanks to the above, the library always knows a \"delta\" quantity for a \"point\" type. I've implemented this logic, got great results, and thought I was done. But next, I realized that I need to update a few more things.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#adding-support-to-quantity_point","title":"Adding support to <code>quantity_point</code>","text":"<p><code>quantity_point</code> is intended to model \"point\" quantities and return \"delta\" quantities on subtraction or by calling <code>.quantity_from...()</code> family of member functions. This is possible and can be done. I've finished most of the implementation already. However, two interesting questions arise:</p> <ol> <li>Should <code>isq::altitude</code> be reserved only for <code>quantity_point</code> and not available for    \"regular\"\u00a0<code>quantity</code> types?</li> <li>Should <code>isq::height</code> apply only to <code>quantity</code>?</li> </ol> <p>I think that question #1 makes a lot of sense. If we realize that <code>quantity</code> always represents \"delta\" quantities, what would a <code>quantity</code> of <code>isq::altitude</code> mean? However, forcing the usage of <code>quantity_point</code> might be too strict here. Some users are not familiar or comfortable with this abstraction. Also, we can't multiply or divide quantity points.</p> <p>Question</p> <p>Does anyone know a derived quantity built with altitude or time instant? If so, please let me know in the comments, as limiting \"point\" <code>quantity_spec</code> to <code>quantity_point</code> would prevent forming such derived quantities.</p> <p>Question #2 is also interesting. However, in this case, I think that the answer should be \"NO\". I can imagine a series of height measurements. Every physical measurement can be modeled as a <code>quantity_point</code>, so a <code>quantity_point</code> of height might make sense.</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#opening-can-of-worms","title":"Opening can of worms","text":"<p>So far, so good. I thought I was done here and could continue my work on symbolic expressions for vector and complex quantities. However, I've realized that I've opened a can of worms. What about the convertibility of <code>quantity_spec</code>? How should <code>common_quantity_spec()</code> behave?</p> <p>Let's start with conversions. It might seem easy. <code>isq::altitude</code> and <code>isq::height</code> should not be convertible to each other. But more questions arise:</p> <ol> <li>Should it be possible to <code>quantity_cast</code> from <code>isq::altitude</code> to <code>isq::height</code> or vice versa?</li> <li>Should <code>isq::height</code> be convertible to <code>isq::length</code>?</li> <li>Should <code>isq::length</code> be explicitly convertible to <code>isq::height</code>?</li> <li>Should <code>isq::altitude</code> be convertible to <code>isq::length</code>?</li> <li>Should <code>isq::length</code> be explicitly convertible to <code>isq::altitude</code>?</li> </ol> <p>The need for #1 will always probably mean an error in program logic, so <code>quantity_cast</code> could not work for such entities. This would be an exception to our conversion rules that always allow casting between branches of one tree.</p> <p>The answer to questions #2 and #3 is \"YES\".</p> <p>We might be tempted to say \"NO\" to questions #4 and #5 as <code>isq::altitude</code> is defined as \"point\" while <code>isq::length</code> is not specified as such. However, I've just realized that it is not the case.</p> <p>The proper answer to questions #4 and #5 is \"It depends\". If we are dealing with a <code>quantity_point</code> then converting from <code>isq::altitude</code> to <code>isq::length</code> or the other way around should work. However, it would probably be a bad idea for a <code>quantity</code> type.</p> <p>It turns out that <code>common_quantity_spec()</code> is similar. It is probably safe to state that it should not compile for <code>isq::altitude</code> and <code>isq::height</code> arguments. This means that we will not be able to compare such quantities as well. As those are different abstractions, preventing that might be an excellent idea.</p> <p>Again, it gets tricky if we consider passing <code>isq::length</code> and <code>isq::altitude</code> to it. For <code>quantity_point</code> it probably should work fine and fail to compile for <code>quantity</code>.</p> <p>The above means that to determine the conversion rules and common quantity specifications, we need to know the context in which the <code>quantity_spec</code> is being used. This sucks!</p>"},{"location":"blog/2025/01/15/bringing-quantity-safety-to-the-next-level/#should-we-get-rid-of-a-quantity_point","title":"Should we get rid of a <code>quantity_point</code>?","text":"<p>There are at least two ways of solving the above issue. In any case, we need to introduce a wrapper over the <code>quantity_spec</code> to denote it is being used in a \"point\" abstraction.</p> <p>A simpler solution could be implicitly amending the <code>Reference</code> provided to the <code>quantity_point</code> class template with <code>point&lt;...&gt;</code>. So, for example, we would have the following members in <code>quantity_point&lt;isq::altitude[m]&gt;</code>:</p> <ul> <li><code>qp::quantity_spec == point&lt;isq::altitude&gt;</code>,</li> <li><code>qp::reference</code> of a type <code>reference&lt;point&lt;isq::altitude&gt;, si::metre&gt;</code>.</li> </ul> <p>This should work but might be a bit confusing as members of the class template would not exactly contain the types of template parameters.</p> <p>A better solution might be removing a dedicated <code>quantity_point</code> abstraction and providing both functionalities through the <code>quantity</code> class template. I still haven't figured out the best syntax. Please let me know if you have good ideas in the comments below. Here are some rough ideas:</p> Before After <code>quantity_spec</code> <code>quantity&lt;si::metre&gt;</code> <code>quantity&lt;si::metre&gt;</code> <code>kind_of&lt;isq::length&gt;</code> <code>quantity_point&lt;si::metre&gt;</code> <code>quantity&lt;point&lt;si::metre&gt;&gt;</code> <code>point&lt;kind_of&lt;isq::length&gt;&gt;</code> <code>quantity_point&lt;si::metre, mean_sea_level&gt;</code> <code>quantity&lt;point&lt;si::metre, mean_sea_level&gt;&gt;</code> <code>point&lt;kind_of&lt;isq::length&gt;&gt;</code> <code>quantity&lt;isq::height[m]&gt;</code> <code>quantity&lt;isq::height[m]&gt;</code> <code>isq::height</code> <code>quantity_point&lt;isq::height[m]&gt;</code> <code>quantity&lt;point&lt;isq::height[m]&gt;&gt;</code> <code>point&lt;isq::height&gt;</code> <code>quantity_point&lt;isq::altitude[m]&gt;</code> <code>quantity&lt;point&lt;isq::altitude[m]&gt;&gt;</code> <code>point&lt;isq::altitude&gt;</code> <code>quantity_point&lt;isq::altitude[m], mean_sea_level&gt;</code> <code>quantity&lt;point&lt;isq::altitude[m], mean_sea_level&gt;&gt;</code> <code>point&lt;isq::altitude&gt;</code> <p>I am still undecided about whether we should pursue this option, which would involve a huge design change in the library. It may even require bumping the library major version to V3.</p> <p>On the bright side, it would limit the number of abstractions in the library. It would also make the library more consistent with standards like ISO/IEC 80000, which talk about quantities and do not mention quantity points at all. This could also be useful before we start our work on the next big task - logarithmic quantities and units.</p>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/","title":"Introducing absolute quantities","text":"<p>This post introduces a new abstraction called an absolute quantity. It complements affine space abstractions (point and delta) and will most probably be a new default in the library when we release V3.</p>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#affine-space-in-a-nutshell","title":"Affine space in a nutshell","text":"<p>So far mp-units and other quantities and units libraries have been modeling two kinds of abstractions:</p> <ol> <li> <p>Points (modeled with <code>quantity_point</code> class template)</p> <ul> <li>can be interpolated,</li> <li>can be subtracted,</li> <li>can't be added,</li> <li>can't be multiplied or divided by another quantity or scalar,</li> <li>some of them could be specified as non-negative,</li> <li>specified relative to some absolute or relative point origin,</li> <li>conversion to offset units (e.g., degree Celsius) accounts for offset.</li> </ul> </li> <li> <p>Deltas (modeled with <code>quantity</code> class template)</p> <ul> <li>can be interpolated,</li> <li>can be subtracted,</li> <li>can be added,</li> <li>can be multiplied and divided by another quantity and scalar,</li> <li>may be negative as there is always a chance that we will subtract a larger value   from a smaller one,</li> <li>don't use point origins in its definition,</li> <li>conversion to offset units (e.g., degree Celsius) ignores the offset (just the conversion   factor is used).</li> </ul> </li> </ol> <p>Info</p> <p>More information on this subject can be found in the Affine Space chapter.</p>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#issues","title":"Issues","text":"<p>A current affine space implementation works well for many essential use cases. However, it also produces some issues.</p> <ol> <li>We can't print quantity points as, at least for today, we do not have the means to properly    describe the user-provided origin in the text output.</li> <li>Quantity points are hard to use in physical equations to denote not-delta values.</li> </ol> <p>To make both of the above work, a user needs to convert the quantity point to quantity with either <code>qp.quantity_from_zero()</code> or <code>qp.quantity_from(some_origin)</code> member functions.</p> <pre><code>quantity_point m1(2 * kg);\nquantity_point m2(3 * kg);\nquantity_point m = m1 + m2.quantity_from_zero();\nquantity d_v = 30 * km / h;\nquantity E_k = m.quantity_from_zero() * pow&lt;2&gt;(d_v) / 2;\n\nstd::cout &lt;&lt; \"Mass: \" &lt;&lt; m.quantity_from_zero() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Velocity: \" &lt;&lt; d_v &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Kinetic energy: \" &lt;&lt; E_k.in&lt;double&gt;(J) &lt;&lt; \"\\n\";\n</code></pre> <p>This is quite inconvenient and is a common reason for avoiding quantity point abstraction in many equations in source code where it would be a good fit otherwise.</p>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#absolute-quantities","title":"Absolute quantities","text":"<p>Despite the above drawbacks, affine space points are necessary to model some abstractions (e.g., temperatures in degrees Celsius, tared mass measurements, altitudes above some reference point, etc.) and do it really well. Constrained affine space arithmetic (e.g., preventing accidental addition of points) also improves the safety of our programs. This is why it is a valuable abstraction and should be used more even often than now.</p> <p>To improve the user experience and open the doors for new features in the future, we are considering adding a third abstraction for absolute quantities. In terms of properties, an absolute quantity will lie between points and deltas.</p> Feature Point Absolute Delta Interpolation Subtraction Addition Multiply/Divide May be non-negative Relative to origin Absolute &amp; relative Measured against nothing/void Can use offset units Conversion to offset units With offset No offset Text output <p>As we can see above, absolute quantities have only two limitations, and both are connected to the offset units' usage. They can't use those because they must remain absolute instead of being measured relative to some custom origin.</p> <p>Absolute quantities could be considered delta quantities that represent a whole -- the entire entity being measured. This is why we can represent a system mass by adding absolute masses of all system elements or a system energy by adding absolute temperatures of all the system elements.</p> <p>As those are more related to deltas than points, it is impossible to specify their origin points. This also allows us to print them, as we do not need any special text to describe their origin as they are always measured against nothing/void.</p>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#interfaces-refactoring","title":"Interfaces refactoring","text":"<p>As I mentioned in my previous post, we are seriously considering removing <code>quantity_point</code> class template and replacing it with a <code>quantity_spec</code> point wrapper. For example, <code>quantity_point&lt;isq::altitude[m]&gt;</code> will become <code>quantity&lt;point&lt;isq::altitude[m]&gt;&gt;</code>.</p> <p>I initially planned <code>quantity&lt;isq::mass&gt;</code> to be the same as <code>quantity&lt;delta&lt;isq::mass&gt;&gt;</code>, but it turns out that deltas probably should not be the default. It is consistent with how we write physical expressions on paper, right? Delta symbol (\u2206) is always \"verbose\" in physical equations, it would be nice for the C++ code to do the same. So, deltas will always need to be explicit.</p> <p>And this brings us to absolute quantities. They should actually be the default we are looking for. This is what we write as quantities in most of the physical equations. This is why we will not need any specifier to denote them.</p> <p>For example:</p> <pre><code>inline constexpr struct tare final : relative_point_origin&lt;quantity_point{2 * kg}&gt; {} tare;\n\nquantity&lt;point&lt;isq::mass&gt;&gt;       m1(10 * kg);         // point quantity with an implicit point origin\nquantity&lt;point&lt;isq::mass, tare&gt;&gt; m2 = tare + 8 * kg;  // point quantity with an explicit relative point origin\nquantity&lt;isq::mass&gt; \u00a0 \u00a0 \u00a0 \u00a0      m3 = 15 * kg;        // absolute quantity (e.g., non-negative)\nquantity&lt;delta&lt;isq::mass&gt;&gt;       m13 = m1 - m3;       // delta quantity (e.g., may be negative)\nquantity&lt;delta&lt;isq::mass&gt;&gt;       m23 = m2 - m3;       // delta quantity (e.g., may be negative)\n</code></pre> <p>With the above, the initial example may be refactored to:</p> <pre><code>quantity m1 = 2 * kg;\nquantity m2 = 3 * kg;\nquantity m = m1 + m2;\nquantity d_v = delta&lt;km / h&gt;(30);\nquantity E_k = m * pow&lt;2&gt;(d_v) / 2;\n\nstd::cout &lt;&lt; \"Mass: \" &lt;&lt; m &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Velocity: \" &lt;&lt; d_v &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Kinetic energy: \" &lt;&lt; E_k.in&lt;double&gt;(J) &lt;&lt; \"\\n\";\n</code></pre>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#arithmetic","title":"Arithmetic","text":"<p>Affine space arithmetic is well-defined. However, we are adding a new type to the library that lands between points and deltas. This is why we must agree on the arithmetic for all possible combinations.</p>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#addition","title":"Addition","text":"<p>Absolute quantities are deltas against nothing so adding them to a point yields another point.</p> <p>Adding a delta to them yields a delta, as a delta may represent only a part of something and a whole, and a part is not a whole. The delta may also be negative and greater than the absolute quantity, which may yield a negative value. This is why delta is a good result here.</p> <p>Only adding whole non-negative entities of the system yields a system being expressed as an entire non-negative entity. This is why adding absolute quantities results in an absolute quantity.</p> Lhs \\ Rhs Point Absolute Delta Point Point Point Absolute Point Absolute Delta Delta Point Delta Delta"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#subtraction","title":"Subtraction","text":"<p>Similarly, during subtraction, regular affine space arithmetics for deltas apply. Subtracting an absolute quantity from a point yields a point, and trying to do the opposite does not make physical sense.</p> <p>Subtracting two non-negative absolute quantities may yield a negative value if we subtract a larger one from the smaller one, so the result should be a delta. A similar result may be obtained by subtracting a delta from absolute quantity or absolute quantity from a delta.</p> Lhs \\ Rhs Point Absolute Delta Point Delta Point Point Absolute Delta Delta Delta Delta Delta <p>Info</p> <p>Based on the above assumptions, one of the lines of the below code can't compile:</p> <pre><code>quantity temp1 = 270 * K;\nquantity temp2 = point&lt;K&gt;(300);\nquantity temp3 = temp2 - temp1;             // Point\n// quantity temp4 = temp1 - temp2;          // Compile-time error\nquantity temp5 = temp1 - temp2.absolute();  // Delta\n</code></pre>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#motivating-example","title":"Motivating example","text":"<p>Let's consider a room with a table and two glasses filled with fluid on top of it. Let's also assume that we want to stack one on top of the other and treat them as a system we observe.</p> <p></p> <pre><code>// absolute quantities\nquantity&lt;isq::height[cm]&gt; glass1_height = 20 * cm;\nquantity&lt;isq::height[cm]&gt; glass2_height = 15 * cm;\n\n// delta quantities\nquantity&lt;delta&lt;isq::height&gt;[cm]&gt; fluid_level = 16 * cm;\n\n// point quantities\ninline constexpr struct floor_level final : absolute_point_origin&lt;isq::height&gt; floor_level;\nquantity&lt;point&lt;isq::height[cm], floor_level&gt;&gt; table_top = floor_level + 1 * m;\n\n// absolute results\nquantity system_height = glass1_height + glass2_height;\n\n// delta results\nquantity empty_height_res = glass1_height - fluid_level;\nquantity glass2_height_res = system_height - glass1_height;    // could result in an absolute quantity\nassert(glass2_height_res == glass2_height);\nquantity height_diff_res = glass2_height - glass1_height;      // but this one should definitely return delta\n\n// point results\nquantity&lt;point&lt;isq::height[cm], floor_level&gt;&gt; glass1_top = table_top + glass1_height;\nquantity point1 = glass1_top - glass1_height;\nassert(point1 == table_top);\n// quantity point2 = glass1_height - glass1_top; \u00a0 \u00a0          \u00a0// no sense - does not compile\n</code></pre>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#what-about-time","title":"What about time?","text":"<p>Everything looks promising and nice for now. But let's look closer into the quantity of time. There is no way to measure its absolute value as we don't even know where (when?) the time axis starts... Only time points and time deltas (durations) make sense.</p> <p>The above raises a few questions:</p> <ol> <li>Does it mean that <code>quantity&lt;si::seconds&gt;</code> or <code>quantity&lt;isq::time[s]&gt;</code> should not compile?</li> <li>Should we require the user to always state <code>quantity&lt;delta&lt;si::seconds&gt;&gt;</code> or \u00a0 \u00a0<code>quantity&lt;delta&lt;isq::time[s]&gt;&gt;</code>? This would be consistent with physical equations but more    verbose in the source code.</li> <li>Should the syntax <code>40 * s</code> be disallowed or should it implicitly create<code>quantity&lt;delta&lt;si::seconds&gt;&gt;</code>    instead of <code>quantity&lt;si::seconds&gt;</code>?</li> <li>A somehow similar case might be the length quantity as there is no one well-established    zero origin that serves for all length measurements. However, asking the users always    to provide a <code>delta</code> specifier for length would probably be an overkill.</li> </ol> <p>As you can see, I do not yet have good answers to the above problems yet. Please feel welcome to share some feedback on this.</p>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#new-opportunities","title":"New opportunities","text":"<p>The new syntax simplifies API as one <code>quantity</code> class template will now serve all quantity variations (possibly even more in the future). It also allows us to model quantities that were impossible to express before without some workarounds.</p> <p>For example, we can now correctly calculate Carnot engine efficiency with any of the following:</p> <pre><code>quantity temp_cold = 300. * K;\nquantity temp_hot = 500. * K;\nquantity carnot_eff_1 = 1. - temp_cold / temp_hot;\nquantity carnot_eff_2 = (temp_hot - temp_cold) / temp_hot;\n</code></pre> <p>In the above code, we can easily create absolute or delta values of temperatures and do arithmetics on them. Previously, we had to create deltas from both points artificially with:</p> <pre><code>quantity temp_cold = point&lt;K&gt;(300.);\nquantity temp_hot = point&lt;K&gt;(500.);\nquantity carnot_eff_1 = 1. - temp_cold.quantity_from_zero() / temp_hot.quantity_from_zero();\nquantity carnot_eff_2 = (temp_hot - temp_cold) / temp_hot.quantity_from_zero();\n</code></pre> <p>It worked but was far from being physically pure and pretty.</p>"},{"location":"blog/2025/06/16/introducing-absolute-quantities/#summary","title":"Summary","text":"<p>We believe that adding absolute quantities will be a significant improvement in the library that will allow us to model physical equations in a terser, more correct, easier to write, understand, and maintain way.</p> <p>We plan to deliver the features mentioned in this post as a part of mp-units V3.</p> <p>Please share your feedback.</p>"},{"location":"blog/2024/10/07/international-system-of-quantities-isq-part-1---introduction/","title":"International System of Quantities (ISQ): Part 1 - Introduction","text":"<p>This post starts a series of articles about the International System of Quantities (ISQ). In this series, we will describe:</p> <ul> <li>What is ISQ?</li> <li>Which engineering problems does ISQ help to solve and how?</li> <li>How to model and implement it in the programming language?</li> <li>What is missing in the ISQ, and why is that a problem?</li> </ul>"},{"location":"blog/2024/10/07/international-system-of-quantities-isq-part-1---introduction/#articles-from-this-series","title":"Articles from this series","text":"<ul> <li>Part 1 - Introduction</li> <li>Part 2 - Problems when ISQ is not used</li> <li>Part 3 - Modeling ISQ</li> <li>Part 4 - Implementing ISQ</li> <li>Part 5 - Benefits</li> <li>Part 6 - Challenges</li> </ul>"},{"location":"blog/2024/10/07/international-system-of-quantities-isq-part-1---introduction/#terms-and-definitions","title":"Terms and Definitions","text":"<p>From our experience, many people, including experts in the domain, often tend to name things differently, or sometimes they use the same term while having a different meaning in mind. This is why it is essential to stick to one well-defined glossary of terms for metrology.</p> <p>The mp-units project consistently uses the official metrology vocabulary defined by the ISO and BIPM:</p> <ul> <li>International Organization for Standardization (ISO),</li> <li>International Bureau of Weights and Measures (BIPM).</li> </ul> <p>The above are identical and contain the same set of definitions. We provide both to point out that the biggest institutions in standardizing metrology agree on the same vocabulary.</p>"},{"location":"blog/2024/10/07/international-system-of-quantities-isq-part-1---introduction/#systems-of-quantities-vs-systems-of-units","title":"Systems of Quantities vs Systems of Units","text":"<p>Here are the official definitions from our vocabulary:</p> <p>System of quantities</p> <p>A system of quantities is a set of quantities together with a set of noncontradictory equations relating those quantities.</p> <p>System of units</p> <p>A system of units is a set of base units and derived units, together with their multiples and submultiples, defined in accordance with given rules, for a given system of quantities.</p> <p>From the definition above, we can find out that the systems of quantities and units form a hierarchy:</p> <pre><code>flowchart TD\n    system_of_quantities[\"System of Quantities\"]\n    system_of_quantities --- system_of_units1[System of Units #1]\n    system_of_quantities --- system_of_units2[System of Units #2]\n    system_of_quantities --- system_of_units3[System of Units #3]</code></pre> <p>System of quantities defines quantities commonly used in engineering (e.g., length, time, mass, speed, energy, power, etc.) and relations between them. It does not assign any specific units to those quantities, though.</p> <p>Systems of units are the ones that assign units of measurement to quantities from a specific system of quantities they chose to model. Different systems of units are free to chose whatever they find suitable for specific quantities and do not have to be consistent/compatible with other such systems. For example:</p> <ul> <li>SI decided to measure length in meters, mass in kilograms, and time in seconds,</li> <li>CGS decided to measure length in centimeters, mass in grams, and time in seconds.</li> </ul> <p>Both systems of units above agree on the unit of time, but chose different units for other quantities. In the above example, SI chose a non-prefixed unit of metre for a base quantity of length while CGS chose a scaled centimetre. On the other hand, SI chose a scaled kilogram over the gram used in the CGS. Those decisions also result in a need for different coherent units for derived quantities. For example:</p> Quantity SI CGS length metre (m) centimetre (cm) mass kilogram (kg) gram (g) time second (s) second (s) force newton (N) dyne energy joule (J) erg pressure pascal (Pa) barye <p>Often, there is no way to state which one is correct or which one is wrong. Each system of units has the freedom to choose whichever unit suits its engineering requirements and constraints the best for a specific quantity.</p>"},{"location":"blog/2024/10/07/international-system-of-quantities-isq-part-1---introduction/#isq-vs-si","title":"ISQ vs SI","text":"<p>Some of the systems of quantities and units have been used more over the years and have become more popular than others. Here are the official descriptions of the most popular systems used in engineering today:</p> <p>International System of Quantities (ISQ)</p> <p>The International System of Quantities (ISQ) is a system of quantities based on the seven base quantities: length, mass, time, electric current, thermodynamic temperature, amount of substance, and luminous intensity.</p> <p>International System of Units (SI)</p> <p>The International System of Units (SI) is a system of units, based on the International System of Quantities, their names and symbols, including a series of prefixes and their names and symbols, together with rules for their use, adopted by the General Conference on Weights and Measures (CGPM).</p>"},{"location":"blog/2024/10/07/international-system-of-quantities-isq-part-1---introduction/#the-international-system-of-quantities-isq-standardization","title":"The International System of Quantities (ISQ) standardization","text":"<p>The set of quantities constituting the ISQ is defined in the series of ISO 80000 and IEC 80000 standards under the general title \"Quantities and units\".</p> <p>ISO 80000:</p> <ul> <li>Part 1: General</li> <li>Part 2: Mathematical signs and symbols to be used in the natural sciences and technology</li> <li>Part 3: Space and time</li> <li>Part 4: Mechanics</li> <li>Part 5: Thermodynamics</li> <li>Part 7: Light</li> <li>Part 8: Acoustics</li> <li>Part 9: Physical chemistry and molecular physics</li> <li>Part 10: Atomic and nuclear physics</li> <li>Part 11: Characteristic numbers</li> <li>Part 12: Condensed matter physics</li> </ul> <p>IEC 80000:</p> <ul> <li>Part 6: Electromagnetism</li> <li>Part 13: Information science and technology</li> <li>Part 15: Logarithmic and related quantities, and their units</li> <li>Part 16: Printing and writing rules</li> <li>Part 17: Time dependency</li> </ul>"},{"location":"blog/2024/10/07/international-system-of-quantities-isq-part-1---introduction/#to-be-continued","title":"To be continued...","text":"<p>In the next part of this series, we will describe typical issues with libraries that do not model systems of quantities.</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/","title":"International System of Quantities (ISQ): Part 2 - Problems when ISQ is not used","text":"<p>This article is the next one in our series about the ISQ. After introducing the basic terms and systems, this article will talk about the issues we face when we base the quantities and units library on just units or dimensions.</p> <p>Note</p> <p>The issues described in this article do not apply to the mp-units library. Its interfaces, even if when we decide only to use simple quantities that only use units, those are still backed up by quantity kinds under the framework's hood.</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#articles-from-this-series","title":"Articles from this series","text":"<ul> <li>Part 1 - Introduction</li> <li>Part 2 - Problems when ISQ is not used</li> <li>Part 3 - Modeling ISQ</li> <li>Part 4 - Implementing ISQ</li> <li>Part 5 - Benefits</li> <li>Part 6 - Challenges</li> </ul>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#limitations-of-units-only-solutions","title":"Limitations of units-only solutions","text":"<p>Units-only is not a good design for a quantities and units library. It works to some extent, but plenty of use cases can't be addressed, and for those that somehow work, we miss important safety improvements provided by additional abstractions in this article series.</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#no-way-to-specify-a-quantity-type-in-generic-interfaces","title":"No way to specify a quantity type in generic interfaces","text":"<p>A common requirement in the domain is to write unit-agnostic generic interfaces. For example, let's try to implement a generic <code>avg_speed</code> function template that takes a quantity of any unit and produces the result. If we call it with distance in <code>km</code> and time in <code>h</code>, we will get <code>km/h</code> as a result, but if we call it with <code>mi</code> and <code>h</code>, we expect <code>mi/h</code> to be returned.</p> <pre><code>template&lt;Unit auto U1, typename Rep1, Unit auto U2, typename Rep2&gt;\nauto avg_speed(quantity&lt;U1, Rep1&gt; distance, quantity&lt;U2, Rep2&gt; time)\n{\n  return distance / time;\n}\n\nquantity speed = avg_speed(120 * km, 2 * h);\n</code></pre> <p>This function works but does not provide any type safety to the users. The function arguments can be easily reordered on the call site. Also, we do not get any information about the return type of the function or any safety measures to ensure that the function logic actually returns a quantity of speed.</p> <p>To improve safety, with a units-only library, we have to write the function in the following way:</p> <pre><code>template&lt;typename Rep1, typename Rep2&gt;\nquantity&lt;si::metre / si::second, decltype(Rep1{} / Rep2{})&gt; avg_speed(quantity&lt;si::metre, Rep1&gt; distance,\n                                                                      quantity&lt;si::second, Rep2&gt; time)\n{\n  return distance / time;\n}\n\navg_speed(120 * km, 2 * h).in(km / h);\n</code></pre> <p>Despite being safer, the above code decreased the performance because we always pay for the conversion at the function's input and output.</p> <p>Moreover, in a good library, the above code should not compile. The reason for this is that even though the conversion from <code>km</code> to <code>m</code> and from <code>h</code> to <code>s</code> is considered value-preserving, it is not true in the opposite direction. When we try to convert the result stored in an integral type from the unit of <code>m/s</code> to <code>km/h</code>, we will inevitably lose some data.</p> <p>We could try to provide concepts like <code>ScaledUnitOf&lt;si::metre&gt;</code> that would take a set of units while trying to constrain them somehow, but it leads to even more problems with the unit definitions. For example, are <code>Hz</code> and <code>Bq</code> just scaled versions of <code>1/s</code>? If we constrain the interface to just prefixed units, then litre and a cubic metre or kilometre and mile will be incompatible. What about radian and steradian or a litre per 100 kilometre (popular unit of a fuel consumption) and a squared metre? Should those be compatible?</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#disjoint-units-of-the-same-quantity-type-do-not-work","title":"Disjoint units of the same quantity type do not work","text":"<p>Sometimes, we need to define several units describing the same quantity but which should not convert to each other in the library's framework. A typical example here is currency. A user may want to define EURO and USD as units of currency, so both of them can be used for such quantities. However, it is impossible to predefine one fixed conversion factor for those, as a currency exchange rate varies over time, and the library's framework can't provide such an information as an input to the built-in conversion function. User's application may have more information in this domain and handle such a conversion at runtime with custom logic (e.g., using an additional time point function argument). If we would like to model that in a unit-only solution, how can we specify that EURO and USD are units of quantities of currency, but are not convertible to each other?</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#dimensions-to-the-rescue","title":"Dimensions to the rescue?","text":"<p>To resolve the above issues, most of the libraries on the market introduce dimension abstraction. Thanks to that, we could solve the first issue of the previous chapter with:</p> <pre><code>QuantityOf&lt;dim_speed&gt; auto avg_speed(QuantityOf&lt;dim_length&gt; auto distance,\n                                     QuantityOf&lt;dim_time&gt; auto time)\n{\n  return distance / time;\n}\n</code></pre> <p>and the second one by specifying that both EURO and USD are units of <code>dim_currency</code>. This is a significant improvement but still has some issues.</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#limitations-of-dimensions","title":"Limitations of dimensions","text":"<p>Let's first look at the above solution again. A domain expert seeing this code will immediately say there is no such thing as a speed dimension. The ISQ specifies only 7 dimensions with unique symbols assigned, and the dimensions of all the ISQ quantities are created as a vector product of those. For example, a quantity of speed has a dimension of \\(L^1T^{-1}\\). So, to be physically correct, the above code should be rewritten as:</p> <pre><code>QuantityOf&lt;dim_length / dim_time&gt; auto avg_speed(QuantityOf&lt;dim_length&gt; auto distance,\n                                                 QuantityOf&lt;dim_time&gt; auto time)\n{\n  return distance / time;\n}\n</code></pre> <p>Most of the libraries on the market ignore this fact and try to model distinct quantities through their dimensions, giving a false sense of safety. A dimension is not enough to describe a quantity. This has been known for a long time now. The \"Measurement Data (Archive Report)\" report from 1996 says explicitly:</p> <p>Measurement Data (Archive Report)</p> <p>Dimensional analysis does not adequately model the semantics of measurement data.</p> <p>In the following chapters, we will see a few use cases that can't be solved with an approach that only relies on units or dimensions.</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#si-units-of-quantities-of-the-same-dimension-but-different-kinds","title":"SI units of quantities of the same dimension but different kinds","text":"<p>The SI provides several units for distinct quantities of the same dimension but different kinds. For example:</p> <ul> <li>hertz (Hz) is a unit of frequency and becquerel (Bq) is a unit of activity.   Both are defined as \\(s^{-1}\\), and have the same dimension of \\(T^{-1}\\).</li> <li>gray (Gy) is a unit of absorbed dose and sievert (Sv) is a unit of dose equivalent.   Both are defined as \\(m^2 s^{-2}\\), and have the same dimension of \\(L^2T^{-2}\\)</li> <li>radian (rad) is a unit of plane angle defined as \\(m/m\\), and   steradian (sr) is a unit of solid angle defined as \\(m^2/m^2\\).   Both are quantities of dimension one, which also has its own units like one (1) and percent (%).</li> </ul> <p>There are many more similar examples in the ISO/IEC 80000 series. For example, storage capacity quantity can be measured in units of one, bit, octet, and byte.</p> <p>The above conflicts can't be solved with dimensions, and they yield many safety issues. For example, we can ask ourselves what should be the result of the following:</p> <ol> <li><code>quantity q = 1 * Hz + 1 * Bq;</code></li> <li><code>quantity&lt;Gy&gt; q = 42 * Sv;</code></li> <li><code>bool b = (1 * rad + 1 * bit) == 2 * sr;</code></li> </ol> <p>None of the above code should compile, but most of the libraries on the market happily accept it and provide meaningless results. Some of them decide not to define one or more of the above units at all to avoid potential safety issues. For example, the Au library does not define Sv to avoid mixing it up with Gy.</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#derived-quantities-of-the-same-dimension-but-different-kinds","title":"Derived quantities of the same dimension but different kinds","text":"<p>Even if some quantities do not have a specially assigned unit, they may still have a totally different physical meaning even if they share the same dimension:</p> <ul> <li>work vs. moment of force both of the same dimension \\(L^2MT^{-2}\\),</li> <li>fuel consumption expressed in \\(\\frac{l}{100\\;km}\\) vs. area expressed in \\(m^2\\) both of the same   dimension \\(L^2\\).</li> </ul> <p>Again, we don't want to accidentally mix those.</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#various-quantities-of-the-same-dimension-and-kinds","title":"Various quantities of the same dimension and kinds","text":"<p>Even if we somehow address all the above, there are plenty of use cases that still can't be safely implemented with such abstractions.</p> <p>Let's consider that we want to implement a freight transport application to position cargo in the container. In majority of the products on the market we will end up with something like:</p> <pre><code>class Box {\n  length length_;\n  length width_;\n  length height_;\npublic:\n  Box(length l, length w, length h): length_(l), width_(w), height_(h) {}\n  area floor() const { return length_ * width_; }\n  // ...\n};\n</code></pre> <pre><code>Box my_box(2 * m, 3 * m, 1 * m);\n</code></pre> <p>Such interfaces are not much safer than just using plain fundamental types (e.g., <code>double</code>). One of the main reasons of using a quantities and units library was to introduce strong-type interfaces to prevent such issues. In this scenario, we need to be able to discriminate between length, width, and height of the package.</p> <p>A similar but also really important use case is in aviation. The current altitude is a totally different quantity than the distance to the destination. The same is true for forward speed and sink rate. We do not want to accidentally mix those.</p> <p>When we deal with energy, we should be able to implicitly construct it from a proper product of any mass, length, and time. However, when we want to calculate gravitational potential energy, we may not want it to be implicitly initialized from any expression of matching dimensions. Such an implicit construction should be allowed only if we multiply a mass with acceleration of free fall and height. All other conversions should have an explicit annotation to make it clear that something potentially unsafe is being done in the code. Also, we should not be able to assign a potential energy to a quantity of kinetic energy. However, both of them (possibly accumulated with each other) should be convertible to a mechanical energy quantity.</p> <pre><code>mass m = 1 * kg;\nlength l = 1 * m;\ntime t = 1 * s;\nacceleration_of_free_fall g = 9.81 * m / s2;\nheight h = 1 * m;\nspeed v = 1 * m / s;\nenergy e = m * pow&lt;2&gt;(l) / pow&lt;2&gt;(t);                     // OK\npotential_energy ep1 = e;                                 // should not compile\npotential_energy ep2 = static_cast&lt;potential_energy&gt;(e);  // OK\npotential_energy ep3 = m * g * h;                         // OK\nkinetic_energy ek1 = m * pow&lt;2&gt;(v) / 2;                   // OK\nkinetic_energy ek2 = ep3 + ek1;                           // should not compile\nmechanical_energy me = ep3 + ek1;                         // OK\n</code></pre> <p>Yet another example comes from the audio industry. In the audio software, we want to treat specific counts (e.g., beats, samples) as separate quantities. We could assign dedicated base dimensions to them. However, if we divide them by duration, we should obtain a quantity convertible to frequency and even be able to express the result in a unit of <code>Hz</code>. With the dedicated dimensions approach, this wouldn't work as the dimension of frequency is just \\(T^{-1}\\), which would not match the results of our dimensional equations. This is why we can't assign dedicated dimensions to such counts.</p> <p>The last example that we want to mention here comes from finance. This time, we need to model currency volume as a special quantity of currency. currency volume can be obtained by multiplying currency by the dimensionless market quantity. Of course, both currency and currency volume should be expressed in the same units (e.g., USD).</p> <p>None of the above scenarios can be addressed with just units and dimensions. We need a better abstraction to safely implement them.</p>"},{"location":"blog/2024/10/14/international-system-of-quantities-isq-part-2---problems-when-isq-is-not-used/#to-be-continued","title":"To be continued...","text":"<p>In the next part of this series, we will introduce the main ideas behind the International System of Quantities and describe how we can model it in the programming language.</p>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/","title":"International System of Quantities (ISQ): Part 3 - Modeling ISQ","text":"<p>The physical units libraries on the market typically only focus on modeling one or more systems of units. However, as we have learned, this is not the only system kind to model. Another, and maybe even more important, is a system of quantities. The most important example here is the International System of Quantities (ISQ) defined by ISO/IEC 80000.</p> <p>This article continues our series about the International System of Quantities. This time, we will learn about the main ideas behind the ISQ and describe how it can be modelled in a programming language.</p>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#articles-from-this-series","title":"Articles from this series","text":"<ul> <li>Part 1 - Introduction</li> <li>Part 2 - Problems when ISQ is not used</li> <li>Part 3 - Modeling ISQ</li> <li>Part 4 - Implementing ISQ</li> <li>Part 5 - Benefits</li> <li>Part 6 - Challenges</li> </ul>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#dimension-is-not-enough-to-describe-a-quantity","title":"Dimension is not enough to describe a quantity","text":"<p>Most of the products on the market are aware of physical dimensions. However, a dimension is not enough to describe a quantity. Let's repeat briefly some of the problems described in more detail in the previous article. For example, let's see the following implementation:</p> <pre><code>class Box {\n  area base_;\n  length height_;\npublic:\n  Box(length l, length w, length h) : base_(l * w), height_(h) {}\n  // ...\n};\n\nBox my_box(2 * m, 3 * m, 1 * m);\n</code></pre> <p>How do you like such an interface? It turns out that in most existing strongly-typed libraries this is often the best we can do. </p> <p>Another typical question many users ask is how to deal with work and torque. Both of those have the same dimension but are distinct quantities.</p> <p>A similar issue is related to figuring out what should be the result of:</p> <pre><code>auto res = 1 * Hz + 1 * Bq + 1 * Bd;\n</code></pre> <p>where:</p> <ul> <li><code>Hz</code> (hertz) - unit of frequency,</li> <li><code>Bq</code> (becquerel) - unit of activity,</li> <li><code>Bd</code> (baud) - unit of modulation rate.</li> </ul> <p>All of those quantities have the same dimension, namely \\(\\mathsf{T}^{-1}\\), but probably it is not wise to allow adding, subtracting, or comparing them, as they describe vastly different physical properties.</p> <p>If the above example seems too abstract, let's consider Gy (gray - unit of absorbed dose) and Sv (sievert - unit of dose equivalent), or radian and steradian. All of those quantities have the same dimensions.</p> <p>Another example here is fuel consumption (fuel volume divided by distance, e.g., <code>6.7 l/100km</code>) and an area. Again, both have the same dimension \\(\\mathsf{L}^{2}\\), but probably it wouldn't be wise to allow adding, subtracting, or comparing a fuel consumption of a car and the area of a football field. Such an operation does not have any physical sense and should fail to compile.</p> <p>It turns out that the above issues can't be solved correctly without proper modeling of a system of quantities.</p>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#quantities-of-the-same-kind","title":"Quantities of the same kind","text":"<p>As it was described in the previous article, dimension is not enough to describe a quantity. We need a better abstraction to ensure the safety of our calculations. It turns out that ISO/IEC 80000 comes with the answer:</p> <p>ISO 80000-1:2009</p> <ul> <li>Quantities may be grouped together into categories of quantities that are   mutually comparable.</li> <li>Mutually comparable quantities are called quantities of the same kind.</li> <li>Two or more quantities cannot be added or subtracted unless they belong to the same category   of mutually comparable quantities.</li> <li>Quantities of the same kind within a given system of quantities have the same quantity   dimension.</li> <li>Quantities of the same dimension are not necessarily of the same kind.</li> </ul> <p>ISO Guide also explicitly states:</p> <p>ISO Guide</p> <p>Measurement units of quantities of the same quantity dimension may be designated by the same name and symbol even when the quantities are not of the same kind. For example, joule per kelvin and J/K are respectively the name and symbol of both a measurement unit of heat capacity and a measurement unit of entropy, which are generally not considered to be quantities of the same kind. However, in some cases special measurement unit names are restricted to be used with quantities of specific kind only. For example, the measurement unit \u2018second to the power minus one\u2019 (1/s) is called hertz (Hz) when used for frequencies and becquerel (Bq) when used for activities of radionuclides. As another example, the joule (J) is used as a unit of energy, but never as a unit of moment of force, i.e. the newton metre (N \u00b7 m).</p> <p>The above quotes from ISO provide answers to all the issues mentioned above and in the previous article.</p> <p>More than one quantity may be defined for the same dimension:</p> <ul> <li>quantities of different kinds (e.g., frequency, modulation rate, activity).</li> <li>quantities of the same kind (e.g., length, width, altitude, distance, radius,   wavelength, position vector).</li> </ul> <p>Two quantities can't be added, subtracted, or compared unless they belong to the same kind. As frequency, activity, and modulation rate are of different kinds, the expression provided above should not compile.</p>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#system-of-quantities-is-not-only-about-kinds","title":"System of quantities is not only about kinds","text":"<p>ISO/IEC 80000 specifies hundreds of different quantities. Plenty of various kinds are provided, and often, each kind contains more than one quantity. It turns out that such quantities form a hierarchy of quantities of the same kind.</p> <p>For example, here are all quantities of the kind length provided in the ISO 80000-3:</p> <pre><code>flowchart TD\n    length[\"&lt;b&gt;length&lt;/b&gt;&lt;br&gt;[m]\"]\n    length --- width[\"&lt;b&gt;width&lt;/b&gt; / &lt;b&gt;breadth&lt;/b&gt;\"]\n    length --- height[\"&lt;b&gt;height&lt;/b&gt; / &lt;b&gt;depth&lt;/b&gt; / &lt;b&gt;altitude&lt;/b&gt;\"]\n    width --- thickness[\"&lt;b&gt;thickness&lt;/b&gt;\"]\n    width --- diameter[\"&lt;b&gt;diameter&lt;/b&gt;\"]\n    width --- radius[\"&lt;b&gt;radius&lt;/b&gt;\"]\n    length --- path_length[\"&lt;b&gt;path_length&lt;/b&gt;\"]\n    path_length --- distance[\"&lt;b&gt;distance&lt;/b&gt;\"]\n    distance --- radial_distance[\"&lt;b&gt;radial_distance&lt;/b&gt;\"]\n    length --- wavelength[\"&lt;b&gt;wavelength&lt;/b&gt;\"]\n    length --- displacement[\"&lt;b&gt;displacement&lt;/b&gt;&lt;br&gt;{vector}\"]\n    displacement --- position_vector[\"&lt;b&gt;position_vector&lt;/b&gt;\"]\n    radius --- radius_of_curvature[\"&lt;b&gt;radius_of_curvature&lt;/b&gt;\"]</code></pre> <p>Each of the above quantities expresses some kind of length, and each can be measured with meters, which is the unit defined by the SI for quantities of length. However, each has different properties, usage, and sometimes even a different character (position vector and displacement are vector quantities).</p> <p>Forming such a hierarchy helps us define arithmetics and conversion rules for various quantities of the same kind.</p>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#converting-between-quantities-of-the-same-kind","title":"Converting between quantities of the same kind","text":"<p>Based on the hierarchy above, we can define the following quantity conversion rules:</p> <ol> <li> <p>Implicit conversions</p> <ul> <li>Every width is a length.</li> <li>Every radius is a width.</li> </ul> <pre><code>static_assert(implicitly_convertible(isq::width, isq::length));\nstatic_assert(implicitly_convertible(isq::radius, isq::length));\nstatic_assert(implicitly_convertible(isq::radius, isq::width));\n</code></pre> <p>Implicit conversions are allowed on copy-initialization:</p> <pre><code>void foo(quantity&lt;isq::length[m]&gt; q);\n</code></pre> <pre><code>quantity&lt;isq::width[m]&gt; q1 = 42 * m;\nquantity&lt;isq::length[m]&gt; q2 = q1;  // implicit quantity conversion\nfoo(q1);                           // implicit quantity conversion\n</code></pre> </li> <li> <p>Explicit conversions</p> <ul> <li>Not every length is a width.</li> <li>Not every width is a radius.</li> </ul> <pre><code>static_assert(!implicitly_convertible(isq::length, isq::width));\nstatic_assert(!implicitly_convertible(isq::length, isq::radius));\nstatic_assert(!implicitly_convertible(isq::width, isq::radius));\nstatic_assert(explicitly_convertible(isq::length, isq::width));\nstatic_assert(explicitly_convertible(isq::length, isq::radius));\nstatic_assert(explicitly_convertible(isq::width, isq::radius));\n</code></pre> <p>Explicit conversions are forced by passing the quantity to a call operator of a <code>quantity_spec</code> type or by calling <code>quantity</code>'s explicit constructor:</p> <pre><code>void foo(quantity&lt;isq::height[m]&gt; q);\n</code></pre> <pre><code>quantity&lt;isq::length[m]&gt; q1 = 42 * m;\nquantity&lt;isq::height[m]&gt; q2 = isq::height(q1);  // explicit quantity conversion\nquantity&lt;isq::height[m]&gt; q3(q1);                // direct initialization\nfoo(isq::height(q1));                           // explicit quantity conversion\n</code></pre> </li> <li> <p>Explicit casts</p> <ul> <li>height is never a width, and vice versa.</li> <li>Both height and width are quantities of kind length.</li> </ul> <pre><code>static_assert(!implicitly_convertible(isq::height, isq::width));\nstatic_assert(!explicitly_convertible(isq::height, isq::width));\nstatic_assert(castable(isq::height, isq::width));\n</code></pre> <p>Explicit casts are forced with a dedicated <code>quantity_cast</code> function:</p> <pre><code>void foo(quantity&lt;isq::height[m]&gt; q);\n</code></pre> <pre><code>quantity&lt;isq::width[m]&gt; q1 = 42 * m;\nquantity&lt;isq::height[m]&gt; q2 = quantity_cast&lt;isq::height&gt;(q1);  // explicit quantity cast\nfoo(quantity_cast&lt;isq::height&gt;(q1));                           // explicit quantity cast\n</code></pre> </li> <li> <p>No conversion</p> <ul> <li>time has nothing in common with length.</li> </ul> <pre><code>static_assert(!implicitly_convertible(isq::time, isq::length));\nstatic_assert(!explicitly_convertible(isq::time, isq::length));\nstatic_assert(!castable(isq::time, isq::length));\n</code></pre> <p>Even the explicit casts will not force such a conversion:</p> <pre><code>void foo(quantity&lt;isq::length[m]&gt;);\n</code></pre> <pre><code>quantity&lt;isq::length[m]&gt; q1 = 42 * s;    // Compile-time error\nfoo(quantity_cast&lt;isq::length&gt;(42 * s)); // Compile-time error\n</code></pre> </li> </ol>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#comparing-adding-and-subtracting-quantities-of-the-same-kind","title":"Comparing, adding, and subtracting quantities of the same kind","text":"<p>ISO/IEC 80000 explicitly states that width and height are quantities of the same kind, and as such they:</p> <ul> <li>are mutually comparable,</li> <li>can be added and subtracted.</li> </ul> <p>This means that we should be allowed to compare any quantities from the same tree (as long as their underlying representation types are comparable):</p> <pre><code>static_assert(isq::radius(1 * m) == isq::height(1 * m));\n</code></pre> <p>Also, based on our hierarchy above, the only reasonable result of <code>1 * width + 1 * height</code> is <code>2 * length</code>, where the result of <code>length</code> is known as a common quantity type. A result of such an equation is always the first common node in a hierarchy tree of the same kind. For example:</p> <pre><code>static_assert((isq::width(1 * m) + isq::height(1 * m)).quantity_spec == isq::length);\nstatic_assert((isq::thickness(1 * m) + isq::radius(1 * m)).quantity_spec == isq::width);\nstatic_assert((isq::distance(1 * m) + isq::path_length(1 * m)).quantity_spec == isq::path_length);\n</code></pre>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#modeling-a-quantity-kind","title":"Modeling a quantity kind","text":"<p>In the quantities and units library, we also need an abstraction describing an entire family of quantities of the same kind. Such quantities have not only the same dimension but also can be expressed in the same units.</p> <p>To annotate a quantity to represent its kind (and not just a hierarchy tree's root quantity) we introduced a <code>kind_of&lt;&gt;</code> specifier. For example, to express any quantity of length, we need to type <code>kind_of&lt;isq::length&gt;</code>.</p> <p>Important</p> <p><code>isq::length</code> and <code>kind_of&lt;isq::length&gt;</code> are two different things.</p> <p>Such an entity behaves as any quantity of its kind. This means that it is implicitly convertible to any quantity in a tree.</p> <pre><code>static_assert(!implicitly_convertible(isq::length, isq::height));\nstatic_assert(implicitly_convertible(kind_of&lt;isq::length&gt;, isq::height));\n</code></pre> <p>Additionally, the result of operations on quantity kinds is also a quantity kind:</p> <pre><code>static_assert(same_type&lt;kind_of&lt;isq::length&gt; / kind_of&lt;isq::time&gt;, kind_of&lt;isq::length / isq::time&gt;&gt;);\n</code></pre> <p>However, if at least one equation's operand is not a quantity kind, the result becomes a \"strong\" quantity where all the kinds are converted to the hierarchy tree's root quantities:</p> <pre><code>static_assert(!same_type&lt;kind_of&lt;isq::length&gt; / isq::time, kind_of&lt;isq::length / isq::time&gt;&gt;);\nstatic_assert(same_type&lt;kind_of&lt;isq::length&gt; / isq::time, isq::length / isq::time&gt;);\n</code></pre> <p>Info</p> <p>Only a root quantity from the hierarchy tree or the one marked with <code>is_kind</code> specifier in the <code>quantity_spec</code> definition can be put as a template parameter to the <code>kind_of</code> specifier. For example, <code>kind_of&lt;isq::width&gt;</code> will fail to compile. However, we can call <code>get_kind(q)</code> to obtain a kind of any quantity:</p> <pre><code>static_assert(get_kind(isq::width) == kind_of&lt;isq::length&gt;);\n</code></pre>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#how-do-systems-of-units-benefit-from-the-isq-and-quantity-kinds","title":"How do systems of units benefit from the ISQ and quantity kinds?","text":"<p>Modeling a system of units is the most essential feature and a selling point of every physical units library. Thanks to that, the library can protect users from assigning, adding, subtracting, or comparing incompatible units and provide automated conversion factors between various compatible units.</p> <p>Probably all the libraries in the wild model the SI (or at least most of it), and many of them provide support for additional units belonging to various other systems (e.g., imperial).</p>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#systems-of-units-are-based-on-systems-of-quantities","title":"Systems of units are based on systems of quantities","text":"<p>Systems of quantities specify a set of quantities and equations relating to those quantities. Those equations do not take any unit or a numerical representation into account at all. In order to create a quantity, we need to add those missing pieces of information. This is where a system of units kicks in.</p> <p>The SI is explicitly stated to be based on the ISQ. Among others, it defines seven base units, one for each base quantity of ISQ. In the library, this is expressed by associating a quantity kind to a unit being defined:</p> <pre><code>inline constexpr struct metre final : named_unit&lt;\"m\", kind_of&lt;isq::length&gt;&gt; {} metre;\n</code></pre> <p>The <code>kind_of&lt;isq::length&gt;</code> above states explicitly that this unit has an associated quantity kind. In other words, <code>si::metre</code> (and scaled units based on it) can be used to express the amount of any quantity of kind length.</p> <p>Note</p> <p>For some systems of units (e.g., natural units), a unit may not have an associated quantity type. For example, if we define the speed of light constant as <code>c = 1</code>, we can define a system where both length and time will be measured in seconds, and speed will be a quantity measured with the unit <code>one</code>. In such case, the definition will look as follows:</p> <pre><code>inline constexpr struct second final : named_unit&lt;\"s\"&gt; {} second;\n</code></pre>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#constraining-a-derived-unit-to-work-only-with-a-specific-derived-quantity","title":"Constraining a derived unit to work only with a specific derived quantity","text":"<p>Some derived units are valid only for specific derived quantities. For example, SI specifies both hertz and becquerel derived units with the same unit equation \\(s^{-1}\\). However, it also explicitly states:</p> <p>SI</p> <p>The hertz shall only be used for periodic phenomena and the becquerel shall only be used for stochastic processes in activity referred to a radionuclide.</p> <p>This is why it is important for the library to allow constraining such units to be used only with a specific quantity kind:</p> <pre><code>inline constexpr struct hertz final : named_unit&lt;\"Hz\", one / second, kind_of&lt;isq::frequency&gt;&gt; {} hertz;\ninline constexpr struct becquerel final : named_unit&lt;\"Bq\", one / second, kind_of&lt;isq::activity&gt;&gt; {} becquerel;\n</code></pre> <p>With the above, <code>hertz</code> can only be used for frequencies, while <code>becquerel</code> should only be used for quantities of activity:</p> <pre><code>quantity&lt;isq::frequency[Hz]&gt; q1 = 60 * Bq;   // Compile-time error\nquantity&lt;isq::activity[Hz]&gt; q2;              // Compile-time error\nquantity&lt;isq::frequency[Hz]&gt; q3 = 60 * Hz;   // OK\nstd::cout &lt;&lt; q3.in(Bq) &lt;&lt; \"\\n\";              // Compile-time error\n</code></pre> <p>We know already that quantities of different kinds can't be compared, added, and subtracted. The following equation will not compile thanks to constraining derived units to be valid for specific kinds only:</p> <pre><code>auto q = 1 * Hz + 1 * Bq;   // Fails to compile\n</code></pre> <p>All of the above features improve the safety of our library and the products that are using it.</p>"},{"location":"blog/2024/10/21/international-system-of-quantities-isq-part-3---modeling-isq/#to-be-continued","title":"To be continued...","text":"<p>In the next part of this series, we will present how we can implement our ISQ model in a C++ programming language and we will point out some of the first issues that stand in our way.</p>"},{"location":"blog/2024/10/28/international-system-of-quantities-isq-part-4---implementing-isq/","title":"International System of Quantities (ISQ): Part 4 - Implementing ISQ","text":"<p>Up until now, we have introduced the International System of Quantities and described how we can model its main aspects. This article will present how to implement those models in a programming language, and we will point out some of the first issues that stand in our way.</p> <p>In the previous article, we have already introduced a notion of quantity kind, provided <code>kind_of&lt;&gt;</code> specifier, and described how it helps in the modeling of the system of units (e.g., SI).</p> <p>Now, it is time to see how we can implement hierarchies of quantities of the same kind.</p>"},{"location":"blog/2024/10/28/international-system-of-quantities-isq-part-4---implementing-isq/#articles-from-this-series","title":"Articles from this series","text":"<ul> <li>Part 1 - Introduction</li> <li>Part 2 - Problems when ISQ is not used</li> <li>Part 3 - Modeling ISQ</li> <li>Part 4 - Implementing ISQ</li> <li>Part 5 - Benefits</li> <li>Part 6 - Challenges</li> </ul>"},{"location":"blog/2024/10/28/international-system-of-quantities-isq-part-4---implementing-isq/#modeling-a-hierarchy-of-kind-length","title":"Modeling a hierarchy of kind length","text":"<p>First, let's start with something easy - hierarchy of kind length. ISO 80000-3 does a good job of describing all relations between quantities in this case.</p> <p>We've seen this tree already:</p> <pre><code>flowchart TD\n    length[\"&lt;b&gt;length&lt;/b&gt;&lt;br&gt;[m]\"]\n    length --- width[\"&lt;b&gt;width&lt;/b&gt; / &lt;b&gt;breadth&lt;/b&gt;\"]\n    length --- height[\"&lt;b&gt;height&lt;/b&gt; / &lt;b&gt;depth&lt;/b&gt; / &lt;b&gt;altitude&lt;/b&gt;\"]\n    width --- thickness[\"&lt;b&gt;thickness&lt;/b&gt;\"]\n    width --- diameter[\"&lt;b&gt;diameter&lt;/b&gt;\"]\n    width --- radius[\"&lt;b&gt;radius&lt;/b&gt;\"]\n    length --- path_length[\"&lt;b&gt;path_length&lt;/b&gt;\"]\n    path_length --- distance[\"&lt;b&gt;distance&lt;/b&gt;\"]\n    distance --- radial_distance[\"&lt;b&gt;radial_distance&lt;/b&gt;\"]\n    length --- wavelength[\"&lt;b&gt;wavelength&lt;/b&gt;\"]\n    length --- displacement[\"&lt;b&gt;displacement&lt;/b&gt;&lt;br&gt;{vector}\"]\n    displacement --- position_vector[\"&lt;b&gt;position_vector&lt;/b&gt;\"]\n    radius --- radius_of_curvature[\"&lt;b&gt;radius_of_curvature&lt;/b&gt;\"]</code></pre> <p>This is how we can model it in C++:</p> <pre><code>inline constexpr struct dim_length final          : base_dimension&lt;\"L\"&gt; {} dim_length;\n\ninline constexpr struct length final              : quantity_spec&lt;dim_length&gt; {} length;\ninline constexpr struct width final               : quantity_spec&lt;length&gt; {} width;\ninline constexpr auto breadth = width;\ninline constexpr struct height final              : quantity_spec&lt;length&gt; {} height;\ninline constexpr auto depth = height;\ninline constexpr auto altitude = height;\ninline constexpr struct thickness final           : quantity_spec&lt;width&gt; {} thickness;\ninline constexpr struct diameter final            : quantity_spec&lt;width&gt; {} diameter;\ninline constexpr struct radius final              : quantity_spec&lt;width&gt; {} radius;\ninline constexpr struct radius_of_curvature final : quantity_spec&lt;radius&gt; {} radius_of_curvature;\ninline constexpr struct path_length final         : quantity_spec&lt;length&gt; {} path_length;\ninline constexpr auto arc_length = path_length;\ninline constexpr struct distance final            : quantity_spec&lt;path_length&gt; {} distance;\ninline constexpr struct radial_distance final     : quantity_spec&lt;distance&gt; {} radial_distance;\ninline constexpr struct wavelength final          : quantity_spec&lt;length&gt; {} wavelength;\ninline constexpr struct displacement final        : quantity_spec&lt;length, quantity_character::vector&gt; {} displacement;\ninline constexpr struct position_vector final     : quantity_spec&lt;displacement&gt; {} position_vector;\n</code></pre> <p>Thanks to the expressivity and power of C++ templates, we can specify all quantity properties in one line of code. In the above code:</p> <ul> <li><code>length</code> takes the base dimension to indicate that we are creating a base quantity that will serve   as a root for a tree of quantities of the same kind,</li> <li><code>width</code> and following quantities are branches and leaves of this tree with the parent always   provided as the first argument to <code>quantity_spec</code> class template,</li> <li><code>breadth</code> is an alias name for the same quantity as <code>width</code>.</li> </ul> <p>Note</p> <p>Some quantities may be specified to have complex scalar, vector, or tensor character (e.g., <code>displacement</code>). The quantity character can be set with the last parameter of <code>quantity_spec</code>.</p>"},{"location":"blog/2024/10/28/international-system-of-quantities-isq-part-4---implementing-isq/#modeling-a-hierarchy-of-kind-energy","title":"Modeling a hierarchy of kind energy","text":"<p>Base quantities are simple. It is more complicated when we start modeling derived quantities. Let's try to model the hierarchy for energy.</p> <p>When we look into the ISO/IEC 80000 standards, this task immediately stops being as easy as the previous one. Derived quantity equations often do not automatically form a hierarchy tree, and ISO/IEC standards do not provide a clear answer to inter-quantity dependencies. This is why it is often not obvious what such a tree should look like.</p> <p>Even more, ISO explicitly states:</p> <p>ISO/IEC Guide 99</p> <p>The division of \u2018quantity\u2019 according to \u2018kind of quantity\u2019 is, to some extent, arbitrary.</p> <p>Let's try anyway. The below presents some arbitrary hierarchy of derived quantities of kind energy:</p> <pre><code>flowchart TD\n    energy[\"&lt;b&gt;energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * length&lt;sup&gt;2&lt;/sup&gt; / time&lt;sup&gt;2&lt;/sup&gt;)&lt;/i&gt;&lt;br&gt;[J]\"]\n    energy --- mechanical_energy[\"&lt;b&gt;mechanical_energy&lt;/b&gt;\"]\n    mechanical_energy --- potential_energy[\"&lt;b&gt;potential_energy&lt;/b&gt;\"]\n    potential_energy --- gravitational_potential_energy[\"&lt;b&gt;gravitational_potential_energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * acceleration_of_free_fall * height)&lt;/i&gt;\"]\n    potential_energy --- elastic_potential_energy[\"&lt;b&gt;elastic_potential_energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(spring_constant * amount_of_compression&lt;sup&gt;2&lt;/sup&gt;)&lt;/i&gt;\"]\n    mechanical_energy --- kinetic_energy[\"&lt;b&gt;kinetic_energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * speed&lt;sup&gt;2&lt;/sup&gt;)&lt;/i&gt;\"]\n    energy --- enthalpy[\"&lt;b&gt;enthalpy&lt;/b&gt;\"]\n    enthalpy --- internal_energy[\"&lt;b&gt;internal_energy&lt;/b&gt; / &lt;b&gt;thermodynamic_energy&lt;/b&gt;\"]\n    internal_energy --- Helmholtz_energy[\"&lt;b&gt;Helmholtz_energy&lt;/b&gt; / &lt;b&gt;Helmholtz_function&lt;/b&gt;\"]\n    enthalpy --- Gibbs_energy[\"&lt;b&gt;Gibbs_energy&lt;/b&gt; / &lt;b&gt;Gibbs_function&lt;/b&gt;\"]\n    energy --- active_energy[\"&lt;b&gt;active_energy&lt;/b&gt;\"]</code></pre> <p>As we can see above, besides what we've already seen for length hierarchy, derived quantities may provide specific recipes that can be used to create them implicitly:</p> <ul> <li> <p>energy is the most generic one and thus can be created from base quantities of mass,   length, and time. As those are also the roots of quantities of their kinds and all other   quantities from their trees are implicitly convertible to them, it means that an energy can be   implicitly constructed from any quantity of mass, length, and time:</p> <pre><code>static_assert(implicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time), isq::energy));\nstatic_assert(implicitly_convertible(isq::mass * pow&lt;2&gt;(isq::height) / pow&lt;2&gt;(isq::time), isq::energy));\n</code></pre> </li> <li> <p>mechanical energy is a more \"specialized\" quantity than energy (not every energy is   a mechanical energy). It is why an explicit cast is needed to convert from either energy or   the results of its quantity equation:</p> <pre><code>static_assert(!implicitly_convertible(isq::energy, isq::mechanical_energy));\nstatic_assert(explicitly_convertible(isq::energy, isq::mechanical_energy));\nstatic_assert(!implicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time),\n                                      isq::mechanical_energy));\nstatic_assert(explicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time),\n                                     isq::mechanical_energy));\n</code></pre> </li> <li> <p>gravitational potential energy is not only even more specialized one but additionally,   it is special in a way that it provides its own \"constrained\"   quantity equation. Maybe not every   <code>mass * pow&lt;2&gt;(length) / pow&lt;2&gt;(time)</code> is a gravitational potential energy, but every   <code>mass * acceleration_of_free_fall * height</code> is.</p> <pre><code>static_assert(!implicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time),\n                                      gravitational_potential_energy));\nstatic_assert(explicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time),\n                                     gravitational_potential_energy));\nstatic_assert(implicitly_convertible(isq::mass * isq::acceleration_of_free_fall * isq::height,\n                                     gravitational_potential_energy));\n</code></pre> </li> </ul> <p>And here is the C++ code for it:</p> <pre><code>inline constexpr struct energy final                         : quantity_spec&lt;mass* pow&lt;2&gt;(length) / pow&lt;2&gt;(time)&gt; {} energy;\ninline constexpr struct mechanical_energy final              : quantity_spec&lt;energy&gt; {} mechanical_energy;                                                            // differs from ISO 80000\ninline constexpr struct potential_energy final               : quantity_spec&lt;mechanical_energy&gt; {} potential_energy;                                                  // differs from ISO 80000\ninline constexpr struct gravitational_potential_energy final : quantity_spec&lt;potential_energy, mass * acceleration_of_free_fall * height&gt; {} potential_energy;        // not in ISO 80000\ninline constexpr struct elastic_potential_energy final       : quantity_spec&lt;potential_energy, spring_constant * pow&lt;2&gt;(amount_of_compression)&gt; {} potential_energy;  // not in ISO 80000\ninline constexpr struct kinetic_energy final                 : quantity_spec&lt;mechanical_energy, mass* pow&lt;2&gt;(speed)&gt; {} kinetic_energy;                               // differs from ISO 80000\ninline constexpr struct enthalpy final                       : quantity_spec&lt;energy&gt; {} enthalpy;                                                                     // differs from ISO 80000\ninline constexpr struct internal_energy final                : quantity_spec&lt;enthalpy&gt; {} internal_energy;                                                            // differs from ISO 80000\ninline constexpr auto thermodynamic_energy = internal_energy;\ninline constexpr struct Helmholtz_energy final               : quantity_spec&lt;internal_energy&gt; {} Helmholtz_energy;\ninline constexpr auto Helmholtz_function = Helmholtz_energy;\ninline constexpr struct Gibbs_energy final                   : quantity_spec&lt;enthalpy&gt; {} Gibbs_energy;\ninline constexpr auto Gibbs_function = Gibbs_energy;\n</code></pre> <p>Again, the first parameter of <code>quantity_spec</code> determines the position in the tree. If a second argument is provided, it denotes a recipe for this quantity.</p> <p>With the above simple definitions we've automatically addressed our energy-related issues from the Various quantities of the same dimension and kinds chapter of the \"Part 2\" article.</p>"},{"location":"blog/2024/10/28/international-system-of-quantities-isq-part-4---implementing-isq/#modeling-a-hierarchy-of-kind-dimensionless","title":"Modeling a hierarchy of kind dimensionless","text":"<p>As the last example for this article, let's try to model and implement quantities of dimension one, often also called dimensionless quantities. This quantity hierarchy contains more than one quantity kind and more than one unit in its tree:</p> <pre><code>flowchart TD\n    dimensionless[\"&lt;b&gt;dimensionless&lt;/b&gt;&lt;br&gt;[one]\"]\n    dimensionless --- rotation[\"&lt;b&gt;rotation&lt;/b&gt;\"]\n    dimensionless --- thermodynamic_efficiency[\"&lt;b&gt;thermodynamic_efficiency&lt;/b&gt;&lt;br&gt;&lt;i&gt;(work / heat)&lt;/i&gt;\"]\n    dimensionless --- angular_measure[\"&lt;b&gt;angular_measure&lt;/b&gt;&lt;br&gt;&lt;i&gt;(arc_length / radius)&lt;/i&gt;&lt;br&gt;[rad]\"]\n    angular_measure --- rotational_displacement[\"&lt;b&gt;rotational_displacement&lt;/b&gt;&lt;br&gt;&lt;i&gt;(path_length / radius)&lt;/i&gt;\"]\n    angular_measure --- phase_angle[\"&lt;b&gt;phase_angle&lt;/b&gt;\"]\n    dimensionless --- solid_angular_measure[\"&lt;b&gt;solid_angular_measure&lt;/b&gt;&lt;br&gt;&lt;i&gt;(area / pow&lt;2&gt;(radius))&lt;/i&gt;&lt;br&gt;[sr]\"]\n    dimensionless --- drag_factor[\"&lt;b&gt;drag_factor&lt;/b&gt;&lt;br&gt;&lt;i&gt;(drag_force / (mass_density * pow&lt;2&gt;(speed) * area))&lt;/i&gt;\"]\n    dimensionless --- storage_capacity[\"&lt;b&gt;storage_capacity&lt;/b&gt;&lt;br&gt;[bit]\"] --- equivalent_binary_storage_capacity[\"&lt;b&gt;equivalent_binary_storage_capacity&lt;/b&gt;\"]\n    dimensionless --- ...</code></pre> <p>To enable such support in the library, we provided an <code>is_kind</code> specifier that can be appended to the quantity specification:</p> <pre><code>inline constexpr struct dimensionless final            : quantity_spec&lt;detail::derived_quantity_spec&lt;&gt;{}&gt; {} dimensionless;\ninline constexpr struct rotation final                 : quantity_spec&lt;dimensionless&gt; {} rotation;\ninline constexpr struct thermodynamic_efficiency final : quantity_spec&lt;dimensionless, work / heat&gt; {} efficiency;\ninline constexpr struct angular_measure final          : quantity_spec&lt;dimensionless, arc_length / radius, is_kind&gt; {} angular_measure;\ninline constexpr struct rotational_displacement final  : quantity_spec&lt;angular_measure, path_length / radius&gt; {} rotational_displacement;\ninline constexpr struct phase_angle final              : quantity_spec&lt;angular_measure&gt; {} phase_angle;\ninline constexpr struct solid_angular_measure final    : quantity_spec&lt;dimensionless, area / pow&lt;2&gt;(radius), is_kind&gt; {} solid_angular_measure;\ninline constexpr struct drag_factor final              : quantity_spec&lt;dimensionless, drag_force / (mass_density * pow&lt;2&gt;(speed) * area)&gt; {} drag_factor;\ninline constexpr struct storage_capacity final         : quantity_spec&lt;dimensionless, is_kind&gt; {} storage_capacity;\n</code></pre> <p>With the above, we can constrain <code>radian</code>, <code>steradian</code>, and <code>bit</code> to be allowed for usage with specific quantity kinds only:</p> <pre><code>inline constexpr struct radian final    : named_unit&lt;\"rad\", metre / metre, kind_of&lt;isq::angular_measure&gt;&gt; {} radian;\ninline constexpr struct steradian final : named_unit&lt;\"sr\", square(metre) / square(metre), kind_of&lt;isq::solid_angular_measure&gt;&gt; {} steradian;\ninline constexpr struct bit final       : named_unit&lt;\"bit\", one, kind_of&lt;storage_capacity&gt;&gt; {} bit;\n</code></pre> <p>but still allow the usage of <code>one</code> and its scaled versions for such quantities.</p> <p>Note</p> <p><code>dimensionless</code> is a special quantity which serves as an identity element in quantity equations. It is predefined in the library's framework and there is no way for the user to define it or something similar to it.</p>"},{"location":"blog/2024/10/28/international-system-of-quantities-isq-part-4---implementing-isq/#to-be-continued","title":"To be continued...","text":"<p>In the next part of this series, we will present how our ISQ model helps to address the remaining issues described in the Part 2 of our series.</p>"},{"location":"blog/2024/11/04/international-system-of-quantities-isq-part-5---benefits/","title":"International System of Quantities (ISQ): Part 5 - Benefits","text":"<p>In the previous articles, we introduced the International System of Quantities, described how we can model and implement it in a programming language, and presented the issues of software that does not use such abstraction to implement a units library.</p> <p>Some of the issues raised in Part 2 of our series were addressed in Part 3 already. This article will present how our ISQ model elegantly addresses the remaining problems.</p>"},{"location":"blog/2024/11/04/international-system-of-quantities-isq-part-5---benefits/#articles-from-this-series","title":"Articles from this series","text":"<ul> <li>Part 1 - Introduction</li> <li>Part 2 - Problems when ISQ is not used</li> <li>Part 3 - Modeling ISQ</li> <li>Part 4 - Implementing ISQ</li> <li>Part 5 - Benefits</li> <li>Part 6 - Challenges</li> </ul>"},{"location":"blog/2024/11/04/international-system-of-quantities-isq-part-5---benefits/#generic-but-safe-interfaces","title":"Generic but safe interfaces","text":"<p>Let's start with the implementation of a generic utility function that would calculate the average speed based on provided arguments. The resulting quantity should use a derived unit of the provided arguments (e.g., <code>km/h</code> for <code>km</code> and <code>h</code>, <code>m/s</code> for <code>m</code> and <code>s</code>, ...).</p> <p>With C++ concepts backed up with ISQ quantities, we can simply type it as:</p> <pre><code>constexpr QuantityOf&lt;isq::speed&gt; auto avg_speed(QuantityOf&lt;isq::length&gt; auto d,\n                                                QuantityOf&lt;isq::time&gt; auto t)\n{\n  return d / t;\n}\n</code></pre> <p>The above constrains the algorithm to proper quantity types and ensures that a quantity of speed is returned. The latter is essential not only for the users to better understand what the function does but also serves as a unit test for our implementation. It ensures that our quantity equations are correct in the implementation part of the function, and we indeed return a quantity of speed.</p>"},{"location":"blog/2024/11/04/international-system-of-quantities-isq-part-5---benefits/#non-convertible-units-of-currency","title":"Non-convertible units of currency","text":"<p>Our second example was about disjoint units of currency. We want to use various units of currency but we can't provide compile-time known conversion factors between those as such ratios are only known at runtime.</p> <p>First, we define:</p> <ul> <li>a new dimension for currency and a quantity type based on it,</li> <li>set of disjoint units of currency for its quantity kind.</li> </ul> <pre><code>inline constexpr struct dim_currency final : base_dimension&lt;\"$\"&gt; {} dim_currency;\ninline constexpr struct currency final : quantity_spec&lt;dim_currency&gt; {} currency;\n\ninline constexpr struct euro final : named_unit&lt;\"EUR\", kind_of&lt;currency&gt;&gt; {} euro;\ninline constexpr struct us_dollar final : named_unit&lt;\"USD\", kind_of&lt;currency&gt;&gt; {} us_dollar;\n\nnamespace unit_symbols {\n\ninline constexpr auto EUR = euro;\ninline constexpr auto USD = us_dollar;\n\n}\n\nstatic_assert(!std::equality_comparable_with&lt;quantity&lt;euro, int&gt;, quantity&lt;us_dollar, int&gt;&gt;);\n</code></pre> <p>Next, we can provide a custom currency exchange facility that accounts for a specific point in time:</p> <pre><code>template&lt;Unit auto From, Unit auto To&gt;\n[[nodiscard]] double exchange_rate(std::chrono::sys_seconds timestamp)\n{\n  // user-provided logic...\n}\n\ntemplate&lt;UnitOf&lt;currency&gt; auto To, QuantityOf&lt;currency&gt; From&gt;\nQuantityOf&lt;currency&gt; auto exchange_to(From q, std::chrono::sys_seconds timestamp)\n{\n  const auto rate =\n    static_cast&lt;From::rep&gt;(exchange_rate&lt;From::unit, To&gt;(timestamp) * q.numerical_value_in(q.unit));\n  return rate * From::quantity_spec[To];\n}\n</code></pre> <p>Finally, we can use our simple model in the following way:</p> <pre><code>using namespace unit_symbols;\nusing namespace std::chrono;\n\nconst auto yesterday = time_point_cast&lt;seconds&gt;(system_clock::now() - hours{24});\nconst quantity price_usd = 100 * USD;\nconst quantity price_euro = exchange_to&lt;euro&gt;(price_usd, yesterday);\n\nstd::cout &lt;&lt; price_usd &lt;&lt; \" -&gt; \" &lt;&lt; price_euro &lt;&lt; \"\\n\";\n// std::cout &lt;&lt; price_usd + price_euro &lt;&lt; \"\\n\";  // does not compile\n</code></pre> <p>Note</p> <p>It would be better to model the above prices as quantity points, but this is a subject for a different article .</p>"},{"location":"blog/2024/11/04/international-system-of-quantities-isq-part-5---benefits/#derived-quantities-of-the-same-dimension-but-different-kinds","title":"Derived quantities of the same dimension but different kinds","text":"<p>Until now, the issues discussed have not actually required modeling of the ISQ. The introduction of physical dimensions would be enough, and indeed, this is what most of the libraries on the market do. However, we have more exciting challenges to solve as well.</p> <p>The next issue was related to different quantities having the same dimension. In many cases, we want to prevent conversions and any other compatibility between such distinct quantities.</p> <p>Let's try to implement our fuel consumption example. First, we define the quantity type and a handy identifier for a derived unit that we want to use:</p> <pre><code>inline constexpr struct fuel_consumption final : quantity_spec&lt;isq::volume / isq::length&gt; {} fuel_consumption;\ninline constexpr auto L_per_100km = si::litre / (mag&lt;100&gt; * si::kilo&lt;si::metre&gt;);\n\nstatic_assert(fuel_consumption != isq::area);\nstatic_assert(fuel_consumption.dimension == isq::area.dimension);\n</code></pre> <p>Next, we define two quantities. The first one is based only on a derived unit of <code>L/[100 km]</code>, while the second uses a strongly typed quantity type:</p> <pre><code>quantity q1 = 5.8 * L_per_100km;\nquantity q2 = fuel_consumption(6.7 * L_per_100km);\nstd::println(\"Fuel consumptions: {}, {}\", q1, q2);\n\nstatic_assert(implicitly_convertible(q1.quantity_spec, isq::area));\nstatic_assert(!implicitly_convertible(q2.quantity_spec, isq::area));\nstatic_assert(!explicitly_convertible(q2.quantity_spec, isq::area));\nstatic_assert(!castable(q2.quantity_spec, isq::area));\n</code></pre> <p>As we can see, with just units (especially derived ones) and dimensions, we often can't achieve the same level of safety as with adequately modeled hierarchies of quantities. Only in case of <code>q2</code> we can prevent incorrect conversions to a different quantity of the same dimension.</p>"},{"location":"blog/2024/11/04/international-system-of-quantities-isq-part-5---benefits/#various-quantities-of-the-same-dimension-and-kinds","title":"Various quantities of the same dimension and kinds","text":"<p>In the previous example, area and fuel consumption were quantities of the same dimension but of different kinds. In engineering, there are also many cases where we need to model distinct quantities of the same kind.</p> <p>Let's try to improve the safety of our <code>Box</code> example.</p> <p>First, we need to extend our ISQ definitions by the horizontal length quantity and a horizontal area derived from it:</p> <pre><code>inline constexpr struct horizontal_length final : quantity_spec&lt;isq::length&gt; {} horizontal_length;\ninline constexpr struct horizontal_area final : quantity_spec&lt;isq::area, horizontal_length * isq::width&gt; {} horizontal_area;\n</code></pre> <p>Note</p> <p><code>isq::length</code> denotes any quantity of length (not only the horizontal one).</p> <pre><code>static_assert(implicitly_convertible(horizontal_length, isq::length));\nstatic_assert(!implicitly_convertible(isq::length, horizontal_length));\n\nstatic_assert(implicitly_convertible(horizontal_area, isq::area));\nstatic_assert(!implicitly_convertible(isq::area, horizontal_area));\n\nstatic_assert(implicitly_convertible(isq::length * isq::length, isq::area));\nstatic_assert(!implicitly_convertible(isq::length * isq::length, horizontal_area));\n\nstatic_assert(implicitly_convertible(horizontal_length * isq::width, isq::area));\nstatic_assert(implicitly_convertible(horizontal_length * isq::width, horizontal_area));\n</code></pre> <p>With simple two lines of definition, we made the above logic automatically work without needing additional customization for special cases. Based on hierarchies of derived quantities and their recipes, the proposed model automatically inherits the properties of base quantities involved in the recipe. This makes the composition of derived quantities very easy, which is not true for alternative solutions based on tag types that do not compose their properties.</p> <p>Now we can refactor our <code>Box</code> to benefit from the introduced safe abstractions:</p> <pre><code>class Box {\n  quantity&lt;horizontal_length[m]&gt; length_;\n  quantity&lt;isq::width[m]&gt; width_;\n  quantity&lt;isq::height[m]&gt; height_;\npublic:\n  Box(quantity&lt;horizontal_length[m]&gt; l, quantity&lt;isq::width[m]&gt; w, quantity&lt;isq::height[m]&gt; h):\n    length_(l), width_(w), height_(h)\n  {}\n\n  quantity&lt;horizontal_area[m2]&gt; floor() const { return length_ * width_; }\n  // ...\n};\n</code></pre> <p>It is important to note that the safety can be enforced only when a user provides typed quantities as arguments to the functions:</p> <pre><code>Box my_box1(2 * m, 3 * m, 1 * m);\nBox my_box2(2 * horizontal_length[m], 3 * isq::width[m], 1 * isq::height[m]);\nBox my_box3(horizontal_length(2 * m), isq::width(3 * m), isq::height(1 * m));\n</code></pre> <p>Important</p> <p>It is up to the user to decide when and where to care about explicit quantity types and when to prefer simple unit-only mode.</p>"},{"location":"blog/2024/11/04/international-system-of-quantities-isq-part-5---benefits/#various-kinds-of-dimensionless-quantities","title":"Various kinds of dimensionless quantities","text":"<p>Most of the quantities hierarchies describe only one kind. There are some exceptions, though. One of them is a hierarchy of dimensionless quantities. This tree defines quantities that denote:</p> <ul> <li>counts (e.g., storage capacity),</li> <li>ratios (e.g., efficiency),</li> <li>angles (e.g., angular measure, solid angular measure),</li> <li>scaled numbers.</li> </ul> <p>Each of the above could form a separate tree of mutually comparable quantities. However, all of them have a common property. Every quantity from this tree, despite often being measured in a dedicated unit (e.g., <code>bit</code>, <code>rad</code>, <code>sr</code>), should also be able to be measured in a unit <code>one</code>.</p> <p>We've seen how to model such a hierarchy in a previous article in our series. This time, we will see a simplified part of a concrete, real-life example for this use case.</p> <p>We often need to provide strong types for different counts in the digital signal processing domain. Abstractions like samples, beats, MIDI clock, and others should not be possible to be intermixed with each other:</p> <pre><code>namespace ni {\n\ninline constexpr struct SampleCount final : quantity_spec&lt;dimensionless, is_kind&gt; {} SampleCount;\ninline constexpr struct UnitSampleAmount final : quantity_spec&lt;dimensionless, is_kind&gt; {} UnitSampleAmount;\ninline constexpr struct MIDIClock final : quantity_spec&lt;dimensionless, is_kind&gt; {} MIDIClock;\ninline constexpr struct BeatCount final : quantity_spec&lt;dimensionless, is_kind&gt; {} BeatCount;\n</code></pre> <p>We should also be able to create derived quantities from those. For example, when we divide such a quantity by time we should get a new strong quantity that can be measured in both a dedicated unit (e.g., <code>Smpl/s</code> for sample rate) and hertz:</p> <pre><code>inline constexpr struct SampleDuration final : quantity_spec&lt;isq::period_duration&gt; {} SampleDuration;\ninline constexpr struct SamplingRate final : quantity_spec&lt;isq::frequency, SampleCount / SampleDuration&gt; {} SamplingRate;\n\ninline constexpr auto Amplitude = UnitSampleAmount;\ninline constexpr auto Level = UnitSampleAmount;\ninline constexpr struct Power final : quantity_spec&lt;Level * Level&gt; {} Power;\n\ninline constexpr struct BeatDuration final : quantity_spec&lt;isq::period_duration&gt; {} BeatDuration;\ninline constexpr struct Tempo final : quantity_spec&lt;isq::frequency, BeatCount / BeatDuration&gt; {} Tempo;\n</code></pre> <p>We can also define a collection of units associated with specific quantity kinds and their symbols:</p> <pre><code>inline constexpr struct Sample final : named_unit&lt;\"Smpl\", one, kind_of&lt;SampleCount&gt;&gt; {} Sample;\ninline constexpr struct SampleValue final : named_unit&lt;\"PCM\", one, kind_of&lt;UnitSampleAmount&gt;&gt; {} SampleValue;\ninline constexpr struct MIDIPulse final : named_unit&lt;\"p\", one, kind_of&lt;MIDIClock&gt;&gt; {} MIDIPulse;\n\ninline constexpr struct QuarterNote final : named_unit&lt;\"q\", one, kind_of&lt;BeatCount&gt;&gt; {} QuarterNote;\ninline constexpr struct HalfNote final : named_unit&lt;\"h\", mag&lt;2&gt; * QuarterNote&gt; {} HalfNote;\ninline constexpr struct DottedHalfNote final : named_unit&lt;\"h.\", mag&lt;3&gt; * QuarterNote&gt; {} DottedHalfNote;\ninline constexpr struct WholeNote final : named_unit&lt;\"w\", mag&lt;4&gt; * QuarterNote&gt; {} WholeNote;\ninline constexpr struct EightNote final : named_unit&lt;\"8th\", mag_ratio&lt;1, 2&gt; * QuarterNote&gt; {} EightNote;\ninline constexpr struct DottedQuarterNote final : named_unit&lt;\"q.\", mag&lt;3&gt; * EightNote&gt; {} DottedQuarterNote;\ninline constexpr struct QuarterNoteTriplet final : named_unit&lt;\"qt\", mag_ratio&lt;1, 3&gt; * HalfNote&gt; {} QuarterNoteTriplet;\ninline constexpr struct SixteenthNote final : named_unit&lt;\"16th\", mag_ratio&lt;1, 2&gt; * EightNote&gt; {} SixteenthNote;\ninline constexpr struct DottedEightNote final : named_unit&lt;\"q.\", mag&lt;3&gt; * SixteenthNote&gt; {} DottedEightNote;\n\ninline constexpr auto Beat = QuarterNote;\n\ninline constexpr struct BeatsPerMinute final : named_unit&lt;\"bpm\", Beat / si::minute&gt; {} BeatsPerMinute;\ninline constexpr struct MIDIPulsePerQuarter final : named_unit&lt;\"ppqn\", MIDIPulse / QuarterNote&gt; {} MIDIPulsePerQuarter;\n\nnamespace unit_symbols {\n\ninline constexpr auto Smpl = Sample;\ninline constexpr auto pcm = SampleValue;\ninline constexpr auto p = MIDIPulse;\n\ninline constexpr auto n_wd = 3 * HalfNote;\ninline constexpr auto n_w = WholeNote;\ninline constexpr auto n_hd = DottedHalfNote;\ninline constexpr auto n_h = HalfNote;\ninline constexpr auto n_qd = DottedQuarterNote;\ninline constexpr auto n_q = QuarterNote;\ninline constexpr auto n_qt = QuarterNoteTriplet;\ninline constexpr auto n_8thd = DottedEightNote;\ninline constexpr auto n_8th = EightNote;\ninline constexpr auto n_16th = SixteenthNote;\n\n}\n\n}  // namespace ni\n</code></pre> <p>With the above, we can safely work with each quantity and use SI or domain-specific units as needed:</p> <pre><code>using namespace ni::unit_symbols;\nusing namespace mp_units::si::unit_symbols;\n\nconst auto sr1 = ni::GetSampleRate();\nconst auto sr2 = 48'000.f * Smpl / s;\n\nconst auto samples = 512 * Smpl;\n\nconst auto sampleTime1 = (samples / sr1).in(s);\nconst auto sampleTime2 = (samples / sr2).in(ms);\n\nconst auto sampleDuration1 = (1 / sr1).in(ms);\nconst auto sampleDuration2 = (1 / sr2).in(ms);\n\nconst auto rampTime = 35.f * ms;\nconst auto rampSamples1 = (rampTime * sr1).force_in&lt;int&gt;(Smpl);\nconst auto rampSamples2 = (rampTime * sr2).force_in&lt;int&gt;(Smpl);\n\nstd::println(\"Sample rate 1 is: {}\", sr1);\nstd::println(\"Sample rate 2 is: {}\", sr2);\n\nstd::println(\"{} @ {} is {::N[.5f]}\", samples, sr1, sampleTime1);\nstd::println(\"{} @ {} is {::N[.5f]}\", samples, sr2, sampleTime2);\n\nstd::println(\"One sample @ {} is {::N[.5f]}\", sr1, sampleDuration1);\nstd::println(\"One sample @ {} is {::N[.5f]}\", sr2, sampleDuration2);\n\nstd::println(\"{} is {} @ {}\", rampTime, rampSamples1, sr1);\nstd::println(\"{} is {} @ {}\", rampTime, rampSamples2, sr2);\n</code></pre> <p>The above prints:</p> <pre><code>Sample rate 1 is: 44100 Hz\nSample rate 2 is: 48000 Smpl/s\n512 Smpl @ 44100 Hz is 0.01161 s\n512 Smpl @ 48000 Smpl/s is 10.66667 ms\nOne sample @ 44100 Hz is 0.02268 ms\nOne sample @ 48000 Smpl/s is 0.02083 ms\n35 ms is 1543 Smpl @ 44100 Hz\n35 ms is 1680 Smpl @ 48000 Smpl/s\n</code></pre> <p>We can also do a bit more advanced computations to get the following:</p> <pre><code>auto sampleValue = -0.4f * pcm;\nauto power1 = sampleValue * sampleValue;\nauto power2 = -0.2 * pow&lt;2&gt;(pcm);\n\nauto tempo = ni::GetTempo();\nauto reverbBeats = 1 * n_qd;\nauto reverbTime = reverbBeats / tempo;\n\nauto pulsePerQuarter = value_cast&lt;float&gt;(ni::GetPPQN());\nauto transportPosition = ni::GetTransportPos();\nauto transportBeats = (transportPosition / pulsePerQuarter).in(n_q);\nauto transportTime = (transportBeats / tempo).in(s);\n\nstd::println(\"SampleValue is: {}\", sampleValue);\nstd::println(\"Power 1 is: {}\", power1);\nstd::println(\"Power 2 is: {}\", power2);\n\nstd::println(\"Tempo is: {}\", tempo);\nstd::println(\"Reverb Beats is: {}\", reverbBeats);\nstd::println(\"Reverb Time is: {}\", reverbTime.in(s));\nstd::println(\"Pulse Per Quarter is: {}\", pulsePerQuarter);\nstd::println(\"Transport Position is: {}\", transportPosition);\nstd::println(\"Transport Beats is: {}\", transportBeats);\nstd::println(\"Transport Time is: {}\", transportTime);\n</code></pre> <p>which prints:</p> <pre><code>SampleValue is: -0.4 PCM\nPower 1 is: 0.16000001 PCM\u00b2\nPower 2 is: -0.2 PCM\u00b2\nTempo is: 110 bpm\nReverb Beats is: 1 q.\nReverb Time is: 0.8181818 s\nPulse Per Quarter is: 960 ppqn\nTransport Position is: 15836 p\nTransport Beats is: 16.495832 q\nTransport Time is: 8.997726 s\n</code></pre> <p>Info</p> <p>More about this example can be found in \"Exploration of Strongly-typed Units in C++: A Case Study from Digital Audio\" CppCon 2023 talk by Roth Michaels.</p>"},{"location":"blog/2024/11/04/international-system-of-quantities-isq-part-5---benefits/#to-be-continued","title":"To be continued...","text":"<p>In the next part of this series, we will discuss the challenges and issues related to the modeling of the ISQ with a programming language.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/","title":"International System of Quantities (ISQ): Part 6 - Challenges","text":"<p>This article might be the last one from our series. This time, we will discuss the challenges and issues with modeling of the ISQ in software.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#articles-from-this-series","title":"Articles from this series","text":"<ul> <li>Part 1 - Introduction</li> <li>Part 2 - Problems when ISQ is not used</li> <li>Part 3 - Modeling ISQ</li> <li>Part 4 - Implementing ISQ</li> <li>Part 5 - Benefits</li> <li>Part 6 - Challenges</li> </ul>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#ambiguity","title":"Ambiguity","text":"<p>Some quantity names are ambiguous. It is not a problem of ISQ but of the English language and the way we communicate things. When I say: \"Every width is a length, but not every length is a width\" most people understand this right away. However, the same people trying to model our 3D box problem try to do it as follows:</p> <pre><code>class Box {\n  quantity&lt;isq::length[m]&gt; length_;\n  quantity&lt;isq::width[m]&gt; width_;\n  quantity&lt;isq::height[m]&gt; height_;\npublic:\n  // ...\n};\n</code></pre> <p>This looks correct at first sight. Only when we think about the sentence mentioned above will we realize that this implementation has a problem. We intended to specify three orthogonal dimensions of the box, each of which will be a strong quantity that is not convertible to others. But we've failed.</p> <p>When we look at the tree of quantities of length we immediately see that both width and height are special lengths so they are convertible to it.</p> <p>To implement our task correctly, we had to define and use a new quantity of kind length:</p> <pre><code>inline constexpr struct horizontal_length final : quantity_spec&lt;isq::length&gt; {} horizontal_length;\n</code></pre> <p>We do not propose adding horizontal length to ISO 80000-3. There are probably other similar cases as well, but so far, this was the most common and obvious one we've encountered.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#no-common-quantities","title":"No common quantities","text":"<p>ISO 80000-1:2009 explicitly states:</p> <p>Quote</p> <p>Two or more quantities cannot be added or subtracted unless they belong to the same category of mutually comparable quantities.</p> <p>This means that we should be able to add and subtract any quantities as long as they belong to the same kind. However, ISO/IEC documents do not provide any rules or even hints about what should be the result of such operations.</p> <p>If it is possible to add radius and distance, then what quantity should be provided in return? Undoubtedly, the resulting quantity type can't be the same as any of the arguments. It is not a radius or distance. It is some closer unspecified length, though.</p> <p>Info</p> <p>Finding the correct solution took us many months of experimentation and implementation. Based on the hierarchy tree of quantities, we can define conversion rules and what a common quantity should be.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#lack-of-consistency","title":"Lack of consistency","text":"<p>The documents of ISO/IEC 80000 are not 100% consistent, and programming languages do not like inconsistencies.</p> <p>For example:</p> <ul> <li>time is mentioned as a base quantity of ISQ in ISO 80000-1 chapter 4.5.</li> <li> <p>ISO 80000-3 \"Space and time\", does not define a quantity of time. It provides a duration   quantity (item 3-9) with symbol t, and states in the Remarks section:</p> <p>Quote</p> <p>Duration is often just called time.</p> </li> <li> <p>Other parts (e.g., IEC 80000-6 \"Electromagnetism\") often say:</p> <p>Quote</p> <p>... t is time (ISO 80000-3)</p> </li> </ul> <p>To be consistent, ISO/IEC should either:</p> <ul> <li>change ISO 80000-1 chapter 4.5 and all references in other parts to use duration (unlikely),</li> <li>or add time as an alias name to duration in the definition 3-9 of ISO 80000-3.</li> </ul>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#lack-of-definitions","title":"Lack of definitions","text":"<p>ISQ defines derived quantities in terms of other quantities provided in the series. However, some definitions mention quantities that are not defined in the ISQ at all.</p> <p>For example, weight is defined as \\(F_\\textsf{g} = m\\;g\\), where \\(m\\) is the mass of the body (item 4-1 of ISO 80000-4 \"Mechanics\"), and \\(g\\) is the local acceleration of free fall (ISO 80000-3).</p> <p>The problem here is that ISO 80000-3 never defines a quantity with a symbol \\(g\\) or named as a local acceleration of free fall. The closest one we have is acceleration (item 3-11) with a symbol \\(a\\).</p> <p>Info</p> <p>To have a proper definition of weight in mp-units that is not defined in terms of just any kind of acceleration, we have added <code>isq::acceleration_of_free_fall</code> in our definitions as an extension to the original ISQ set of quantities.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#not-engineering-friendly","title":"Not engineering-friendly","text":"<p>Many quantities have proper physical definitions, but they are sometimes not engineering-friendly.</p> <p>For example, velocity is defined as a rate of change of position vector \\(v = \\frac{\\textsf{d}r}{\\textsf{d}t}\\), where \\(r\\) denotes the position vector (item 3\u20111.10) and \\(t\\) the duration (item 3\u20119).</p> <p>Next, a speed quantity is defined as the magnitude of velocity. Despite being physically correct, requiring every speed to be derived from the vector quantity of velocity in software would be inconvenient. If this was the only case, people would always need to use vector representations of position vectors to talk about speeds, which differs from what we do in practice. In practice, we divide any kind of length by time to get some kind of speed.</p> <p>ISO 80000-3 provides length, height, distance and other quantities of kind length that when divided by duration can serve really well to calculate speed.</p> <p>Info</p> <p>This is why in mp-units, we decided to divert from the official definition of speed and define it as:</p> <pre><code>inline constexpr struct speed : quantity_spec&lt;speed, length / time&gt; {} speed;\n</code></pre> <p>This allows us to create a quantity of kind speed from any quantity of length divided by time.</p> <p>Additionally, it is essential to note that for the needs of our library, defining velocity as <code>position_vector / duration</code> would be wrong. We miss the delta part here. Even though it is not mentioned in ISO 80000-3, the delta of position vectors is actually a displacement. This is why our velocity is defined as:</p> <pre><code>inline constexpr struct velocity : quantity_spec&lt;speed, displacement / duration&gt; {} velocity;\n</code></pre> <p>Please also note that velocity is defined as a more specialized quantity of speed.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#affine-space-agnostic","title":"Affine space agnostic","text":"<p>The affine space is a powerful abstraction, allowing us to model some problems safer or more accurately. It has two types of entities:</p> <ul> <li>point - a position specified with coordinate values (e.g., location, address, etc.),</li> <li>displacement vector - the difference between two points (e.g., shift, offset, displacement,   duration, etc.).</li> </ul> <p>Vectors support all the arithmetics operations, but points have some limitations. It is not possible to:</p> <ul> <li>add two points,</li> <li>subtract a point from a vector,</li> <li>multiply nor divide points with anything else.</li> </ul> <p>ISO/IEC series does not acknowledge this abstraction even though it would be really useful in some cases. Let's discuss the following two examples.</p> <p>What does it mean to add two altitudes? It is not meaningful. On the other hand, subtracting those should not result in an altitude, but in a quantity of height. Adding or subtracting height to/from altitude results in altitude. Subtracting altitude from height is meaningless again. Those quantities clearly model affine space. Maybe this is why ISQ defines them as one quantity type height/depth/altitude?</p> <p>What does it mean to add two position vectors? It is not meaningful again. However, subtracting those results in a displacement as we noted in the previous chapter. Adding or subtracting displacement to/from position vector results in another position vector, and subtracting position vector from displacement does not have physical sense. Again, those quantities perfectly model affine space. However, this time, those are defined as separate and independent quantities (i.e., displacement is not modeled as delta position vector or position vector is not modeled as a displacement from the origin of a coordinate system).</p> <p>Info</p> <p>Currently, mp-units does not enforce the affine space behavior for such quantities. Today, subtracting two altitudes result in an altitude and subtracting two position vectors result in a position vector. However, we plan to support automatic conversion to a proper quantity type on subtraction and addition shortly.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#non-negative-quantities","title":"Non-negative quantities","text":"<p>Some quantities in the ISQ are defined as non-negative. This is a really interesting property that may be checked at runtime to increase safety. However, the number of such quantities is minimal. From a few hundred quantities provided by the ISO/IEC series, only the following have this property mentioned explicitly:</p> <ul> <li>width/breadth,</li> <li>thickness,</li> <li>diameter,</li> <li>radius.</li> </ul> <p>If height was defined separately from altitude, it could probably also join this group.</p> <p>Let's think a bit more about this. What does it mean that a quantity is non-negative? Indeed, it is hard to imagine something of a negative width or radius. However, if we subtract two widths, the second one may be larger. This will result in a negative quantity of width, violating our precondition. So, is it non-negative or not?</p> <p>Again, we have to talk about the affine space abstractions. Every empirical measurement can be expressed as a point. Such points for some quantities may be non-negative indeed.</p> <p>Non-negative quantities do not end on the ones provided above. For example, speed is a good example here as well. In general, all magnitudes of vector quantities will also have this property.</p> <p>When subtracting two points, we end up with a delta/displacement type, which may be negative even for quantities listed as non-negative in the ISQ. As stated in the previous chapter, having affine space abstractions acknowledged in ISQ would greatly help here.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#lack-of-quantity-recipes","title":"Lack of quantity recipes","text":"<p>Definition of many derived quantities provides their recipes in the form of quantity equations (e.g., weight equation in the previous chapter). However, some of them do not. Instead, they often provide a very generic description.</p> <p>For example, force is defined as:</p> <p>Quote</p> <p>vector (ISO 80000-2) quantity describing interaction between bodies or particles.</p> <p>This is not helpful for programming languages that like explicit definitions. Different vendors may interpret the above differently, which will result in different implementations that will not be compatible with each other.</p> <p>As the derived quantity of force has to be a vector quantity, it has to be defined in terms of at least one other vector quantity. We have a few to choose from:</p> <ul> <li>displacement (\\(\\Delta{r}\\)),</li> <li>velocity (\\(v\\)),</li> <li>acceleration (\\(a\\)).</li> </ul> <p>It is not stated explicitly in ISQ which one of those should be used and how.</p> <p>Info</p> <p>In mp-units we decided to define force as \\(F = m\\;a\\).</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#lack-of-generic-quantities-and-name-conflicts","title":"Lack of generic quantities and name conflicts","text":"<p>In the previous chapter, we complained about some definitions needing to be more complex or generic. On the other hand, we also lack some generic quantities in ISQ that could serve as a root for a quantity hierarchy tree.</p> <p>For example:</p> <ul> <li>ISO 80000-4 \"Mechanics\" defines power &lt;mechanics&gt; as \\(P = F\\;v\\) (scalar product of force \\(F\\)   (item 4-9.1) acting to a body and its velocity \\(v\\) (ISO 80000-3)),</li> <li>ISO 80000-6 \"Electromagnetism\" defines power as \\(p = u\\;i\\) (scalar quantity given by the   product of instantaneous voltage \\(u\\) (item 6-11.3) and instantaneous electric current \\(i\\)   (item 6-1)).</li> </ul> <p>First, the above definitions have somehow conflicting names which makes it hard for the programming languages to name them consistently by different vendors.</p> <p>Info</p> <p>In mp-units, we chose <code>mechanical_power</code> and <code>electromagnetism_power</code> for those.</p> <p>Second, we do not have any other more generic definition of power to put above those in the tree. Not having it makes it hard to answer what should be the result of:</p> <pre><code>quantity q = isq::mechanical_power(42 * W) + isq::electromagnetism_power(60 * W);\n</code></pre> <p>Info</p> <p>To solve the above problem, we have added <code>isq::power</code> in mp-units, that has a really generic definition of:</p> <pre><code>inline constexpr struct power : quantity_spec&lt;mass* pow&lt;2&gt;(length) / pow&lt;3&gt;(time)&gt; {} power;\n</code></pre>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#invalid-definitions-order","title":"Invalid definitions order","text":"<p>Energy is defined a bit better than power, but still not without issues.</p> <p>The first time ISQ mentions energy is in the ISO 80000-4 \"Mechanics\". It defines potential energy, kinetic energy, and a mechanical energy as the sum of the first two. Right after that a mechanical work/work is defined.</p> <p>Then ISO 80000-5 \"Thermodynamics\" defines energy &lt;thermodynamics&gt; as:</p> <p>Quote</p> <p>ability of a system to do work (ISO 80000-4).</p> <p>Next, internal energy/thermodynamic energy is defined in terms of the change of heat.</p> <p>From the above, it seems that what is called energy &lt;thermodynamics&gt; should actually be the root of our tree and probably be provided in Part 4 before the mechanical energy is defined.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#hierarchies-of-derived-quantities","title":"Hierarchies of derived quantities","text":"<p>Derived quantities of the same kind are often independently defined in the ISQ. The ISO/IEC 80000 series often does not suggest any hierarchy between those. Even more, it states:</p> <p>ISO/IEC Guide 99</p> <p>The division of \u2018quantity\u2019 according to \u2018kind of quantity\u2019 is, to some extent, arbitrary.</p> <p>Because of this, it is unknown or ambiguous how to form a hierarchy tree for such quantities.</p> <p>To get some sense of the complexity here, let's look again at our tree of quantities of a kind energy:</p> <pre><code>flowchart TD\n    energy[\"&lt;b&gt;energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * length&lt;sup&gt;2&lt;/sup&gt; / time&lt;sup&gt;2&lt;/sup&gt;)&lt;/i&gt;&lt;br&gt;[J]\"]\n    energy --- mechanical_energy[\"&lt;b&gt;mechanical_energy&lt;/b&gt;\"]\n    mechanical_energy --- potential_energy[\"&lt;b&gt;potential_energy&lt;/b&gt;\"]\n    mechanical_energy --- kinetic_energy[\"&lt;b&gt;kinetic_energy&lt;/b&gt;\"]\n    energy --- enthalpy[\"&lt;b&gt;enthalpy&lt;/b&gt;\"]\n    enthalpy --- internal_energy[\"&lt;b&gt;internal_energy&lt;/b&gt; / &lt;b&gt;thermodynamic_energy&lt;/b&gt;\"]\n    internal_energy --- Helmholtz_energy[\"&lt;b&gt;Helmholtz_energy&lt;/b&gt; / &lt;b&gt;Helmholtz_function&lt;/b&gt;\"]\n    enthalpy --- Gibbs_energy[\"&lt;b&gt;Gibbs_energy&lt;/b&gt; / &lt;b&gt;Gibbs_function&lt;/b&gt;\"]\n    energy --- active_energy[\"&lt;b&gt;active_energy&lt;/b&gt;\"]</code></pre> <p>Not being exact means that every vendor may implement it differently. This will result in:</p> <ul> <li> <p>different convertibility rules among quantities:</p> <pre><code>static_assert(implicitly_convertible(isq::potential_energy, isq::mechanical_energy));\nstatic_assert(explicitly_convertible(isq::mechanical_energy, isq::potential_energy));\n</code></pre> </li> <li> <p>different common quantities resulting from the arithmetics on various quantities of the same   kind:</p> <pre><code>static_assert((isq::potential_energy(1 * J) + isq::kinetic_energy(1 * J)).quantity_spec == isq::mechanical_energy);\n</code></pre> </li> </ul> <p>It would be great if ISQ could provide specific division of quantities into kinds and more information about the position of each quantity within the hierarchy of quantities of the same kind.</p> <p>Important</p> <p>We can try to do this by ourselves, but it is tough. Probably no one, for sure we are not, is an expert in all the fields of ISO/IEC 80000 applicability.</p> <p>We need the help of subject matter experts who will help us build those trees for their domains and then verify that everything works as expected.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#the-same-or-a-different-kind","title":"The same or a different kind?","text":"<p>Some quantities are more complicated than others. For example, power has:</p> <ul> <li>real scalar quantities expressed in:<ul> <li>W (watts) (e.g., mechanical power, active power),</li> <li>VA (volt-ampere) (e.g., apparent power),</li> <li>var (e.g., reactive power),</li> </ul> </li> <li>complex scalar quantities expressed in VA (volt-ampere) (e.g., complex power).</li> </ul> <p>How should we model this? Maybe those should be two or three independent trees of quantities, each having its own unit?</p> <pre><code>flowchart TD\n    power[\"&lt;b&gt;power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * length&lt;sup&gt;2&lt;/sup&gt; / time&lt;sup&gt;3&lt;/sup&gt;)&lt;/i&gt;&lt;br&gt;[W]\"]\n    power --- mechanical_power[\"&lt;b&gt;mechanical_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(scalar_product(force, velocity))&lt;/i&gt;\"]\n    power --- electromagnetism_power[\"&lt;b&gt;electromagnetism_power&lt;/b&gt; | &lt;b&gt;instantaneous_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(instantaneous_voltage * instantaneous_electric_current)&lt;/i&gt;\"]\n    power --- active_power[\"&lt;b&gt;active_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(1 / period * instantaneous_power * time)&lt;br&gt;(re(complex_power))&lt;/i&gt;\"]\n\n    nonactive_power[\"&lt;b&gt;nonactive_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * length&lt;sup&gt;2&lt;/sup&gt; / time&lt;sup&gt;3&lt;/sup&gt;)&lt;/i&gt;&lt;br&gt;[VA]\"]\n    nonactive_power --- reactive_power[\"&lt;b&gt;reactive_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(im(complex_power))&lt;/i&gt;&lt;br&gt;[var]\"]\n\n    complex_power[\"&lt;b&gt;complex_power&lt;/b&gt;&lt;br&gt;{complex}&lt;br&gt;&lt;i&gt;(voltage_phasor * electric_current_phasor)&lt;br&gt;(active_power + j * reactive_power)&lt;/i&gt;&lt;br&gt;[VA]\"]\n    complex_power --- apparent_power[\"&lt;b&gt;apparent_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(voltage * electric_current)&lt;br&gt;(mod(complex_power))&lt;/i&gt;\"]</code></pre> <p>This will mean that we will not be able to add or compare active power, reactive power, and apparent power, which probably makes a lot of sense. However, it also means that the following will fail to compile:</p> <pre><code>quantity apparent = isq::apparent_power(100 * VA);\nquantity active = isq::active_power(60 * W);\nquantity&lt;isq::nonactive_power[VA]&gt; q = sqrt(pow&lt;2&gt;(apparent) - pow&lt;2&gt;(active)); // Compile-time error\n</code></pre> <p>Also the following will not work:</p> <pre><code>quantity active = isq::active_power(60 * W);\nquantity reactive = isq::reactive_power(40 * var);\nquantity&lt;isq::apparent_power[VA]&gt; q = sqrt(pow&lt;2&gt;(active) + pow&lt;2&gt;(reactive)); // Compile-time error\n</code></pre> <p>If we want the above to work maybe we need to implement the tree as follows?</p> <pre><code>flowchart TD\n    power[\"&lt;b&gt;power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * length&lt;sup&gt;2&lt;/sup&gt; / time&lt;sup&gt;3&lt;/sup&gt;)&lt;/i&gt;&lt;br&gt;[W]\"]\n    power --- mechanical_power[\"&lt;b&gt;mechanical_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(scalar_product(force, velocity))&lt;/i&gt;\"]\n    power --- electromagnetism_power[\"&lt;b&gt;electromagnetism_power&lt;/b&gt; | &lt;b&gt;instantaneous_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(instantaneous_voltage * instantaneous_electric_current)&lt;/i&gt;\"]\n    power --- apparent_power[\"&lt;b&gt;apparent_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(voltage * electric_current)&lt;br&gt;(mod(complex_power))&lt;/i&gt;&lt;br&gt;[VA]\"]\n    apparent_power --- active_power[\"&lt;b&gt;active_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(1 / period * instantaneous_power * time)&lt;br&gt;(re(complex_power))&lt;/i&gt;\"]\n    apparent_power --- nonactive_power[\"&lt;b&gt;nonactive_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(sqrt(apparent_power&lt;sup&gt;2&lt;/sup&gt; - active_power&lt;sup&gt;2&lt;/sup&gt;))&lt;/i&gt;&lt;br&gt;\"]\n    nonactive_power --- reactive_power[\"&lt;b&gt;reactive_power&lt;/b&gt;&lt;br&gt;&lt;i&gt;(im(complex_power))&lt;/i&gt;&lt;br&gt;[var]\"]\n    apparent_power --- complex_power[\"&lt;b&gt;complex_power&lt;/b&gt;&lt;br&gt;{complex}&lt;br&gt;&lt;i&gt;(voltage_phasor * electric_current_phasor)&lt;br&gt;(active_power + j * reactive_power)&lt;/i&gt;\"]</code></pre> <p>However, the above allows direct addition and comparison of active power and nonactive power, and also will not complain if someone will try to use watt (W) as a unit of apparent power or reactive power.</p> <p>Again, ISQ does not provide a direct answer here.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#more-base-quantities","title":"More base quantities?","text":"<p>Is ISQ really based on only seven base quantities? Let's look at the definition of traffic intensity in IEC 80000-13 \"Information science and technology\":</p> <p>Quote</p> <p>number of simultaneously busy resources in a particular pool of resources.</p> <p>It looks like a definition of a specialized dimensionless quantity or, more correctly, a quantity of dimension one. This would not be the only such case. Even in the same Part 13, we can find quantities like storage capacity with a similar property.</p> <p>Only when we look closer do we start to see differences. All dimensionless quantities, even if they have their own dedicated units, can also be measured in a unit of one (1). This is true for storage capacity (also measured in bits), angular measure (also measured in radians), _solid angular measure (also measured in steradians), and more.</p> <p>However, traffic intensity can only be measured in erlangs (E), not in a unit one (1). Does it mean that it is a \"hidden\" 8-th base quantity in ISQ? If so, should it have its own dimension as well?</p> <p>Angular quantities are another interesting case here. Scientists have written petitions and papers for years to make them an additional dimension in ISQ and SI. More about this can be found in our documentation's Strong Angular System chapter.</p>"},{"location":"blog/2024/11/11/international-system-of-quantities-isq-part-6---challenges/#summary","title":"Summary","text":"<p>ISQ is tremendous and solves many problems we had in modeling various subjects for years in software. As a result, we have more powerful tools in our hands that allow us to deliver safer products.</p> <p>Unfortunately, ISQ, contrarily to SI, is not widely recognized, and no libraries besides mp-units model it in any programming language. Keeping it behind a paywall does not help either. We hope that posts from this series will spread in the community, raise awareness of ISQ and its benefits, and encourage authors of other libraries to implement it in their products.</p> <p>Despite all the benefits, it is essential to realize that ISQ has many problems. International standards should be specified in such a way that there is no room for ambiguity in their interpretation by different parties trying to use them. As described above, this is not the case here.</p> <p>ISQ is not ready to be unambiguously modeled in software by various vendors. Here are the most important problems to solve to allow this:</p> <ol> <li>ISQ needs to define basic operations on quantities:</li> </ol> <p>- what the result of addition and subtraction should be when arguments differ, \u00a0 \u00a0 - convertibility rules.</p> <ol> <li>The exact quantity equation recipe needs to be included for many derived quantities.</li> <li>Many ISQ quantities do not provide their exact relation versus other quantities of the same    kind (no strict hierarchy).</li> <li>Some missing quantities need to be included. Others would benefit from corrected names.</li> </ol> <p>Additionally:</p> <ul> <li>extending ISQ with affine space abstractions,</li> <li>specifying more quantities as non-negative,</li> <li>adding more base quantities (i.e., angle)</li> </ul> <p>could improve the safety of our programs and products that people depend on with their lives on a daily basis.</p> <p>I hope you enjoyed following this series and learned more about the International System of Quantities. Please try it out in your domain and share feedback with us. We always love to hear about the projects in which our library is being used and about use cases it helps address.</p>"},{"location":"blog/2023/11/12/report-from-the-kona-2023-iso-c-committee-meeting/","title":"Report from the Kona 2023 ISO C++ Committee meeting","text":"<p>Several groups in the ISO C++ Committee reviewed the P1935: A C++ Approach to Physical Units proposal in Belfast 2019 and Prague 2020. All those groups expressed interest in the potential standardization of such a library and encouraged further work. The authors also got valuable initial feedback that highly influenced the design of the V2 version of the mp-units library.</p> <p>In the following years, we scoped on getting more feedback from the production and design. This resulted in version 2 of the mp-units library that resolved many issues the users and Committee members raised. The features and interfaces of this version are close to being the best we can get with the current version of the C++ language standard.</p> <p>We submitted three new proposals related to the standardization of the quantities and units library for the last ISO C++ Committee meeting:</p> <ul> <li>P2980: A motivation, scope, and plan for a physical quantities and units library,</li> <li>P2981: Improving our safety with a physical quantities and units library,</li> <li>P2982: <code>std::quantity</code> as a numeric type.</li> </ul> <p>Those were reviewed and briefly discussed in several groups: Numerics (SG6), Safety &amp; Security (SG23), and Library Evolution Working Group (LEWG). Most of the feedback was positive, and the Committee is interested in spending more time on such proposals.</p> <p>The following poll was taken by the LEWG:</p> <p>LEWG POLL: Given that our time is limited, more time should be promised for a quantities and units library</p> Strongly in Favor In favor Neutral Against Strongly Against 10 13 4 0 0 <p>Attendance: 22 + 6</p> <p>Number of Authors: 4</p> <p>Authors\u2019 position: 4x SF</p> <p>Outcome: Strong consensus in favor</p> <p>Additionally, some concerns were raised about the large scope of the proposal. We were encouraged to return with more details and design rationale in a unified paper. This is what we are working on now for the next Committee meeting that will happen in mid-March 2024 in Tokyo.</p>"},{"location":"blog/2024/07/02/report-from-the-st-louis-2024-iso-c-committee-meeting/","title":"Report from the St. Louis 2024 ISO C++ Committee meeting","text":"<p>We made significant progress in the standardization of this library during the ISO C++ Committee meeting in St. Louis.</p>"},{"location":"blog/2024/07/02/report-from-the-st-louis-2024-iso-c-committee-meeting/#p30942r3-stdbasic_fixed_string","title":"P30942R3: <code>std::basic_fixed_string</code>","text":"<p>First, the <code>fixed_string</code> was unanimously forwarded from the SG18 LEWG Incubator to the Library Evolution Working Group (LEWG). The group suggested a few minor changes to the paper, which resulted in the R3 version of the proposal.</p> <p>The paper is in excellent shape, and the entire wording is ready as well. Hopefully it will progress quickly through the remaining groups in the Committee.</p>"},{"location":"blog/2024/07/02/report-from-the-st-louis-2024-iso-c-committee-meeting/#p3045r1-quantities-and-units-library","title":"P3045R1: Quantities and units library","text":"<p>In the SG6 (Numerics), we had a really efficient discussion about the recently raised usability issues with temperatures and the Minimal Viable Product (MVP) scope.</p> <p>The following polls were taken:</p> <p>POLL: If WG21 adds anything to the standard to provide units or quantities, then such a solution must at least include the necessary abstractions for units, dimensions, and quantity kinds. (It does not have to provide system definitions, e.g. ISQ/SI definitions.)</p> Strongly in Favor In favor Neutral Against Strongly Against 7 4 7 0 0 <p>POLL: If WG21 adds anything to the standard to provide units or quantities, then such a solution must at least include the necessary abstractions for units, dimensions, quantity kinds, and quantities of the same kind. (It does not have to provide system definitions, e.g. ISQ/SI definitions.)</p> Strongly in Favor In favor Neutral Against Strongly Against 5 2 5 2 0 <p>POLL: If WG21 adds anything to the standard to provide units or quantities, then such a solution must at least include the necessary abstractions for units, dimensions, quantity kinds, and affine spaces. (It does not have to provide system definitions, e.g. ISQ/SI definitions.)</p> Strongly in Favor In favor Neutral Against Strongly Against 5 0 8 1 0 <p>As we can see, there are no controversies about the first poll that states that the MVP should include at least:</p> <ul> <li>units,</li> <li>dimensions,</li> <li>quantity kinds (e.g., frequency vs activity, plane angle vs solid angle,  fuel_consumption vs area).</li> </ul> <p>The next polls add either:</p> <ul> <li>quantities of the same kind (e.g., length vs width vs wavelength, potential energy vs kinetic energy),</li> <li>the affine space abstractions (i.e., point origins and <code>quantity_point</code>).</li> </ul> <p>SG6 considered those less important, but no one was strongly against including those in the MVP. We were asked to return with better motivation and usage examples for those features.</p> <p>If you are depending on quantities of the same kind or quantity points in your project and you would like to see them in the <code>std</code> library, please let us know about your use cases.</p> <p>Besides SG6, we spent six hours in the SG18 LEWG Incubator discussing the details of the library design. The proposal was very well received, and we got a few valuable comments and suggestions that we will apply to the next version of the paper.</p>"},{"location":"blog/2024/04/15/report-from-the-tokyo-2024-iso-c-committee-meeting/","title":"Report from the Tokyo 2024 ISO C++ Committee meeting","text":"<p>The Tokyo 2024 meeting was a very important step in the standardization of this library. Several WG21 groups reviewed proposals, and the feedback was really good.</p>"},{"location":"blog/2024/04/15/report-from-the-tokyo-2024-iso-c-committee-meeting/#p3045r0-quantities-and-units-library","title":"P3045R0: Quantities and units library","text":"<p>The Study Group 6 (Numerics) discussed the proposal for several hours. The initial feedback was positive. There were some concerns related to the description and design of the affine space abstractions in the library. Besides that, the people in the room liked what they saw.</p> <p>We run a few polls in SG6 as well:</p> <p>POLL: The syntax <code>number * unit</code> is the right solution for constructing quantities. Not allowing reordering the operands is correct.</p> Strongly in Favor In favor Neutral Against Strongly Against 5 4 1 0 1 <p>POLL: Not defining any UDLs is the right solution.</p> <p>No objection to unanimous consent.</p> <p>The paper was also briefly discussed in SG18 LEWG Incubator, and the initial feedback was also positive. No polls were taken.</p> <p>SG16 Unicode does not meet during ISO C++ Committee F2F meetings. Still, the text output chapter paper was also reviewed by it during an online meeting before Tokyo. We got good feedback and are expected to return with the updated version. No polls were taken.</p>"},{"location":"blog/2024/04/15/report-from-the-tokyo-2024-iso-c-committee-meeting/#p30942r1-stdbasic_fixed_string","title":"P30942R1: <code>std::basic_fixed_string</code>","text":"<p>In the SG18 LEWG Incubator, before we started to talk about P3045R0, we spent a few hours discussing the design of the <code>std::basic_fixed_string</code>, which is proposed for C++26. The group gave excellent feedback, and if the R2 version addresses it properly, the paper is expected to progress to LEWG (Library Evolution Working Group) in St. Louis.</p> <p>Plenty of polls were taken:</p> <p>POLL: We should promise more committee time to pursuing <code>std::basic_fixed_string</code>, knowing that our time is scarce and this will leave less time for other work.</p> Strongly in Favor In favor Neutral Against Strongly Against 11 0 0 0 0 <p>POLL: Should the constructor from a string literal be <code>consteval</code>?</p> Strongly in Favor In favor Neutral Against Strongly Against 6 3 2 0 0 <p>POLL: Do we want to add <code>.view()</code>?</p> Strongly in Favor In favor Neutral Against Strongly Against 3 5 3 0 0 <p>POLL: Do we want the <code>.size</code> member to be an <code>integral_constant&lt;size_t, N&gt;</code> (and <code>.empty</code> to be <code>bool_constant&lt;N==0&gt;</code>)?</p> Strongly in Favor In favor Neutral Against Strongly Against 5 2 2 2 0 <p>POLL: Should the index <code>operator[]</code> return a reference to <code>const</code>?</p> Strongly in Favor In favor Neutral Against Strongly Against 2 2 3 3 0 <p>POLL: Should the constructor from a string literal have a precondition that <code>txt[N] == 0</code>?</p> Strongly in Favor In favor Neutral Against Strongly Against 6 1 2 0 2"},{"location":"blog/2024/11/25/report-from-the-wroc%C5%82aw-2024-iso-c-committee-meeting/","title":"Report from the Wroc\u0142aw 2024 ISO C++ Committee meeting","text":"<p>The Wroc\u0142aw 2024 meeting was another efficient step in the standardization of this library. We've spent the entire day on the joint LEWGI and SG6 discussion and got lots of feedback. We've also introduced <code>std::fixed_string</code> to LEWG for C++26.</p>"},{"location":"blog/2024/11/25/report-from-the-wroc%C5%82aw-2024-iso-c-committee-meeting/#p3045r4-quantities-and-units-library","title":"P3045R4: Quantities and units library","text":"<p>We have presented the following chapters of our proposal to LEWGI and SG6. We reviewed all the usage examples, discussed composing symbols for derived dimensions and units, and looked into formatting specifications for quantities. We also discussed the minimal scope of the proposal.</p> <p>We got plenty of feedback on:</p> <ul> <li>the paper itself,</li> <li>naming of specific entities in the library,</li> <li>usage examples,</li> <li>text output and formatting.</li> </ul> <p>We were also asked to extend the library to provide text output support for quantity points.</p> <p>You can expect all of those changes to appear in the next release.</p>"},{"location":"blog/2024/11/25/report-from-the-wroc%C5%82aw-2024-iso-c-committee-meeting/#p30942r5-stdbasic_fixed_string","title":"P30942R5: <code>std::basic_fixed_string</code>","text":"<p>The paper was well received. However, Barry Revzin submitted P3380 paper in September. This started a discussion about the scope of this proposal. Should we:</p> <ul> <li>limit it to just a non-mutating interface (as proposed) and maybe rename it to \u00a0 <code>std::string_literal</code>,</li> <li>add range slicing interface (as we support composition already),</li> <li>add some basic mutation interface through non-const <code>operator[]</code>,</li> <li>refactor to fully blown <code>std::inplace_string</code> if P3380 successfully  progresses through EWG.</li> </ul>"},{"location":"getting_started/contributing/","title":"Contributing","text":"<p>\ud83d\udc4d\ud83c\udf89 First off, thanks for taking the time to contribute! \ud83c\udf89\ud83d\udc4d</p>"},{"location":"getting_started/contributing/#mp-units-documentation","title":"mp-units documentation","text":"<p>Before contributing, it is highly recommended to familiarize yourself with our official documentation.</p> <p>This file is also a part of it, and this is why it has non-standard Markdown formatting (which can be seen when reading in a regular Markdown renderer). To benefit from full mkdocs rendering, please switch to the Contributing chapter of our documentation.</p>"},{"location":"getting_started/contributing/#where-to-start","title":"Where to start?","text":"<p>If you are looking for a good issue to start with, please check the following:</p> <ul> <li>good first issue - issues that   should be pretty simple to implement,</li> <li>help wanted - issues that typically are   a bit more involved than beginner issues,</li> <li>high priority - things to fix ASAP   but often of higher complexity.</li> </ul>"},{"location":"getting_started/contributing/#github-codespaces-development-environment","title":"GitHub Codespaces Development Environment","text":"<p>The easiest way to start coding is to use our containerized development environment in GitHub Codespaces. You can either click the button below</p> <p></p> <p>or navigate to the main page of the repository and click \"Code\" button -&gt; \"Codespaces\" tab -&gt; \"Create codespace on master\".</p> <p>You can also use the pre-configured devcontainer and Docker image manually within your IDE.</p>"},{"location":"getting_started/contributing/#environment-features","title":"Environment Features","text":"<p>The development environment is built on our custom <code>trainiteu/mp-units</code> Docker image and provides:</p>"},{"location":"getting_started/contributing/#complete-compiler-matrix","title":"\ud83d\udd27 Complete Compiler Matrix","text":"<ul> <li>GCC: 12, 13, 14, 15</li> <li>Clang: 16, 17, 18, 19, 20</li> <li>C++ versions: C++20/23/26</li> <li>Standard Libraries: libstdc++11 and libc++ for thorough testing</li> </ul>"},{"location":"getting_started/contributing/#automated-build-testing","title":"\ud83d\ude80 Automated Build &amp; Testing","text":"<ul> <li>Multi-compiler testing script: <code>.devcontainer/check_all.sh</code> tests recommended configurations</li> <li>Pre-configured Conan profiles: Ready-to-use compiler configurations</li> <li>Incremental builds: Persistent Conan cache across sessions</li> <li>Fast dependencies: Dedicated Conan Artifactory with pre-compiled packages</li> </ul>"},{"location":"getting_started/contributing/#documentation-tools","title":"\ud83d\udcd6 Documentation Tools","text":"<ul> <li>MkDocs with Material theme: Live documentation server at port 8000</li> <li>API reference generation: Standardeese-like API reference built on top of LaTex</li> <li>Python tooling: pre-commit, mike, mkdocs-material, and plugins via pipx</li> </ul>"},{"location":"getting_started/contributing/#development-tools","title":"\ud83d\udee0\ufe0f Development Tools","text":"<ul> <li>Code quality: clang-format, clang-tidy, include-what-you-use</li> <li>VS Code extensions: 20+ pre-installed extensions for C++, Python, Git</li> </ul>"},{"location":"getting_started/contributing/#quick-start-commands","title":"Quick Start Commands","text":"<pre><code># Test with a single compiler configuration\nconan build . -pr gcc14 -c user.mp-units.build:all=True -b missing\n\n# Test all compiler configurations\n.devcontainer/check_all.sh create\n\n# Generating API Reference\n.devcontainer/api_reference.sh\n\n# Build documentation locally\nmkdocs serve\n\n# Run pre-commit checks\npre-commit run --all-files\n</code></pre> <p>For detailed environment documentation and troubleshooting, see <code>.devcontainer/README.md</code>.</p>"},{"location":"getting_started/contributing/#building-testing-and-packaging","title":"Building, testing, and packaging","text":"<p>Alternatively, please refer to our official docs for download, build, and install instructions with the below changes if you want to set up a development environment on your local machine.</p>"},{"location":"getting_started/contributing/#conan-configuration-properties","title":"Conan configuration properties","text":"<code>user.mp-units.build:all</code> <p>Enables compilation of all the source code, including tests and examples. To support this, it requires some additional Conan build dependencies described in Repository directory tree and dependencies. It also runs unit tests during the Conan build (unless <code>tools.build:skip_test</code> configuration property is set to <code>True</code>).</p> <code>user.mp-units.build:skip_la</code> <p>If <code>user.mp-units.build:all</code> is enabled, among others, Conan installs the external wg21-linear_algebra dependency and enables the compilation of linear algebra-based tests and usage examples. Such behavior can be disabled with this option.</p> <code>user.mp-units.analyze:clang-tidy</code> <p>Enables clang-tidy analysis.</p>"},{"location":"getting_started/contributing/#cmake-options-for-mp-units-project-developers","title":"CMake options for mp-units project developers","text":"<code>MP_UNITS_DEV_IWYU</code> <p> 2.2.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>OFF</code>)</p> <p>Enables include-what-you-use analysis.</p> <code>MP_UNITS_DEV_CLANG_TIDY</code> <p> 2.2.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>OFF</code>)</p> <p>Enables clang-tidy analysis.</p> <code>MP_UNITS_DEV_TIME_TRACE</code> <p> 2.5.0 \u00b7  <code>NONE</code>/<code>ALL</code>/<code>MODULES</code>/<code>HEADERS</code> (Default: <code>NONE</code>)</p> <p>Enables compilation performance data collection with <code>-ftime-trace</code> for clang compilers.</p> <p>All our unit tests compile only for headers and never for modules. To allow fair comparison, <code>MODULES</code> and <code>HEADERS</code> do not enable the data collection for unit tests. This means that they affect only the core, systems, and examples.</p> <p>Please use <code>ALL</code> to profile unit tests as well.</p>"},{"location":"getting_started/contributing/#building-the-entire-repository","title":"Building the entire repository","text":"<p>To build all the mp-units source code (with unit tests and examples), you should:</p> <ol> <li>Use the CMakeLists.txt from the top-level directory.</li> <li>Run Conan with <code>user.mp-units.build:all</code> = <code>True</code>.</li> </ol> <pre><code>git clone https://github.com/mpusz/mp-units.git &amp;&amp; cd mp-units\nconan build . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=23 -c user.mp-units.build:all=True -b missing\n</code></pre> <p>The above will download and install all of the dependencies needed for the development of the library, build all of the source code, and run unit tests.</p> <p>If you prefer to build the project via CMake rather than Conan, then you should replace the <code>conan build</code> with <code>conan install</code> command and then follow with a regular CMake build and testing:</p> <pre><code>conan install . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=23 -c user.mp-units.build:all=True -b missing\ncmake --preset conan-default\ncmake --build --preset conan-release\ncmake --build --preset conan-release --target all_verify_interface_header_sets\ncmake --build --preset conan-release --target test\n</code></pre> <p>Hint</p> <p>To ensure that we always build all the targets and to save some typing of the Conan commands, we can set the following in the <code>~/.conan2/global.conf</code>:</p> <pre><code>user.mp-units.build:all=True\n</code></pre>"},{"location":"getting_started/contributing/#packaging","title":"Packaging","text":"<p>To test CMake installation and Conan packaging run:</p> <pre><code>conan create . --user &lt;username&gt; --channel &lt;channel&gt; -pr &lt;your_conan_profile&gt; -s compiler.cppstd=23 \\\n               -c user.mp-units.build:all=True -b missing\n</code></pre> <p>The above will create a Conan package and run tests provided in ./test_package directory.</p> <p>In case you would like to upload mp-units package to the Conan server, do the following:</p> <pre><code>conan upload -r &lt;remote-name&gt; --all mp-units/2.2.0@&lt;user&gt;/&lt;channel&gt;\n</code></pre>"},{"location":"getting_started/contributing/#building-documentation","title":"Building documentation","text":"<p>We are building our documentation using Material for MkDocs. The easiest way to install all the required dependencies is with <code>pip</code>:</p> <pre><code>pip install -U mkdocs-material mkdocs-rss-plugin\n</code></pre> <p>Additionally, a Cairo Graphics library is required by Material for MkDocs. Please follow the official MkDocs documentation to install it.</p> <p>After that, you can either:</p> <ul> <li> <p>easily start a live server to preview the documentation as you write</p> <pre><code>mkdocs serve\n</code></pre> </li> <li> <p>build the documentation</p> <pre><code>mkdocs build\n</code></pre> </li> </ul>"},{"location":"getting_started/contributing/#generating-api-reference","title":"Generating API reference","text":"<p>We need to take a few steps to set up our environment so that we are ready to generate API reference documents.</p> <p>First, we need to satisfy the requirements described in https://github.com/cplusplus/draft and https://github.com/Eelis/cxxdraft-htmlgen. On the Ubuntu platform, this is equivalent to the following instructions run from the user's home directory:</p> <pre><code>sudo apt install latexmk texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended lmodern\nsudo apt install haskell-stack graphviz nodejs npm ghc cabal-install\nnpm install split mathjax-full mathjax-node-sre mathjax-node-cli yargs@16.2.0\ncabal update\n</code></pre> <p>On some platforms, installing <code>mathjax-node-cli</code> through <code>npm</code> does not update the system's <code>PATH</code> environment variable resulting in <code>tex2html</code> not found errors. In such cases we need to add the <code>.bin</code> folder to the <code>PATH</code> environment variable manually:</p> <pre><code>echo \"export PATH=\\\"~/node_modules/.bin:\\$PATH\\\"\" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc\n</code></pre> <p>Now, we are ready to start building our API reference using our automated script:</p> <pre><code>.devcontainer/api_reference.sh\n</code></pre> <p>This script will: - Configure CMake with the correct module paths - Build both PDF and HTML documentation - Create a symlink to the generated documentation</p> <p>If you only want to setup CMake without building the documentation, use:</p> <pre><code>.devcontainer/api_reference.sh -s\n</code></pre>"},{"location":"getting_started/contributing/#custom-dependency-directory","title":"Custom Dependency Directory","text":"<p>By default, the script downloads dependencies to <code>../api_reference_deps</code> relative to the project root. You can specify a custom directory using the <code>-d</code> parameter:</p> <pre><code># Use a custom directory for dependencies\n.devcontainer/api_reference.sh -d /path/to/custom/deps\n\n# Combine with setup-only mode\n.devcontainer/api_reference.sh -s -d ./local_deps\n</code></pre> <p>The dependency directory will contain: - <code>jegp.cmake_modules</code>: CMake modules for documentation generation - <code>draft</code>: C++ standard draft sources for reference formatting - <code>cxxdraft-htmlgen</code>: HTML generation tools for standardese-style output</p> <p>This is useful when you want to: - Share dependencies across multiple project checkouts - Use a specific location with faster disk access - Avoid re-downloading dependencies for development containers</p>"},{"location":"getting_started/contributing/#manual-documentation-generation","title":"Manual documentation generation","text":"<p>Alternatively, you can run the individual steps manually.</p> <p>First, we need to clone the following git repositories:</p> <ul> <li>https://github.com/JohelEGP/jegp.cmake_modules</li> <li><code>standardese_sources_base</code> branch of https://github.com/JohelEGP/draft</li> <li><code>standardese_sources_base</code> branch of https://github.com/JohelEGP/cxxdraft-htmlgen</li> </ul> <p>For example:</p> <pre><code>git clone https://github.com/JohelEGP/jegp.cmake_modules.git --depth=1\ngit clone https://github.com/JohelEGP/draft.git --branch=standardese_sources_base --depth=1\ngit clone https://github.com/JohelEGP/cxxdraft-htmlgen.git --branch=standardese_sources_base --depth=1\n</code></pre> <p>Next, configure CMake with the following:</p> <pre><code>cmake -S docs/api_reference/src -B build/docs/api_reference -DCMAKE_MODULE_PATH=\"/workspaces/api_reference_deps/jegp.cmake_modules/modules\" -DJEGP_STANDARDESE_SOURCES_GIT_REPOSITORY=\"/workspaces/api_reference_deps/draft\" -DJEGP_CXXDRAFT_HTMLGEN_GIT_REPOSITORY=\"/workspaces/api_reference_deps/cxxdraft-htmlgen\"\n</code></pre> <p>Then build the documentation with CMake:</p> <pre><code>cmake --build build/docs/api_reference\n</code></pre> <p>The generated documentation will be available at: - PDF: <code>build/docs/api_reference/mp-units.pdf</code> - HTML: <code>build/docs/api_reference/mp-units.html/</code></p> <p>In the end, we need to move the generated documentation to the <code>docs/api_reference/gen</code> subdirectory:</p> <pre><code>mv build/docs/api_reference/mp-units.html docs/api_reference/gen\n</code></pre> <p>or just link the entire directory:</p> <pre><code>ln -sf ../../build/docs/api_reference/mp-units.html docs/api_reference/gen\n</code></pre>"},{"location":"getting_started/contributing/#before-committing-git-changes","title":"Before committing git changes","text":"<p>There are a few steps recommended to check before committing and pushing your changes to the git repository.</p>"},{"location":"getting_started/contributing/#naming-conventions","title":"Naming conventions","text":"<p>Here are the main rules for naming things in this repo:</p> <ul> <li>types, functions, variables use <code>standard_case</code>,</li> <li>template parameters use <code>PascalCase</code>,</li> <li>C++ concept names, for now, use <code>PascalCase</code>, but we plan to change it  (see GitHub Issue #93 for more details).</li> </ul>"},{"location":"getting_started/contributing/#unified-code-formatting","title":"Unified code formatting","text":"<p>A formatting standard is enforced with the <code>pre-commit</code> script. Before committing your changes, please do the following:</p> <pre><code>pip install -U pre-commit\npre-commit run --all-files\n</code></pre> <p>This will run:</p> <ul> <li><code>clang-format</code> for code formatting with the <code>.clang-format</code> file provided in the repo,</li> <li><code>cmake-format</code> to format the CMake files,</li> <li>some other checks (e.g., python script checkers, whitespaces, etc.).</li> </ul> <p>The script will run on all the files in the repo and will apply the changes in place when needed. After the script is done, please make sure to review and stage all those changes for the git commit.</p>"},{"location":"getting_started/contributing/#backward-compatibility","title":"Backward compatibility","text":"<p>Before submission, please remember to check if the code compiles fine on the supported compilers. The CI will check it anyway, but it is good to check at least some of the configurations before pushing changes. Especially older compilers can be tricky as those do not have full C++20 conformance. The official list of supported compilers can always be found in the C++ compiler support (API/ABI) chapter of our documentation.</p>"},{"location":"getting_started/contributing/#multi-compiler-testing","title":"Multi-Compiler Testing","text":"<p>In GitHub Codespaces, you can use the <code>.devcontainer/check_all.sh</code> script to test your changes across all supported compiler configurations:</p> <pre><code># Test with all compilers (release builds only)\n.devcontainer/check_all.sh create\n\n# Include debug builds as well\n.devcontainer/check_all.sh -d create\n\n# Just build without creating packages\n.devcontainer/check_all.sh build\n\n# Install dependencies only\n.devcontainer/check_all.sh install\n</code></pre> <p>This script tests a similar compiler matrix to the one used in CI, ensuring your changes work across:</p> <ul> <li>GCC 12, 13, 14 with different C++ standards and feature combinations</li> <li>Clang 16, 17, 18, 20 with libstdc++ and libc++</li> <li>Various build configurations (modules, <code>import std</code>, <code>std::format</code>, contracts)</li> </ul>"},{"location":"getting_started/cpp_compiler_support/","title":"C++ compiler support (API/ABI)","text":"<p>Info</p> <p>mp-units library tries to provide the best user experience possible with the C++ language. To achieve that, it extensively uses the latest C++ language features.</p> <p>Even though the library benefits from the latest C++ versions (if available), C++20 is enough to compile and use all of the library's functionality. Newer features can be hidden behind some preprocessor macros providing a backward-compatible way to use them.</p> <p>The table below provides the minimum compiler version required to compile the code using a specific C++ feature:</p> C++ Feature C++ version gcc clang apple-clang MSVC Minimum support 20 12+ 16+ &amp;&amp; !19 15+ 194+  <code>std::format</code> 20 13+ 17+ 16+ 194+ C++ modules 20 None 17+ None None <code>import std;</code> 23 None 18+ None None Explicit <code>this</code> parameter 23 14+ 18+ None None clang-19 unfixable bug <p>Unfortunately, clang-19 does not build mp-units because of an unfixable bug in the compiler.</p> MSVC bugs <p>MSVC still has a poor C++20 conformance. We had to make many workarounds to our codebase to make it compile on this compiler. Usage of such nasty preprocessor macros degrade the readability and maintainability of our code. This is why we've applied those patches to the main library code but not to unit tests and examples. Those still do not compile on MSVC.</p> <p>Here is a list of the most important MSVC bugs:</p> <ul> <li>Syntax error when using non-type template parameters in templated class member function</li> <li>Type always preferred over value when using qualified identifiers</li> </ul> <p>Please upvote them so they get a higher fixing priority at Microsoft.</p> <p>Important</p> <p>Enabling/disabling features listed above may influence the API of the library and the ABI of the customers' projects.</p>"},{"location":"getting_started/cpp_compiler_support/#stdformat","title":"<code>std::format</code>","text":"<ul> <li>Provides powerful text formatting capabilities   for C++.</li> <li>An alternative fmtlib library can be used instead if<ul> <li>the C++ language feature is not supported,</li> <li>the customer's project did not switch to <code>std::format</code> yet (even when the compiler   supports it).</li> </ul> </li> <li>To write code with wide compatibility   a dedicated macro may be used.</li> <li>Tested with <code>__cpp_lib_format</code> feature test macro.</li> <li>Related build options:<ul> <li>Conan: std_format</li> <li>CMake: MP_UNITS_API_STD_FORMAT</li> </ul> </li> </ul>"},{"location":"getting_started/cpp_compiler_support/#c-modules","title":"C++ modules","text":"<ul> <li>Provide new way to share declarations and definitions across translation units.</li> <li>If used, the library will distribute both \"old-style\" headers and module interface units<ul> <li>associated with the same CMake targets.</li> </ul> </li> <li>Even with full compiler support, a user may still decide to not pay for C++ modules compilation   if they are not needed by the customer's project.</li> <li>Feature test macro is not used for testing here because even if the compiler does not support   the entire C++ feature (e.g. header units), it is enough to build modules for this library.</li> <li>Related build options:<ul> <li>Conan: cxx_modules</li> <li>CMake: MP_UNITS_BUILD_CXX_MODULES</li> </ul> </li> </ul> <p>Note</p> <p>More requirements for C++ modules support can be found in the CMake's documentation.</p>"},{"location":"getting_started/cpp_compiler_support/#import-std","title":"<code>import std;</code>","text":"<ul> <li>If enabled, the library will obtain all the definitions from the <code>std</code> namespace via   <code>import std;</code> instead of the \"old-style\" header includes.</li> <li>Related build options:<ul> <li>Conan: import_std</li> <li>CMake: CMAKE_CXX_MODULE_STD</li> </ul> </li> </ul>"},{"location":"getting_started/cpp_compiler_support/#explicit-this-parameter","title":"Explicit <code>this</code> parameter","text":"<ul> <li>This feature removes the need for the usage of the CRTP idiom in the   <code>quantity_spec</code> definitions.</li> <li>To write code with wide compatibility   a dedicated macro may be used.</li> <li>Tested with <code>__cpp_explicit_this_parameter</code> feature test macro.</li> <li>Related build options:<ul> <li>Conan: no_crtp</li> <li>CMake: MP_UNITS_API_NO_CRTP</li> </ul> </li> </ul>"},{"location":"getting_started/faq/","title":"Frequently Asked Questions","text":""},{"location":"getting_started/faq/#why-do-we-spell-metre-instead-of-meter","title":"Why do we spell <code>metre</code> instead of <code>meter</code>?","text":"<p>This is how the BIPM defines it in the SI Brochure (British English spelling by default).</p>"},{"location":"getting_started/faq/#why-dont-we-use-udls-to-create-quantities","title":"Why don't we use UDLs to create quantities?","text":"<p>Many reasons make UDLs a poor choice for a physical units library:</p> <ol> <li>UDLs work only with literals (compile-time known values). Our observation is that besides    the unit tests, there are only a few compile-time known quantity values used in the production    code. Please note that for physical constants, we recommend using    Faster-than-lightspeed Constants.</li> <li> <p>Typical implementations of UDLs tend to always use the widest representation type available.    In the case of <code>std::chrono::duration</code>, the following is true:</p> <pre><code>using namespace std::chrono_literals;\nauto d1 = 42s;\nauto d2 = 42.s;\nstatic_assert(std::is_same_v&lt;decltype(d1)::rep, std::int64_t&gt;);\nstatic_assert(std::is_same_v&lt;decltype(d2)::rep, long double&gt;);\n</code></pre> </li> </ol> <p>When such UDL is intermixed in arithmetics with any quantity type of a shorter representation    type, it will always expand it to the longest one. In other words, such long type spreads until    all types use it everywhere.</p> <ol> <li> <p>While increasing the coverage for the library, we learned that many unit symbols conflict with    built-in types or numeric extensions. A few of those are: <code>F</code> (farad), <code>J</code> (joule), <code>W</code> (watt),    <code>K</code> (kelvin), <code>d</code> (day), <code>l</code> or <code>L</code> (litre), <code>erg</code>, <code>ergps</code>. Usage of the <code>_</code> prefix would make    it work for mp-units, but in case the library is standardized, those naming collisions would    be a big issue. This is why we came up with the <code>_q_</code> prefix that would become <code>q_</code> after    standardization (e.g., <code>42q_s</code>), which is not that nice anymore.</p> </li> <li> <p>UDLs with the same identifiers defined in different namespace can't be disambiguated in the C++    language. If both SI and CGS systems define <code>_q_s</code> UDL for a second unit, then it would not be possible    to specify which one to use in case both namespaces are \"imported\" with using directives.</p> </li> <li> <p>Another bad property of UDLs is that they do not compose. A coherent unit of angular momentum would    have a UDL specified as <code>_q_kg_m2_per_s</code>. Now imagine that we want to make every possible user happy.    How many variations of that unit would we predefine for differently scaled versions of all unit    ingredients?</p> </li> <li> <p>UDLs are also really expensive to define and specify. Typically, for each unit, we need two    definitions. One for integral and another one for floating-point representation. Before the    V2 framework, the coherent unit of angular momentum was defined as:</p> <pre><code>constexpr auto operator\"\" _q_kg_m2_per_s(unsigned long long l)\n{\n  gsl_Expects(std::in_range&lt;std::int64_t&gt;(l));\n  return angular_momentum&lt;kilogram_metre_sq_per_second, std::int64_t&gt;(static_cast&lt;std::int64_t&gt;(l));\n}\n\nconstexpr auto operator\"\" _q_kg_m2_per_s(long double l)\n{\n  return angular_momentum&lt;kilogram_metre_sq_per_second, long double&gt;(l);\n}\n</code></pre> </li> </ol>"},{"location":"getting_started/faq/#why-cant-i-create-a-quantity-by-passing-a-number-to-a-constructor","title":"Why can't I create a quantity by passing a number to a constructor?","text":"<p>A quantity class template in the mp-units library has no publicly available constructor taking a raw value. Such support is provided by the <code>std::chrono::duration</code> and was pointed out to us as a red flag safety issue by a few parties already.</p> <p>Consider the following structure and a code using it:</p> <pre><code>struct X {\n  std::vector&lt;std::chrono::milliseconds&gt; vec;\n  // ...\n};\n</code></pre> <pre><code>X x;\nx.vec.emplace_back(42);\n</code></pre> <p>Everything works fine for years until, at some point, someone changes the structure to:</p> <pre><code>struct X {\n  std::vector&lt;std::chrono::microseconds&gt; vec;\n  // ...\n};\n</code></pre> <p>The code continues to compile just fine, but all the calculations are off now. This is why we decided to not follow this path.</p> <p>In the mp-units library, both a number and a unit have to always be explicitly provided in order to form a quantity.</p> <p>Note</p> <p>The same applies to the construction of <code>quantity_point</code> using an explicit point origin. To prevent similar safety issues during maintenance, the initialization always requires providing both a <code>quantity</code> and a <code>PointOrigin</code> that we use as a reference point.</p>"},{"location":"getting_started/faq/#why-a-dimensionless-quantity-is-not-just-a-fundamental-arithmetic-type","title":"Why a dimensionless quantity is not just a fundamental arithmetic type?","text":"<p>In the initial design of this library, the resulting type of division of two quantities was their common representation type:</p> <pre><code>static_assert(std::is_same_v&lt;decltype(10 * km / (5 * km)), int&gt;);\n</code></pre> <p>First of all, this was consistent with <code>std::chrono::duration</code> behavior. Additional reasoning behind it was not providing a false impression of a strong <code>quantity</code> type for something that looks and feels like a regular number. Also, all of the mathematic and trigonometric functions were working fine out of the box with such representation types, so we did not have to rewrite <code>sin()</code>, <code>cos()</code>, <code>exp()</code>, and others.</p> <p>However, the feedback we got from the production usage was that such an approach is really bad for generic programming. It is hard to handle the result of the two quantities' division (or multiplication) as it might be either a quantity or a fundamental type. If we want to raise such a result to some power, we must use <code>units::pow</code> or <code>std::pow</code> depending on the resulting type. Those are only a few issues related to such an approach.</p> <p>Moreover, suppose we divide quantities of the same dimension but with units of significantly different magnitudes. In that case, we may end up with a really small or a huge floating-point value, which may result in losing lots of precision. Returning a dimensionless quantity from such cases allows us to benefit from all the properties of scaled units and is consistent with the rest of the library.</p> <p>Note</p> <p>More information on the current design can be found in the Dimensionless Quantities chapter.</p>"},{"location":"getting_started/faq/#why-derived-units-order-is-not-preserved-from-the-multiplication","title":"Why derived units order is not preserved from the multiplication?","text":"<p>It might be surprising, but the quantities and units multiplication order does not impact the order of components in the derived unit. Let's try the following example:</p> <pre><code>std::println(\"{}\", 42 * kW * h);\nconstexpr auto kWh = kW * h;\nstd::println(\"{}\", 42 * kWh);\n</code></pre> <p>The above prints:</p> <pre><code>42 h kW\n42 h kW\n</code></pre> <p>Some users could expect to see <code>42 kWh</code> or <code>42 kW h</code> in the output. It is not the case and for a very good reason. As stated in Simplifying the resulting symbolic expressions, to be able to reason about and simplify units, the library needs to order them in an appropriate order.</p> <p>Maybe this default order could be improved a bit, but according to international standards, there is no generic ordering rule. Various quantities use different, often domain-specific, ordering of derived unit components.</p> <p>Let's see what SI says here:</p> Derived quantity Symbol Derived unit expressed in terms of base units electric field strength V m\u207b\u00b9 kg m s\u207b\u00b3 A\u207b\u00b9 electric charge density C m\u207b\u00b3 A s m\u207b\u00b3 exposure (x- and \u03b3-rays) C kg\u207b\u00b9 A s kg\u207b\u00b9 <p>However, there is a workaround. A user can define its own named unit for a derived unit and provide the custom symbol text that suits the project's requirements. For example, the above case could be addressed with:</p> <pre><code>inline constexpr struct kilowatt_hour final : named_unit&lt;\"kWh\", kW * h&gt; {} kilowatt_hour;\ninline constexpr auto kWh = kilowatt_hour;\n</code></pre> <p>With the above, we can refactor the above code to:</p> <pre><code>std::println(\"{}\", 42 * kWh);\nstd::println(\"{}\", (42 * kW * h).in(kWh));\n</code></pre> <p>Both lines will produce an expected \"42 kWh\" unit in the output.</p> <p>Important</p> <p>Please note that this makes the entire \"kWh\" a single, indivisible entity that is not subject to simplification rules. This means that <code>42 * kWh / (2 * h)</code> will result with <code>21 kWh/h</code> rather than <code>21 kW</code>. To get the latter, the user needs to explicitly provide a new derived unit:</p> <pre><code>std::println(\"{}\", (42 * kWh / (2 * h)).in(kW));\n</code></pre>"},{"location":"getting_started/faq/#why-do-the-identifiers-for-concepts-in-the-library-use-camelcase","title":"Why do the identifiers for concepts in the library use <code>CamelCase</code>?","text":"<p>Initially, C++20 was meant to use <code>CamelCase</code> for all the concept identifiers. All the concepts from the <code>std::ranges</code> library were merged with such names into the standard document draft. Frustratingly, <code>CamelCase</code> concepts got dropped from the C++ standard at the last moment before releasing C++20. Now, we are facing the predictable consequences of running out of names.</p> <p>As long as some concepts in the library could be easily named with a <code>standard_case</code> there are some that are hard to distinguish from the corresponding type names, such as <code>Quantity</code>, <code>QuantityPoint</code>, <code>QuantitySpec</code>, or <code>Reference</code>. This is why we decided to use <code>CamelCase</code> consistently for all the concept identifiers to make it clear when we are talking about a type or concept identifier.</p> <p>However, we are aware that this might be a temporary solution. In case the library gets standardized, we can expect the ISO C++ Committee to bikeshed/rename all of the concept identifiers to a <code>standard_case</code>, even if it will result in a harder to understand code.</p> <p>Note</p> <p>In case you have a good idea of how to rename existing concepts to the <code>standard_case</code>, please let us know in the associated GitHub Issue.</p>"},{"location":"getting_started/faq/#why-utf-8-quantity-symbols-are-used-by-default-instead-of-portable-characters","title":"Why UTF-8 quantity symbols are used by default instead of portable characters?","text":"<p>Both C++ and ISO 80000 are standardized by the ISO. ISO 80000 and the SI standards specify UTF-8 symbols as the official unit names for some quantities (e.g. <code>\u03a9</code> symbol for the resistance quantity). As the mp-units library will be proposed for standardization as a part of the C++ Standard Library we have to obey the rules and be consistent with ISO specifications.</p> <p>Note</p> <p>We do understand engineering reality and the constraints of some environments. This is why the library has the option of Portable Quantity Symbols.</p>"},{"location":"getting_started/faq/#why-dont-we-have-cmake-options-to-disable-the-building-of-tests-and-examples","title":"Why don't we have CMake options to disable the building of tests and examples?","text":"<p>Over time, many people provided PRs proposing adding options to build tests and examples conditionally. Here are a few examples:</p> <ul> <li>Add CMake options for disabling docs, examples and tests</li> <li>build: add options to disable part of the build</li> <li>CMake Refactoring and Option Cleanup</li> </ul> <p>We admit this is a common practice in the industry, but we also believe this is a bad pattern.</p> <p>First, the only need for such options comes when a user wants to use <code>add_subdirectory()</code> in CMake to handle dependencies. Such an approach does not scale and should be discouraged. There is little use for such a practice in times when we have dedicated package managers like Conan.</p> <p>The second thing is that our observation is that many people are fixed on disabling \"unneeded\" subdirectories from compilation, but they do not see or address the biggest issue, which is polluting user's build environment with our development-specific settings. Propagating our restrictive compilation flags to user's project is not the best idea as it might cause a lot of harm if this project stops to compile because of that.</p> <p>Last but not least, not having those options is on purpose. Top level CMakeLists.txt file should only be used by mp-units developers and contributors as an entry point for the project's development. We want to ensure that everyone will build ALL the code correctly before pushing a commit. Having such options would allow unintended issues to leak to PRs and CI.</p> <p>This is why our projects have two entry points:</p> <ul> <li>./CMakeLists.txt is to be used by projects developers to build ALL the project code with really   restrictive compilation flags,</li> <li>./src/CMakeLists.txt contains only a pure library definition and should be used by the customers   that prefer to use CMake's <code>add_subdirectory()</code> to handle the dependencies.</li> </ul> <p>Note</p> <p>For more details on this please refer to the CMake + Conan: 3 Years Later - Mateusz Pusz lecture that Mateusz Pusz provided at the C++Now 2021 conference.</p>"},{"location":"getting_started/installation_and_usage/","title":"Installation And Usage","text":"<p>This chapter provides all the necessary information to obtain mp-units and build the user's source code using it.</p>"},{"location":"getting_started/installation_and_usage/#obtaining-dependencies","title":"Obtaining dependencies","text":"<p>This library assumes that most of the dependencies will be provided by the Conan Package Manager. If you want to obtain required dependencies by other means, some modifications to the library's CMake files might be needed.</p> Conan quick intro <p>In case you are not familiar with Conan, to install it (or upgrade) just do:</p> <pre><code>pip install -U conan\n</code></pre> <p>After that, you might need to add a custom profile file for your development environment in ~/.conan2/profiles directory. An example profile can look as follows:</p> ~/.conan2/profiles/gcc12<pre><code>[settings]\narch=x86_64\nbuild_type=Release\ncompiler=gcc\ncompiler.cppstd=20\ncompiler.libcxx=libstdc++11\ncompiler.version=14\nos=Linux\n\n[conf]\ntools.build:compiler_executables={\"c\": \"gcc-14\", \"cpp\": \"g++-14\"}\n</code></pre> <p>Setting the language version</p> <p>Please note that the mp-units library requires at least C++20 to be set in a Conan profile or forced via the Conan command line. If we do the former, we will not need to provide <code>-s compiler.cppstd=20</code> every time we run a Conan command line (as provided in the command line instructions below).</p> <p>Using Ninja as a CMake generator for Conan</p> <p>It is highly recommended to set Ninja as a CMake generator for Conan. To do so, we could create a ~/.conan2/global.conf file that will set <code>tools.cmake.cmaketoolchain:generator</code> to one of the Ninja generators. For example:</p> ~/.conan2/global.conf<pre><code>tools.cmake.cmaketoolchain:generator=\"Ninja Multi-Config\"\n</code></pre> <p>Separate build folders for different configurations</p> <p>~/.conan2/global.conf file may also set <code>tools.cmake.cmake_layout:build_folder_vars</code> which makes working with several compilers or build configurations easier. For example, the below line will force Conan to generate separate CMake presets and folders for each compiler and C++ standard version:</p> ~/.conan2/global.conf<pre><code>tools.cmake.cmake_layout:build_folder_vars=[\"settings.compiler\", \"settings.compiler.version\", \"settings.compiler.cppstd\"]\n</code></pre> <p>In such a case, we will need to use a configuration-specific preset name in the Conan instructions provided below rather than just <code>conan-default</code> and <code>conan-release</code> (e.g., <code>conan-gcc-13-23</code> and <code>conan-gcc-13-23-release</code>)</p> CMake with presets support <p>It is recommended to use at least CMake 3.23 to build this project to benefit from CMake Presets generated by Conan. All build instructions below assume that you have such support. If not, your CMake invocations have to be replaced with something like:</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake .. -G \"Ninja Multi-Config\" -DCMAKE_TOOLCHAIN_FILE=&lt;path_to_generators_dir&gt;/conan_toolchain.cmake\ncmake --build . --config Release\n</code></pre> <p>Tip</p> <p>In case you can't use CMake 3.23 but you have access to CMake 3.20 or later, you can append <code>-c tools.cmake.cmaketoolchain.presets:max_schema_version=2</code> to the <code>conan install</code> command which will force Conan to use an older version of the CMake Presets schema.</p>"},{"location":"getting_started/installation_and_usage/#build-options","title":"Build options","text":"<p>Note</p> <p>Most of the below options are related to the C++ language features available in the compilers. Please refer to the C++ compiler support chapter to learn more about which C++ features are required for each option and which compilers support them.</p>"},{"location":"getting_started/installation_and_usage/#conan-options","title":"Conan options","text":"<code>cxx_modules</code> <p> 2.2.0 \u00b7  <code>True</code>/<code>False</code> (Default: automatically determined from settings)</p> <p>Configures CMake to add C++ modules to the list of default targets.</p> <code>import_std</code> <p> 2.3.0 \u00b7  <code>True</code>/<code>False</code> (Default: <code>False</code>)</p> <p>Enables <code>import std;</code> usage.</p> <code>std_format</code> <p> 2.2.0 \u00b7  <code>True</code>/<code>False</code> (Default: automatically determined from settings)</p> <p>Enables the usage of <code>std::format</code> and associated facilities for text formatting. If it is not supported, then the {fmt} library is used instead.</p> <code>no_crtp</code> <p> 2.2.0 \u00b7  <code>True</code>/<code>False</code> (Default: automatically determined from settings)</p> <p>Removes the need for the usage of the CRTP idiom in the <code>quantity_spec</code> definitions.</p> <code>contracts</code> <p> 2.2.0 \u00b7  <code>none</code>/<code>gsl-lite</code>/<code>ms-gsl</code> (Default: see below)</p> <p>Enables checking of preconditions and additional assertions in the code.</p> <p>If the automatically determined default for <code>import_std</code> is <code>True</code>, then the <code>contracts</code> option is set to <code>none</code> by default. <code>gsl-lite</code> otherwise.</p> <code>freestanding</code> <p> 2.2.0 \u00b7  <code>True</code>/<code>False</code> (Default: <code>False</code>)</p> <p>Configures the library in the freestanding mode. When enabled, the library's source code will build with the compiler's <code>-ffreestanding</code> compilation option without any issues.</p> <code>natural_units</code> <p> 2.5.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>ON</code>)</p> <p>Enables experimental natural units systems support.</p> CMake options to set when Conan is not being used"},{"location":"getting_started/installation_and_usage/#cmake-options","title":"CMake options","text":"<p>Conan will automatically set all the below CMake options based on its configuration (described above). Manual setting of the below CMake options is only needed when Conan is not being used.</p> <code>MP_UNITS_BUILD_AS_SYSTEM_HEADERS</code> <p> 2.2.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>OFF</code>)</p> <p>Exports library as system headers.</p> <code>MP_UNITS_BUILD_CXX_MODULES</code> <p> 2.2.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>OFF</code>)</p> <p>Adds C++ modules to the list of default targets.</p> <code>MP_UNITS_API_STD_FORMAT</code> <p> 2.2.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: automatically determined)</p> <p>Enables the usage of <code>std::format</code> and associated facilities for text formatting. If it is not supported, then the {fmt} library is used instead.</p> <code>MP_UNITS_API_NO_CRTP</code> <p> 2.2.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: automatically determined)</p> <p>Removes the need for the usage of the CRTP idiom in the <code>quantity_spec</code> definitions.</p> <code>MP_UNITS_API_CONTRACTS</code> <p> 2.2.0 \u00b7  <code>NONE</code>/<code>GSL-LITE</code>/<code>MS-GSL</code> (Default: <code>GSL-LITE</code>)</p> <p>Enables checking of preconditions and additional asserts in the code.</p> <code>MP_UNITS_API_FREESTANDING</code> <p> 2.2.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>OFF</code>)</p> <p>Configures the library in the freestanding mode. When enabled, the library's source code should build with the compiler's <code>-ffreestanding</code> compilation option without any issues.</p> <code>MP_UNITS_API_NATURAL_UNITS</code> <p> 2.5.0 \u00b7  <code>ON</code>/<code>OFF</code> (Default: <code>ON</code>)</p> <p>Enables experimental natural units systems support.</p>"},{"location":"getting_started/installation_and_usage/#installation-and-reuse","title":"Installation and reuse","text":"<p>There are many different ways of installing/reusing mp-units in your project. Below we mention only a few of many options possible.</p> <p>Important: Prefer using Conan if possible</p> <p>The easiest and most recommended way to obtain mp-units is with the Conan package manager. See Conan + CMake (release) for a detailed instruction.</p>"},{"location":"getting_started/installation_and_usage/#conan-cmake-release","title":"Conan + CMake (release)","text":"<p>Tip</p> <p>If you are new to the Conan package manager you may want to read Obtaining Dependencies and refer to the Consuming packages chapter of the official Conan documentation for more information.</p> <p>mp-units releases are hosted on Conan-Center. The following steps may be performed to obtain an official library release:</p> <ol> <li> <p>Create Conan configuration file (either conanfile.txt or conanfile.py) in your    project's top-level directory and add mp-units as a dependency of your project.    For example, the simplest file may look as follows:</p> conanfile.txtconanfile.py <pre><code>[requires]\nmp-units/2.4.0\n\n[options]\n# The below mp-units options are set to defaults by Conan.\n# Uncomment and set to an explicit value to override the defaults.\n#\n# mp-units*:cxx_modules=True\n# mp-units*:import_std=False\n# mp-units*:std_format=True\n# mp-units*:no_crtp=True\n# mp-units*:contracts=gsl-lite\n# mp-units*:freestanding=False\n\n[layout]\ncmake_layout\n\n[generators]\nCMakeToolchain\nCMakeDeps\n</code></pre> <pre><code>from conan import ConanFile\nfrom conan.tools.build import can_run\nfrom conan.tools.cmake import CMake, cmake_layout\n\nclass MPUnitsTestConan(ConanFile):\n    settings = \"os\", \"arch\", \"compiler\", \"build_type\"\n    generators = \"CMakeDeps\", \"CMakeToolchain\"\n\n    def requirements(self):\n        self.requires(\n            \"mp-units/2.4.0\",\n            options={\n                # The below mp-units options are set to defaults by Conan.\n                # Uncomment and set to an explicit value to override the defaults.\n                #\n                # \"cxx_modules\": False,\n                # \"import_std\": False,\n                # \"std_format\": True,\n                # \"no_crtp\": True,\n                # \"contracts\": \"gsl-lite\",\n                # \"freestanding\": False,\n            },\n        )\n\n    def layout(self):\n        cmake_layout(self)\n\n    def build(self):\n        cmake = CMake(self)\n        cmake.configure()\n        cmake.build()\n        if can_run(self):\n            cmake.ctest(cli_args=[\"--output-on-failure\"])\n</code></pre> </li> <li> <p>Import mp-units and its dependencies definitions with <code>find_package</code>:</p> <pre><code>find_package(mp-units REQUIRED)\n</code></pre> </li> <li> <p>Link your CMake targets with mp-units:</p> <pre><code>target_link_libraries(&lt;your_target&gt; &lt;PUBLIC|PRIVATE|INTERFACE&gt; mp-units::mp-units)\n</code></pre> </li> <li> <p>Download, build, and install Conan dependencies before running the CMake configuration step:</p> conanfile.txt or conanfile.pyconanfile.py only <pre><code>conan install . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -b=missing\ncmake --preset conan-default\ncmake --build --preset conan-release\ncmake --build --preset conan-release --target test\n</code></pre> <pre><code>conan build . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -b=missing\n</code></pre> </li> </ol>"},{"location":"getting_started/installation_and_usage/#conan-cmake-live-at-head","title":"Conan + CMake (Live At Head)","text":"<p>This chapter describes the procedure to Live At Head, which means using the latest stable version of mp-units all the time.</p> <p>Note</p> <p>Please note that even though the Conan packages that you will be using are generated ONLY for builds that are considered stable (passed our CI tests), some minor regressions may happen (CI and C++ build environments are not perfect yet). Also, please expect that the library interface might, and probably will, change occasionally. Even though we do our best, such changes might not be reflected in the project's documentation right away.</p> <p>The procedure is similar to the one described in Conan + CMake (release) with the following differences:</p> <ol> <li> <p>Before starting the previous procedure, add mp-units remote to your Conan configuration:</p> <pre><code>conan remote add conan-mpusz https://mpusz.jfrog.io/artifactory/api/conan/conan-oss\n</code></pre> </li> <li> <p>In your Conan configuration file, provide the package identifier of the <code>mpusz/testing</code> stream:</p> conanfile.txtconanfile.py <pre><code>[requires]\nmp-units/2.5.0@mpusz/testing\n\n[options]\n# The below mp-units options are set to defaults by Conan.\n# Uncomment and set to an explicit value to override the defaults.\n#\n# mp-units*:cxx_modules=True\n# mp-units*:import_std=False\n# mp-units*:std_format=True\n# mp-units*:no_crtp=True\n# mp-units*:contracts=gsl-lite\n# mp-units*:freestanding=False\n\n[layout]\ncmake_layout\n\n[generators]\nCMakeToolchain\nCMakeDeps\n</code></pre> <pre><code>from conan import ConanFile\nfrom conan.tools.build import can_run\nfrom conan.tools.cmake import CMake, cmake_layout\n\nclass MPUnitsTestConan(ConanFile):\n    settings = \"os\", \"arch\", \"compiler\", \"build_type\"\n    generators = \"CMakeDeps\", \"CMakeToolchain\"\n\n    def requirements(self):\n        self.requires(\n            \"mp-units/2.5.0@mpusz/testing\",\n            options={\n                # The below mp-units options are set to defaults by Conan.\n                # Uncomment and set to an explicit value to override the defaults.\n                #\n                # \"cxx_modules\": False,\n                # \"import_std\": False,\n                # \"std_format\": True,\n                # \"no_crtp\": True,\n                # \"contracts\": \"gsl-lite\",\n                # \"freestanding\": False,\n            },\n        )\n\n    def layout(self):\n        cmake_layout(self)\n\n    def build(self):\n        cmake = CMake(self)\n        cmake.configure()\n        cmake.build()\n        if can_run(self):\n            cmake.ctest(cli_args=[\"--output-on-failure\"])\n</code></pre> <p>Tip</p> <p>The identifiers of the latest packages can always be found in the project's README file or on the project's Artifactory.</p> </li> <li> <p>Force Conan to check for updated recipes with <code>-u</code>:</p> <pre><code>conan install . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -b=missing -u\n</code></pre> </li> </ol> Alternative installation scenarios"},{"location":"getting_started/installation_and_usage/#copy","title":"Copy","text":"<p>As mp-units is a C++ header-only library you can simply copy all needed src/*/include subdirectories to your source tree.</p> <p>Note</p> <p>In such a case, you are on your own to ensure all the dependencies are installed and their header files can be located during the build. Please also note that some compiler-specific flags are needed to make the code compile without issues.</p>"},{"location":"getting_started/installation_and_usage/#copy-cmake","title":"Copy + CMake","text":"<p>If you copy the mp-units library source code from the project's ./src directory (not the entire repo from its root), you can reuse CMake targets defined by the library. To do so, you should use CMakeLists.txt file from the ./src directory:</p> <pre><code>add_subdirectory(&lt;path_to_mp_units_lib_folder&gt;)\n# ...\ntarget_link_libraries(&lt;your_target&gt; &lt;PUBLIC|PRIVATE|INTERFACE&gt; mp-units::mp-units)\n</code></pre> <p>Note</p> <p>You are still on your own to make sure all the dependencies are installed and their header and CMake configuration files can be located during the build.</p> <p>Important: Library users should not use the top-level CMake file</p> <p>Top level CMakeLists.txt file should only be used by mp-units developers and contributors as an entry point for the project's development. ./src/CMakeLists.txt contains only a pure library definition and should be used by the customers that prefer to use CMake's <code>add_subdirectory()</code> to handle the dependencies.</p> <p>To learn more about the rationale, please check our FAQ.</p>"},{"location":"getting_started/installation_and_usage/#install","title":"Install","text":"<p>If you don't want to use Conan in your project and just want to install the mp-units library on your file system, and use <code>find_package(mp-units)</code> from another repository to find it; it is enough to perform the following steps:</p> <pre><code>conan install . -pr &lt;your_conan_profile&gt; -s compiler.cppstd=20 -b=missing\nmv CMakeUserPresets.json src\ncd src\ncmake --preset conan-default -DCMAKE_INSTALL_PREFIX=&lt;your_installation_path&gt;\ncmake --build --preset conan-release --target install\n</code></pre>"},{"location":"getting_started/introduction/","title":"Introduction","text":"<p>mp-units is a Modern C++ library that provides compile-time dimensional analysis and unit/quantity manipulation. The initial versions of the library were inspired by the <code>std::chrono::duration</code> but with each release, the interfaces diverged from the original to provide a better user experience.</p> <p>Info</p> <p>A brief introduction to the library's interfaces and the rationale for changes in version 2.0 of mp-units were provided in detail by Mateusz Pusz in the \"The Power of C++ Templates With mp-units: Lessons Learned &amp; a New Library Design\" talk at the C++ on Sea 2023 conference.</p>"},{"location":"getting_started/introduction/#open-source","title":"Open Source","text":"<p>mp-units is Free and Open Source, with a permissive MIT license. Check out the source code and issue tracking (for questions and support, reporting bugs, suggesting feature requests and improvements) at https://github.com/mpusz/mp-units.</p>"},{"location":"getting_started/introduction/#with-the-users-experience-in-mind","title":"With the User's Experience in Mind","text":"<p>Most of the critical design decisions in the library are dictated by the requirement of providing the best user experience possible. Other C++ physical units libraries are \"famous\" for their enormous and hard-to-understand error messages (one line of the error log often does not fit on one slide). The ultimate goal of mp-units is to improve this and make compile-time errors and debugging as easy and user-friendly as possible.</p> <p>To achieve this goal, several techniques are applied:</p> <ul> <li>usage of C++20 concepts that improve   compile-times and the readability of error messages when compared to the traditional template   metaprogramming with SFINAE,</li> <li>usage of strong types for framework entities (instead of type aliases),</li> <li>usage of symbolic expressions to improve the readability of generated types,</li> <li>limiting the number of template arguments to the bare minimum.</li> </ul> <p>Important: It is all about errors</p> <p>In many generic C++ libraries, compile-time errors do not happen often. It is hard to break <code>std::string</code> or <code>std::vector</code> in a way that won't compile with a huge error log. Physical quantities and units libraries are different. Generation of compile-time errors is the main reason to use such a library.</p>"},{"location":"getting_started/introduction/#key-features","title":"Key Features","text":"Feature Description Safety - The affine space strong types (<code>quantity</code> and <code>quantity_point</code>)- Compile-time checked conversions of quantities and units- Unique support for many quantities of the same kind- Type-safe equations on scalar, vector, and tensor quantities and their units- Value-preserving conversions Performance - All the compile-time logic implemented as immediate (<code>consteval</code>) functions- As fast or even faster than working with fundamental types- No space size overhead needed to implement high-level abstractions Great User Experience - Optimized for readable compilation errors and great debugging experience- Efficient and composable way to specify a unit of choice- Value-based dimension, unit, and quantity equations Feature Rich - Systems of Quantities- Systems of Units- Scalar, vector, and tensor quantities- The affine space- Different models of the universe (e.g. natural units systems)- Strong dimensionless quantities- Strong angular system- Supports any unit's magnitude (huge, small, floating-point)- Faster-than-lightspeed constants- Highly adjustable text-output formatting Easy to Extend - Each entity can be defined with a single line of code- User can easily extend the systems with custom dimensions, quantities, and units Low Standardization Cost - Small number of predefined entities thanks to their composability- No external dependencies (assuming full C++20 support)- No macros in the user interface (besides portability and standard-compliance issues)- Possibility to be standardized as a freestanding part of the C++ Standard Library"},{"location":"getting_started/look_and_feel/","title":"Look and Feel","text":"<p>Here is a small example of operations possible on scalar quantities:</p> C++ modulesHeader files <pre><code>import mp_units;\n\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\n\n// simple numeric operations\nstatic_assert(10 * km / 2 == 5 * km);\n\n// conversions to common units\nstatic_assert(1 * h == 3600 * s);\nstatic_assert(1 * km + 1 * m == 1001 * m);\n\n// derived quantities\nstatic_assert(1 * km / (1 * s) == 1000 * m / s);\nstatic_assert(2 * km / h * (2 * h) == 4 * km);\nstatic_assert(2 * km / (2 * km / h) == 1 * h);\n\nstatic_assert(2 * m * (3 * m) == 6 * m2);\n\nstatic_assert(10 * km / (5 * km) == 2);\n\nstatic_assert(1000 / (1 * s) == 1 * kHz);\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\n\n// simple numeric operations\nstatic_assert(10 * km / 2 == 5 * km);\n\n// conversions to common units\nstatic_assert(1 * h == 3600 * s);\nstatic_assert(1 * km + 1 * m == 1001 * m);\n\n// derived quantities\nstatic_assert(1 * km / (1 * s) == 1000 * m / s);\nstatic_assert(2 * km / h * (2 * h) == 4 * km);\nstatic_assert(2 * km / (2 * km / h) == 1 * h);\n\nstatic_assert(2 * m * (3 * m) == 6 * m2);\n\nstatic_assert(10 * km / (5 * km) == 2);\n\nstatic_assert(1000 / (1 * s) == 1 * kHz);\n</code></pre> <p>Try it on Compiler Explorer</p> <p>This library requires some C++20 features (concepts and constraints, classes as NTTP, ...). Thanks to them, a user gets a powerful but still easy-to-use interface where all unit conversions and dimensional analysis can be performed without sacrificing accuracy. Please see the below example for a quick preview of basic library features:</p> C++ modulesHeader files <pre><code>#include &lt;format&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;print&gt;\nimport mp_units;\n\nusing namespace mp_units;\n\nconstexpr QuantityOf&lt;isq::speed&gt; auto avg_speed(QuantityOf&lt;isq::length&gt; auto d,\n                                                QuantityOf&lt;isq::time&gt; auto t)\n{\n  return d / t;\n}\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n  using namespace mp_units::international::unit_symbols;\n\n  constexpr quantity v1 = 110 * km / h;\n  constexpr quantity v2 = 70 * mph;\n  constexpr quantity v3 = avg_speed(220. * isq::distance[km], 2 * h);\n  constexpr quantity v4 = avg_speed(isq::distance(140. * mi), 2 * h);\n  constexpr quantity v5 = v3.in(m / s);\n  constexpr quantity v6 = value_cast&lt;m / s&gt;(v4);\n  constexpr quantity v7 = value_cast&lt;int&gt;(v6);\n\n  std::cout &lt;&lt; v1 &lt;&lt; '\\n';                                        // 110 km/h\n  std::cout &lt;&lt; std::setw(10) &lt;&lt; std::setfill('*') &lt;&lt; v2 &lt;&lt; '\\n';  // ***70 mi/h\n  std::cout &lt;&lt; std::format(\"{:*^10}\\n\", v3);                      // *110 km/h*\n  std::println(\"{:%N in %U of %D}\", v4);                          // 70 in mi/h of LT\u207b\u00b9\n  std::println(\"{::N[.2f]}\", v5);                                 // 30.56 m/s\n  std::println(\"{::N[.2f]U[dn]}\", v6);                            // 31.29 m\u22c5s\u207b\u00b9\n  std::println(\"{:%N}\", v7);                                      // 31\n}\n</code></pre> <pre><code>#include &lt;mp-units/systems/international.h&gt;\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#include &lt;format&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;print&gt;\n\nusing namespace mp_units;\n\nconstexpr QuantityOf&lt;isq::speed&gt; auto avg_speed(QuantityOf&lt;isq::length&gt; auto d,\n                                                QuantityOf&lt;isq::time&gt; auto t)\n{\n  return d / t;\n}\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n  using namespace mp_units::international::unit_symbols;\n\n  constexpr quantity v1 = 110 * km / h;\n  constexpr quantity v2 = 70 * mph;\n  constexpr quantity v3 = avg_speed(220. * isq::distance[km], 2 * h);\n  constexpr quantity v4 = avg_speed(isq::distance(140. * mi), 2 * h);\n  constexpr quantity v5 = v3.in(m / s);\n  constexpr quantity v6 = value_cast&lt;m / s&gt;(v4);\n  constexpr quantity v7 = value_cast&lt;int&gt;(v6);\n\n  std::cout &lt;&lt; v1 &lt;&lt; '\\n';                                        // 110 km/h\n  std::cout &lt;&lt; std::setw(10) &lt;&lt; std::setfill('*') &lt;&lt; v2 &lt;&lt; '\\n';  // ***70 mi/h\n  std::cout &lt;&lt; std::format(\"{:*^10}\\n\", v3);                      // *110 km/h*\n  std::println(\"{:%N in %U of %D}\", v4);                          // 70 in mi/h of LT\u207b\u00b9\n  std::println(\"{::N[.2f]}\", v5);                                 // 30.56 m/s\n  std::println(\"{::N[.2f]U[dn]}\", v6);                            // 31.29 m\u22c5s\u207b\u00b9\n  std::println(\"{:%N}\", v7);                                      // 31\n}\n</code></pre> <p>Try it on Compiler Explorer</p> <p>Note</p> <p>More code examples can be found in the Examples chapter.</p>"},{"location":"getting_started/project_structure/","title":"Project structure","text":"<p>This chapter provides a high level overview of the project to make it easier to navigate, build, and use.</p>"},{"location":"getting_started/project_structure/#cmake-projects-and-dependencies","title":"CMake projects and dependencies","text":"<p>The GitHub repository contains three independent CMake-based projects:</p> <ul> <li> <p>./src</p> <ul> <li>header-only project containing whole mp-units library</li> <li>./src/CMakeLists.txt file is intended as an entry point for library users</li> <li> <p>in case this library becomes part of the C++ standard, it will have no external dependencies   but until then, it depends on the following:</p> <ul> <li>gsl-lite or ms-gsl   to verify runtime contracts (if contract checking is enabled),</li> <li>{fmt} to provide text formatting of quantities   (if <code>std::format</code> is not supported yet on a specific compiler).</li> </ul> </li> </ul> </li> <li> <p>.</p> <ul> <li>project used as an entry point for library development and CI/CD</li> <li>it wraps ./src project together with usage examples and tests</li> <li> <p>additionally to the dependencies of ./src project, it uses:</p> <ul> <li>Catch2 library as a unit tests framework.</li> </ul> </li> </ul> </li> <li> <p>./test_package</p> <ul> <li>CMake library installation and Conan package verification.</li> </ul> </li> </ul> <p>Important: Library users should not use the top-level CMake file</p> <p>Top level CMakeLists.txt file should only be used by mp-units developers and contributors as an entry point for the project's development. We want to ensure that everyone will build ALL the code correctly before pushing a commit. Having such options would allow unintended issues to leak to PRs and CI.</p> <p>This is why our projects have two entry points:</p> <ul> <li>./CMakeLists.txt is to be used by projects developers to build ALL the project code   with really restrictive compilation flags,</li> <li>./src/CMakeLists.txt contains only a pure library definition and should be used by the   customers that prefer to use CMake's   <code>add_subdirectory()</code> to   handle the dependencies.</li> </ul> <p>To learn more about the rationale, please check our FAQ.</p>"},{"location":"getting_started/project_structure/#modules","title":"Modules","text":"<p>The mp-units library provides the following C++ modules:</p> <pre><code>flowchart TD\n    mp_units --- mp_units.systems --- mp_units.core</code></pre> C++ Module CMake Target Contents <code>mp_units.core</code> <code>mp-units::core</code> Core library framework and systems-independent utilities <code>mp_units.systems</code> <code>mp-units::systems</code> All the systems of quantities and units <code>mp_units</code> <code>mp-units::mp-units</code> Core + Systems <p>Note</p> <p>C++ modules are provided within the package only when:</p> <ul> <li><code>cxx_modules</code> Conan option is set to <code>True</code>,</li> <li><code>MP_UNITS_BUILD_CXX_MODULES</code> CMake option is set to <code>ON</code>.</li> </ul>"},{"location":"getting_started/project_structure/#header-files","title":"Header files","text":"<p>All of the project's header files can be found in the <code>mp-units/...</code> subdirectory.</p>"},{"location":"getting_started/project_structure/#core-library","title":"Core library","text":"<ul> <li><code>mp-units/framework.h</code> contains the entire library's framework definitions,</li> <li><code>mp-units/concepts.h</code> exposes only the library's concepts for generic code needs,</li> <li><code>mp-units/format.h</code> provides text formatting support,</li> <li><code>mp-units/ostream.h</code> enables streaming of the library's objects to the text output,</li> <li><code>mp-units/math.h</code> provides overloads of common math functions for quantities,</li> <li><code>mp-units/random.h</code> provides C++ pseudo-random number generators for quantities,</li> <li><code>mp-units/compat_macros.h</code> provides macros for wide compatibility.</li> </ul> More details <p>More detailed header files can be found in subfolders which typically should not be included by the end users:</p> <ul> <li><code>mp-units/framework/...</code> provides all the public interfaces of the framework,</li> <li><code>mp-units/bits/...</code> provides private implementation details only (no public definitions),</li> <li><code>mp-units/ext/...</code> contains external dependencies that at some point in the future should   be replaced with C++ standard library facilities.</li> </ul>"},{"location":"getting_started/project_structure/#systems-and-associated-utilities","title":"Systems and associated utilities","text":"<p>The systems definitions can be found in the <code>mp-units/systems/...</code> subdirectory:</p>"},{"location":"getting_started/project_structure/#systems-of-quantities","title":"Systems of quantities","text":"<ul> <li><code>mp-units/systems/isq.h</code> provides   International System of Quantities (ISQ)   definitions,</li> <li><code>mp-units/systems/isq_angle.h</code> provides a modification of the ISQ based on   the proposals to make an angle a base quantity in the ISQ,</li> </ul> Tip: Improving compile times <p><code>mp-units/systems/isq.h</code> might be expensive to compile in every translation unit. There are some smaller, domain targeted files available for explicit inclusion in the <code>mp-units/systems/isq/...</code> subdirectory.</p>"},{"location":"getting_started/project_structure/#systems-of-units","title":"Systems of units","text":"<ul> <li><code>mp-units/systems/si.h</code> provides   International System of Units (SI)   definitions and associated math functions,</li> <li><code>mp-units/systems/iec.h</code> provides units and prefixes defined by IEC (e.g., in the series of   IEC 80000 standards),</li> <li><code>mp-units/systems/angular.h</code> provides strong angular units   and associated math functions,</li> <li><code>mp-units/systems/international.h</code> provides   international yard and pound units,</li> <li><code>mp-units/systems/imperial.h</code> includes <code>international.h</code> and extends it with   imperial units,</li> <li><code>mp-units/systems/usc.h</code> includes <code>international.h</code> and extends it with   United States customary system of units,</li> <li><code>mp-units/systems/cgs.h</code> provides   centimetre-gram-second system of units,</li> <li><code>mp-units/systems/iau.h</code> provides   astronomical system of units,</li> <li><code>mp-units/systems/hep.h</code> provides units used in   high-energy physics,</li> <li><code>mp-units/systems/typographic.h</code> provides units used in   typography or typesetting,</li> <li><code>mp-units/systems/natural.h</code> provides an example implementation of   natural units.</li> </ul> Tip: Improving compile times <p><code>mp-units/systems/si.h</code> might be expensive to compile in every translation unit. There are some smaller files available for explicit inclusion in the <code>mp-units/systems/si/...</code> subdirectory.</p> <p><code>mp-units/systems/si/unit_symbols.h</code> is the most expensive to include.</p>"},{"location":"getting_started/quick_start/","title":"Quick Start","text":"<p>This chapter provides a quick introduction to get you started with mp-units. Much more details can be found in our User's Guide.</p>"},{"location":"getting_started/quick_start/#quantities","title":"Quantities","text":"<p>A quantity is a concrete amount of a unit representing a quantity type of a specified dimension with a specific representation. It is represented in the library with a <code>quantity</code> class template.</p> <p>The SI Brochure says:</p> <p>SI Brochure</p> <p>The value of the quantity is the product of the number and the unit. The space between the number and the unit is regarded as a multiplication sign (just as a space between units implies multiplication).</p> <p>Following the above, the value of a quantity in the mp-units library is created by multiplying a number with a predefined unit:</p> C++ modulesHeader files <pre><code>import mp_units;\n\nusing namespace mp_units;\n\nquantity q = 42 * si::metre / si::second;\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n\nusing namespace mp_units;\n\nquantity q = 42 * si::metre / si::second;\n</code></pre> <p>Info</p> <p>In case someone doesn't like the multiply syntax or there is an ambiguity between <code>operator*</code> provided by this and other libraries, there are two other ways to create a quantity:</p> <ol> <li> <p><code>delta</code> construction helper:</p> C++ modulesHeader files <pre><code>import mp_units;\n\nusing namespace mp_units;\n\nquantity q = delta&lt;si::metre / si::second&gt;(42);\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n\nusing namespace mp_units;\n\nquantity q = delta&lt;si::metre / si::second&gt;(42);\n</code></pre> </li> <li> <p>A two-parameter constructor:</p> C++ modulesHeader files <pre><code>import mp_units;\n\nusing namespace mp_units;\n\nquantity q{42, si::metre / si::second};\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n\nusing namespace mp_units;\n\nquantity q{42, si::metre / si::second};\n</code></pre> </li> </ol> <p>The above creates an instance of <code>quantity&lt;derived_unit&lt;si::metre, per&lt;si::second&gt;&gt;{}, int&gt;</code>. The same can be obtained using optional unit symbols:</p> C++ modulesHeader files <pre><code>import mp_units;\n\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\n\nquantity q = 42 * m / s;\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\n\nquantity q = 42 * m / s;\n</code></pre> <p>Important</p> <p>Unit symbols introduce a lot of short identifiers into the current scope, which may cause naming collisions with unrelated but already existing identifiers in the code base. This is why unit symbols are opt-in and typically should be imported only in the context where they are being used (e.g., function scope).</p> <p>A user has several options here to choose from depending on the required scenario and possible naming conflicts:</p> using-directiveusing-declarationcustom short identifierunit names <p>Explicitly \"import\" all of the symbols of a specific system of units from a dedicated <code>unit_symbols</code> namespace with a using-directive:</p> <pre><code>using namespace mp_units;\n\nvoid foo(double speed_m_s)\n{\n  // imports all the SI symbols at once\n  using namespace si::unit_symbols;\n  quantity speed = speed_m_s * m / s;\n  // ...\n}\n</code></pre> <p>Note</p> <p>This solution is perfect for small and isolated scopes but can cause surprising issues when used in larger scopes or when used for the entire program namespace.</p> <p>There are 29 named units in SI, and each of them has many prefixed variations (e.g., <code>ng</code>, <code>kcd</code>, ...). It is pretty easy to introduce a name collision with those.</p> <p>Selectively bring only the required and not-conflicting symbols with using-declarations:</p> <pre><code>using namespace mp_units;\n\nvoid foo(double N)\n{\n  // 'N' function parameter would collide with the SI symbol for Newton, so we only bring what we need\n  using si::unit_symbols::m;\n  using si::unit_symbols::s;\n  quantity speed = N * m / s;\n  // ...\n}\n</code></pre> <p>Specify a custom not conflicting unit identifier for a unit:</p> <pre><code>using namespace mp_units;\n\nvoid foo(double speed_m_s)\n{\n  // names of some local variables are conflicting with the symbols we want to use\n  auto m = ...;\n  auto s = ...;\n\n  constexpr Unit auto mps = si::metre / si::second;\n  quantity speed = speed_m_s * mps;\n}\n</code></pre> <p>Full unit names are straightforward to use and often provide the most readable code:</p> <pre><code>using namespace mp_units;\n\nvoid foo(double m, double s)\n{\n  quantity speed = m * si::metre / (s * si::second);\n  // ...\n}\n</code></pre> <p>Quantities of the same kind can be added, subtracted, and compared to each other:</p> C++ modulesHeader files <pre><code>import mp_units;\n\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\n\nstatic_assert(1 * km + 50 * m == 1050 * m);\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n\nusing namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\n\nstatic_assert(1 * km + 50 * m == 1050 * m);\n</code></pre> <p>Various quantities can be multiplied or divided by each other:</p> <pre><code>static_assert(140 * km / (2 * h) == 70 * km / h);\n</code></pre> <p>Note</p> <p>In case you wonder why this library does not use UDLs to create quantities, please check our FAQ.</p>"},{"location":"getting_started/quick_start/#quantity-points","title":"Quantity points","text":"<p>The quantity point specifies an absolute quantity with respect to an origin. If no origin is provided explicitly, an implicit one will be provided by the library.</p> <p>Together with quantities, they model The Affine Space.</p> <p>Quantity points should be used in all places where adding two values is meaningless (e.g., temperature points, timestamps, altitudes, readouts from the car's odometer, etc.).</p> <p>The set of operations that can be done on quantity points is limited compared to quantities. This introduces an additional type-safety.</p> C++ modulesHeader files <pre><code>#include &lt;print&gt;\nimport mp_units;\n\nint main()\n{\n  using namespace mp_units;\n  using namespace mp_units::si::unit_symbols;\n  using namespace mp_units::usc::unit_symbols;\n\n  quantity_point temp = point&lt;deg_C&gt;(20.);\n  std::println(\"Temperature: {} ({})\",\n               temp.quantity_from_zero(),\n               temp.in(deg_F).quantity_from_zero());\n}\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n#include &lt;mp-units/systems/usc.h&gt;\n#include &lt;print&gt;\n\nint main()\n{\n  using namespace mp_units;\n  using namespace mp_units::si::unit_symbols;\n  using namespace mp_units::usc::unit_symbols;\n\n  quantity_point temp = point&lt;deg_C&gt;(20.);\n  std::println(\"Temperature: {} ({})\",\n               temp.quantity_from_zero(),\n               temp.in(deg_F).quantity_from_zero());\n}\n</code></pre> <p>The above outputs:</p> <pre><code>Temperature: 20 \u2103 (68 \u2109)\n</code></pre> <p>Info</p> <p>Check The Affine Space chapter to learn more about quantity points.</p>"},{"location":"users_guide/terms_and_definitions/","title":"Terms and Definitions","text":"<p>The mp-units project consistently uses the official metrology vocabulary defined by the ISO and BIPM. You can find essential project-related definitions in our documentation's \"Glossary\" chapter. Even more, terms are provided in the official metrology vocabulary of the ISO and BIPM.</p> <p>Tip</p> <p>Please familiarize yourself with terms from \"Glossary\" to better understand the documentation and improve domain-related communication and discussions.</p>"},{"location":"users_guide/examples/avg_speed/","title":"<code>avg_speed</code>","text":"<p>Try it on Compiler Explorer</p> <p>Let's continue the previous example. This time, our purpose will not be to showcase as many library features as possible, but we will scope on different interfaces one can provide with the mp-units. We will also describe some advantages and disadvantages of presented solutions.</p> <p>First, we either import a module or include all the necessary header files and import all the identifiers from the <code>mp_units</code> namespace:</p> avg_speed.cpp<pre><code>#ifdef MP_UNITS_IMPORT_STD\nimport std;\n#else\n#include &lt;exception&gt;\n#include &lt;iostream&gt;\n#endif\n#ifdef MP_UNITS_MODULES\nimport mp_units;\n#else\n#include &lt;mp-units/systems/cgs.h&gt;\n#include &lt;mp-units/systems/international.h&gt;\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#endif\n\nnamespace {\n\nusing namespace mp_units;\n</code></pre> <p>Next, we define two functions calculating average speed based on quantities of fixed units and integral and floating-point representation types, respectively, and a third function that we introduced in the previous example:</p> avg_speed.cpp<pre><code>constexpr quantity&lt;si::metre / si::second, int&gt; fixed_int_si_avg_speed(quantity&lt;si::metre, int&gt; d,\n                                                                       quantity&lt;si::second, int&gt; t)\n{\n  return d / t;\n}\n\nconstexpr quantity&lt;si::metre / si::second&gt; fixed_double_si_avg_speed(quantity&lt;si::metre&gt; d, quantity&lt;si::second&gt; t)\n{\n  return d / t;\n}\n\nconstexpr QuantityOf&lt;isq::speed&gt; auto avg_speed(QuantityOf&lt;isq::length&gt; auto d, QuantityOf&lt;isq::time&gt; auto t)\n{\n  return d / t;\n}\n</code></pre> <p>We also added a simple utility to print our results:</p> avg_speed.cpp<pre><code>template&lt;QuantityOf&lt;isq::length&gt; D, QuantityOf&lt;isq::time&gt; T, QuantityOf&lt;isq::speed&gt; V&gt;\nvoid print_result(D distance, T duration, V speed)\n{\n  const auto result_in_kmph = speed.force_in(si::kilo&lt;si::metre&gt; / non_si::hour);\n  std::cout &lt;&lt; \"Average speed of a car that makes \" &lt;&lt; distance &lt;&lt; \" in \" &lt;&lt; duration &lt;&lt; \" is \" &lt;&lt; result_in_kmph\n            &lt;&lt; \".\\n\";\n}\n</code></pre> <p>Now, let's analyze how those three utility functions behave with different sets of arguments. First, we are going to use quantities of SI units and integral representation:</p> avg_speed.cpp<pre><code>void example()\n{\n  using namespace mp_units::si::unit_symbols;\n\n  // SI (int)\n  {\n    constexpr auto distance = 220 * km;\n    constexpr auto duration = 2 * h;\n\n    std::cout &lt;&lt; \"SI units with 'int' as representation\\n\";\n\n    print_result(distance, duration, fixed_int_si_avg_speed(distance, duration));\n    print_result(distance, duration, fixed_double_si_avg_speed(distance, duration));\n    print_result(distance, duration, avg_speed(distance, duration));\n  }\n</code></pre> <p>The above provides the following output:</p> <pre><code>SI units with 'int' as representation\nAverage speed of a car that makes 220 km in 2 h is 108 km/h.\nAverage speed of a car that makes 220 km in 2 h is 110 km/h.\nAverage speed of a car that makes 220 km in 2 h is 110 km/h.\n</code></pre> <p>Please note that in the first two cases, we must convert length from <code>km</code> to <code>m</code> and time from <code>h</code> to <code>s</code>. The converted values are used to calculate speed in <code>m/s</code> which is then again converted to the one in <code>km/h</code>. Those conversions not only impact the application's runtime performance but may also affect the precision of the final result. Such truncation can be easily observed in the first case where we deal with integral representation types (the resulting speed is <code>108 km/h</code>).</p> <p>The second scenario is really similar to the previous one, but this time, function arguments have floating-point representation types:</p> avg_speed.cpp<pre><code>  // SI (double)\n  {\n    constexpr auto distance = 220. * km;\n    constexpr auto duration = 2. * h;\n\n    std::cout &lt;&lt; \"\\nSI units with 'double' as representation\\n\";\n\n    // conversion from a floating-point to an integral type is a truncating one so an explicit cast is needed\n    print_result(distance, duration, fixed_int_si_avg_speed(value_cast&lt;int&gt;(distance), value_cast&lt;int&gt;(duration)));\n    print_result(distance, duration, fixed_double_si_avg_speed(distance, duration));\n    print_result(distance, duration, avg_speed(distance, duration));\n  }\n</code></pre> <p>Conversion from floating-point to integral representation types is considered value-truncating and that is why now, in the first case, we need an explicit call to <code>value_cast&lt;int&gt;</code>.</p> <p>In the text output, we can observe that, again, the resulting value gets truncated during conversions in the first cast:</p> <pre><code>SI units with 'double' as representation\nAverage speed of a car that makes 220 km in 2 h is 108 km/h.\nAverage speed of a car that makes 220 km in 2 h is 110 km/h.\nAverage speed of a car that makes 220 km in 2 h is 110 km/h.\n</code></pre> <p>Next, let's do the same for integral and floating-point representations, but this time using international mile:</p> avg_speed.cpp<pre><code>  // International mile (int)\n  {\n    using namespace mp_units::international::unit_symbols;\n\n    constexpr auto distance = 140 * mi;\n    constexpr auto duration = 2 * h;\n\n    std::cout &lt;&lt; \"\\nInternational mile with 'int' as representation\\n\";\n\n    // it is not possible to make a lossless conversion of miles to meters on an integral type\n    // (explicit cast needed)\n    print_result(distance, duration, fixed_int_si_avg_speed(distance.force_in(m), duration));\n    print_result(distance, duration, fixed_double_si_avg_speed(distance, duration));\n    print_result(distance, duration, avg_speed(distance, duration));\n  }\n\n  // International mile (double)\n  {\n    using namespace mp_units::international::unit_symbols;\n\n    constexpr auto distance = 140. * mi;\n    constexpr auto duration = 2. * h;\n\n    std::cout &lt;&lt; \"\\nInternational mile with 'double' as representation\\n\";\n\n    // conversion from a floating-point to an integral type is a truncating one so an explicit cast is needed\n    // also it is not possible to make a lossless conversion of miles to meters on an integral type\n    // (explicit cast needed)\n    print_result(distance, duration, fixed_int_si_avg_speed(value_cast&lt;m, int&gt;(distance), value_cast&lt;int&gt;(duration)));\n    print_result(distance, duration, fixed_double_si_avg_speed(distance, duration));\n    print_result(distance, duration, avg_speed(distance, duration));\n  }\n</code></pre> <p>One important difference here is the fact that as it is not possible to make a lossless conversion of miles to meters on a quantity using an integral representation type, so this time, we need a <code>value_cast&lt;m, int&gt;</code> to force it.</p> <p>If we check the text output of the above, we will see the following:</p> <pre><code>International mile with 'int' as representation\nAverage speed of a car that makes 140 mi in 2 h is 111 km/h.\nAverage speed of a car that makes 140 mi in 2 h is 112.654 km/h.\nAverage speed of a car that makes 140 mi in 2 h is 112 km/h.\n\nInternational mile with 'double' as representation\nAverage speed of a car that makes 140 mi in 2 h is 111 km/h.\nAverage speed of a car that makes 140 mi in 2 h is 112.654 km/h.\nAverage speed of a car that makes 140 mi in 2 h is 112.654 km/h.\n</code></pre> <p>Please note how the first and third results get truncated using integral representation types.</p> <p>In the end, we repeat the scenario for CGS units:</p> avg_speed.cpp<pre><code>  // CGS (int)\n  {\n    constexpr auto distance = 22'000'000 * cgs::centimetre;\n    constexpr auto duration = 7200 * cgs::second;\n\n    std::cout &lt;&lt; \"\\nCGS units with 'int' as representation\\n\";\n\n    // it is not possible to make a lossless conversion of centimeters to meters on an integral type\n    // (explicit cast needed)\n    print_result(distance, duration, fixed_int_si_avg_speed(distance.force_in(m), duration));\n    print_result(distance, duration, fixed_double_si_avg_speed(distance, duration));\n    print_result(distance, duration, avg_speed(distance, duration));\n  }\n\n  // CGS (double)\n  {\n    constexpr auto distance = 22'000'000. * cgs::centimetre;\n    constexpr auto duration = 7200. * cgs::second;\n\n    std::cout &lt;&lt; \"\\nCGS units with 'double' as representation\\n\";\n\n    // conversion from a floating-point to an integral type is a truncating one so an explicit cast is needed\n    // it is not possible to make a lossless conversion of centimeters to meters on an integral type\n    // (explicit cast needed)\n    print_result(distance, duration, fixed_int_si_avg_speed(value_cast&lt;m, int&gt;(distance), value_cast&lt;int&gt;(duration)));\n\n    print_result(distance, duration, fixed_double_si_avg_speed(distance, duration));\n    print_result(distance, duration, avg_speed(distance, duration));\n  }\n}\n\n}  // namespace\n</code></pre> <p>Again, we observe <code>value_cast</code> being used in the same places and consistent truncation errors in the text output:</p> <pre><code>CGS units with 'int' as representation\nAverage speed of a car that makes 22000000 cm in 7200 s is 108 km/h.\nAverage speed of a car that makes 22000000 cm in 7200 s is 110 km/h.\nAverage speed of a car that makes 22000000 cm in 7200 s is 109 km/h.\n\nCGS units with 'double' as representation\nAverage speed of a car that makes 2.2e+07 cm in 7200 s is 108 km/h.\nAverage speed of a car that makes 2.2e+07 cm in 7200 s is 110 km/h.\nAverage speed of a car that makes 2.2e+07 cm in 7200 s is 110 km/h.\n</code></pre> <p>The example file ends with a simple <code>main()</code> function:</p> avg_speed.cpp<pre><code>int main()\n{\n  try {\n    example();\n  } catch (const std::exception&amp; ex) {\n    std::cerr &lt;&lt; \"Unhandled std exception caught: \" &lt;&lt; ex.what() &lt;&lt; '\\n';\n  } catch (...) {\n    std::cerr &lt;&lt; \"Unhandled unknown exception caught\\n\";\n  }\n}\n</code></pre>","tags":["CGS System","International System"]},{"location":"users_guide/examples/hello_units/","title":"<code>hello_units</code>","text":"<p>Try it on Compiler Explorer</p> <p>This is a really simple example showcasing the features of the mp-units library.</p> <p>First, we either import the <code>mp_units</code> module or include the headers for:</p> <ul> <li>an International System of Quantities (ISQ),</li> <li>an International System of units (SI),</li> <li>units derived from the International Yard and Pound,</li> <li>text formatting and stream output support.</li> </ul> hello_units.cpp<pre><code>#include &lt;mp-units/compat_macros.h&gt;\n#include &lt;mp-units/ext/format.h&gt;\n#ifdef MP_UNITS_IMPORT_STD\nimport std;\n#else\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#endif\n#ifdef MP_UNITS_MODULES\nimport mp_units;\n#else\n#include &lt;mp-units/systems/international.h&gt;\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#endif\n</code></pre> <p>Also, to shorten the definitions, we \"import\" all the symbols from the <code>mp_units</code> namespace.</p> hello_units.cpp<pre><code>using namespace mp_units;\n</code></pre> <p>Next, we define a simple function that calculates the average speed based on the provided arguments of length and time:</p> hello_units.cpp<pre><code>constexpr QuantityOf&lt;isq::speed&gt; auto avg_speed(QuantityOf&lt;isq::length&gt; auto d, QuantityOf&lt;isq::time&gt; auto t)\n{\n  return d / t;\n}\n</code></pre> <p>The above function template takes any quantities implicitly convertible to <code>isq::length</code> and <code>isq::time</code>, respectively. Those quantities can use any compatible unit and a representation type. The function returns a result of a straightforward equation and ensures that its quantity type is implicitly convertible to <code>isq::speed</code>.</p> <p>Tip</p> <p>Besides verifying the type returned from the function, constraining a generic return type is beneficial for users of such a function as it provides more information of what to expect from a function than just using <code>auto</code>.</p> hello_units.cpp<pre><code>int main()\n{\n  using namespace mp_units::si::unit_symbols;\n  using namespace mp_units::international::unit_symbols;\n</code></pre> <p>The above lines explicitly opt into using unit symbols from two systems of units. As this introduces a lot of short identifiers into the current scope, it is not done implicitly while including a header file.</p> hello_units.cpp<pre><code>  constexpr quantity v1 = 110 * km / h;\n  constexpr quantity v2 = 70 * mph;\n  constexpr quantity v3 = avg_speed(220. * km, 2 * h);\n  constexpr quantity v4 = avg_speed(isq::distance(140. * mi), 2 * isq::duration[h]);\n  constexpr quantity v5 = v3.in(m / s);\n  constexpr quantity v6 = value_cast&lt;m / s&gt;(v4);\n  constexpr quantity v7 = value_cast&lt;int&gt;(v6);\n</code></pre> <ul> <li>Lines <code>27</code> &amp; <code>28</code> create a quantity of kind <code>isq::length / isq::time</code> with the numbers   and units provided. Such quantities can be converted or assigned to any other quantity   with a matching kind.</li> <li>Line <code>29</code> calls our function template with quantities of kind <code>isq::length</code> and   <code>isq::time</code> and number and units provided.</li> <li>Line <code>30</code> explicitly provides quantity types of the quantities passed to a function template.   This time, those will not be quantity kinds anymore and will have   more restrictive conversion rules.</li> <li>Line <code>31</code> changes the unit of a quantity <code>v3</code> to <code>m / s</code> in a   value-preserving way   (floating-point representations are considered to be value-preserving).</li> <li>Line <code>32</code> does a similar operation, but this time, it would also succeed for   value-truncating cases   (if that was the case).</li> <li>Line <code>33</code> does a value-truncating conversion   of changing the underlying representation type from <code>double</code> to <code>int</code>.</li> </ul> hello_units.cpp<pre><code>  std::cout &lt;&lt; v1 &lt;&lt; '\\n';                                           // 110 km/h\n  std::cout &lt;&lt; std::setw(10) &lt;&lt; std::setfill('*') &lt;&lt; v2 &lt;&lt; '\\n';     // ***70 mi/h\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{:*^10}\\n\", v3);            // *110 km/h*\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{:%N in %U of %D}\\n\", v4);  // 70 in mi/h of LT\u207b\u00b9\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{::N[.2f]}\\n\", v5);         // 30.56 m/s\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{::N[.2f]U[dn]}\\n\", v6);    // 31.29 m\u22c5s\u207b\u00b9\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{:%N}\\n\", v7);              // 31\n}\n</code></pre> <p>The above presents various ways to print a quantity. Both stream insertion operations and <code>std::format</code> facilities are supported.</p> <p>Tip</p> <p><code>MP_UNITS_STD_FMT</code> is used for compatibility reasons. If a specific compiler does not support <code>std::format</code> or a user prefers to use the <code>{fmt}</code> library, this macro will resolve to <code>fmt</code> namespace. Otherwise, the <code>std</code> namespace will be used.</p> <p>More about it can be found in the Wide Compatibility chapter.</p>","tags":["International System","Text Formatting"]},{"location":"users_guide/examples/hw_voltage/","title":"<code>hw_voltage</code>","text":"<p>Try it on Compiler Explorer</p> <p>As it was stated in The Affine Space chapter, every measurement can (and probably should) be modelled as a <code>quantity_point</code>. This is a perfect example of such a use case.</p> <p>This example implements a simplified scenario of measuring voltage read from hardware through a mapped 16-bits register. The actual voltage range of [-10 V, 10 V] is mapped to [-32767, 32767] on hardware. Translation of the value requires not only scaling of the value but also applying of an offset.</p> <p>First we include all the dependencies:</p> hw_voltage.cpp<pre><code>#include &lt;mp-units/compat_macros.h&gt;\n#include &lt;mp-units/ext/format.h&gt;\n#ifdef MP_UNITS_IMPORT_STD\nimport std;\n#else\n#include &lt;iostream&gt;\n#include &lt;optional&gt;\n#endif\n#ifdef MP_UNITS_MODULES\nimport mp_units;\n#else\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#endif\n\nusing namespace mp_units;\n</code></pre> <p>Next, we specify the real measurement voltage range to be in the range of [-10, 10]:</p> hw_voltage.cpp<pre><code>// real voltage range\ninline constexpr int min_voltage = -10;\ninline constexpr int max_voltage = 10;\ninline constexpr int voltage_range = max_voltage - min_voltage;\n</code></pre> <p>and provide a storage type and special values for the hardware representation:</p> hw_voltage.cpp<pre><code>// hardware encoding of voltage\nusing voltage_hw_t = std::uint16_t;\ninline constexpr voltage_hw_t voltage_hw_error = std::numeric_limits&lt;voltage_hw_t&gt;::max();\ninline constexpr voltage_hw_t voltage_hw_min = 0;\ninline constexpr voltage_hw_t voltage_hw_max = voltage_hw_error - 1;\ninline constexpr voltage_hw_t voltage_hw_range = voltage_hw_max - voltage_hw_min;\ninline constexpr voltage_hw_t voltage_hw_zero = voltage_hw_range / 2;\n</code></pre> <p>Finally, we define a quantity point origin, an offset unit that scales the value and uses this origin to offset the zero of the sale, and a dedicated quantity point alias using those:</p> hw_voltage.cpp<pre><code>inline constexpr struct hw_voltage_origin final :\n  relative_point_origin&lt;point&lt;si::volt&gt;(min_voltage)&gt; {} hw_voltage_origin;\n\ninline constexpr struct hw_voltage_unit final :\n  named_unit&lt;\"hwV\", mag_ratio&lt;voltage_range, voltage_hw_range&gt; * si::volt, hw_voltage_origin&gt; {} hw_voltage_unit;\n\nusing hw_voltage_quantity_point = quantity_point&lt;hw_voltage_unit, hw_voltage_origin, voltage_hw_t&gt;;\n</code></pre> <p>Now, when everything is ready, we can simulate mapping of our hardware register, and provide a helper function that will read the value and construct a quantity point from the obtained copy:</p> hw_voltage.cpp<pre><code>// mapped HW register\nvolatile voltage_hw_t hw_voltage_value;\n\nstd::optional&lt;hw_voltage_quantity_point&gt; read_hw_voltage()\n{\n  voltage_hw_t local_copy = hw_voltage_value;\n  if (local_copy == voltage_hw_error) return std::nullopt;\n  return point&lt;hw_voltage_unit&gt;(local_copy);\n}\n</code></pre> <p>We also provide a simple print helper for our quantity points:</p> hw_voltage.cpp<pre><code>void print(QuantityPoint auto qp)\n{\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"{:10} ({:5})\", qp.quantity_from_zero(),\n                                        value_cast&lt;double, si::volt&gt;(qp).quantity_from_zero());\n}\n</code></pre> <p>In the main function we simulate setting of 3 values by our hardware. Each of them is read and printed in the voltage unit used on the hardware as well as in the standard SI unit:</p> hw_voltage.cpp<pre><code>int main()\n{\n  // simulate reading of 3 values from the hardware\n  hw_voltage_value = voltage_hw_min;\n  quantity_point qp1 = read_hw_voltage().value();\n  hw_voltage_value = voltage_hw_zero;\n  quantity_point qp2 = read_hw_voltage().value();\n  hw_voltage_value = voltage_hw_max;\n  quantity_point qp3 = read_hw_voltage().value();\n\n  print(qp1);\n  print(qp2);\n  print(qp3);\n}\n</code></pre> <p>The above program results with the following text output:</p> <pre><code>     0 hwV (-10 V)\n 32767 hwV (  0 V)\n 65534 hwV ( 10 V)\n</code></pre>","tags":["Affine Space","Embedded","Text Formatting"]},{"location":"users_guide/examples/si_constants/","title":"<code>si_constants</code>","text":"<p>Try it on Compiler Explorer</p> <p>The next example presents all the seven defining constants of the SI system. We can observe how Faster-than-lightspeed Constants work in practice.</p> si_constants.cpp<pre><code>#include &lt;mp-units/compat_macros.h&gt;\n#include &lt;mp-units/ext/format.h&gt;\n#ifdef MP_UNITS_IMPORT_STD\nimport std;\n#else\n#include &lt;iostream&gt;\n#endif\n#ifdef MP_UNITS_MODULES\nimport mp_units;\n#else\n#include &lt;mp-units/systems/si.h&gt;\n#endif\n</code></pre> <p>As always, we start with the inclusion of all the needed header files. The main part of the example prints all of the SI-defining constants:</p> si_constants.cpp<pre><code>int main()\n{\n  using namespace mp_units;\n  using namespace mp_units::si;\n  using namespace mp_units::si::unit_symbols;\n\n  std::cout &lt;&lt; \"The seven defining constants of the SI and the seven corresponding units they define:\\n\";\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"- hyperfine transition frequency of Cs: {} = {::N[.0]}\\n\",\n                                        1. * si2019::hyperfine_structure_transition_frequency_of_cs,\n                                        (1. * si2019::hyperfine_structure_transition_frequency_of_cs).in(Hz));\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"- speed of light in vacuum:             {} = {::N[.0]}\\n\",\n                                        1. * si2019::speed_of_light_in_vacuum,\n                                        (1. * si2019::speed_of_light_in_vacuum).in(m / s));\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"- Planck constant:                      {} = {::N[.8e]}\\n\",\n                                        1. * si2019::planck_constant, (1. * si2019::planck_constant).in(J * s));\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"- elementary charge:                    {} = {::N[.9e]}\\n\",\n                                        1. * si2019::elementary_charge, (1. * si2019::elementary_charge).in(C));\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"- Boltzmann constant:                   {} = {::N[.6e]}\\n\",\n                                        1. * si2019::boltzmann_constant, (1. * si2019::boltzmann_constant).in(J / K));\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"- Avogadro constant:                    {} = {::N[.8e]}\\n\",\n                                        1. * si2019::avogadro_constant, (1. * si2019::avogadro_constant).in(one / mol));\n  std::cout &lt;&lt; MP_UNITS_STD_FMT::format(\"- luminous efficacy:                    {} = {}\\n\",\n                                        1. * si2019::luminous_efficacy, (1. * si2019::luminous_efficacy).in(lm / W));\n}\n</code></pre> <p>While analyzing the output of this program (provided below), we can easily notice that a direct printing of the quantity provides just a value <code>1</code> with a proper constant symbol. This is the main power of the Faster-than-lightspeed Constants feature. Only after we explicitly convert the unit of a quantity to proper SI units we get an actual numeric value of the constant.</p> <pre><code>The seven defining constants of the SI and the seven corresponding units they define:\n- hyperfine transition frequency of Cs: 1 \u0394\u03bd_Cs = 9192631770 Hz\n- speed of light in vacuum:             1 c = 299792458 m/s\n- Planck constant:                      1 h = 6.62607015e-34 J s\n- elementary charge:                    1 e = 1.602176634e-19 C\n- Boltzmann constant:                   1 k = 1.380649e-23 J/K\n- Avogadro constant:                    1 N_A = 6.02214076e+23 1/mol\n- luminous efficacy:                    1 K_cd = 683 lm/W\n</code></pre>","tags":["Physical Constants","Text Formatting"]},{"location":"users_guide/examples/tags_index/","title":"Tags Index","text":"<p>Note</p> <p>mp-units usage example applications are meant to be built on all of the supported compilers. This is why they benefit from the Wide Compatibility mode.</p> <p>Tip</p> <p>All usage examples in this chapter are categorized with appropriate tags to simplify navigation and search of relevant code. You can either read all the examples one-by-one in the order provided by the documentation authors or, thanks to the tagging system, jump straight to the example that is the most interesting for you.</p>"},{"location":"users_guide/examples/tags_index/#tag:affine-space","title":"Affine Space","text":"<ul> <li>            hw_voltage          </li> </ul>"},{"location":"users_guide/examples/tags_index/#tag:cgs-system","title":"CGS System","text":"<ul> <li>            avg_speed          </li> </ul>"},{"location":"users_guide/examples/tags_index/#tag:embedded","title":"Embedded","text":"<ul> <li>            hw_voltage          </li> </ul>"},{"location":"users_guide/examples/tags_index/#tag:international-system","title":"International System","text":"<ul> <li>            avg_speed          </li> <li>            hello_units          </li> </ul>"},{"location":"users_guide/examples/tags_index/#tag:physical-constants","title":"Physical Constants","text":"<ul> <li>            si_constants          </li> </ul>"},{"location":"users_guide/examples/tags_index/#tag:text-formatting","title":"Text Formatting","text":"<ul> <li>            hello_units          </li> <li>            hw_voltage          </li> <li>            si_constants          </li> </ul>"},{"location":"users_guide/framework_basics/character_of_a_quantity/","title":"Character of a Quantity","text":"<p>Warning</p> <p>This chapter's features are experimental and subject to change or removal. Please share your feedback if something seems wrong or could be improved.</p>"},{"location":"users_guide/framework_basics/character_of_a_quantity/#scalars-vectors-and-tensors","title":"Scalars, vectors, and tensors","text":"<p>ISO 80000-2</p> <p>Scalars, vectors and tensors are mathematical objects that can be used to denote certain physical quantities and their values. They are as such independent of the particular choice of a coordinate system, whereas each scalar component of a vector or a tensor and each component vector and component tensor depend on that choice.</p> <p>Such distinction is important because each quantity character represents different properties and allows different operations to be done on its quantities.</p> <p>For example, imagine a physical units library that allows the creation of a \\(speed\\) quantity from both \\(length / time\\) and \\(length * time\\). It wouldn't be too safe to use such a product, right?</p> <p>Now we have to realize that both of the above operations (multiplication and division) are not even mathematically defined for linear algebra types such as vectors or tensors. On the other hand, two vectors can be passed as arguments to dot and cross-product operations. The result of the first one is a scalar. The second one results in a vector that is perpendicular to both vectors passed as arguments. Again, it wouldn't be safe to allow replacing those two operations with each other or expect the same results from both cases. This simply can't work.</p>"},{"location":"users_guide/framework_basics/character_of_a_quantity/#isq-defines-quantities-of-all-characters","title":"ISQ defines quantities of all characters","text":"<p>While defining quantities ISO 80000 explicitly mentions when a specific quantity has a vector or tensor character. Here are some examples:</p> Quantity Character Quantity Equation \\(duration\\) scalar {base quantity} \\(mass\\) scalar {base quantity} \\(length\\) scalar {base quantity} \\(path\\; length\\) scalar {base quantity} \\(radius\\) scalar {base quantity} \\(position\\; vector\\) vector {base quantity} \\(velocity\\) vector \\(position\\; vector / duration\\) \\(acceleration\\) vector \\(velocity / duration\\) \\(force\\) vector \\(mass * acceleration\\) \\(power\\) scalar \\(force \\cdot velocity\\) \\(moment\\; of\\; force\\) vector \\(position\\; vector \\times force\\) \\(torque\\) scalar \\(moment\\; of\\; force \\cdot \\{unit\\; vector\\}\\) \\(surface\\; tension\\) scalar \\(\\lvert force \\rvert / length\\) \\(angular\\; displacement\\) scalar \\(path\\; length / radius\\) \\(angular\\; velocity\\) vector \\(angular\\; displacement / duration * \\{unit\\; vector\\}\\) \\(momentum\\) vector \\(mass * velocity\\) \\(angular\\; momentum\\) vector \\(position\\; vector \\times momentum\\) \\(moment\\; of\\; inertia\\) tensor \\(angular\\; momentum \\otimes angular\\; velocity\\) <p>In the above equations:</p> <ul> <li>\\(a * b\\) - regular multiplication where one of the arguments has to be scalar</li> <li>\\(a / b\\) - regular division where the divisor has to be scalar</li> <li>\\(a \\cdot b\\) - dot product of two vectors</li> <li>\\(a \\times b\\) - cross product of two vectors</li> <li>\\(\\lvert a \\rvert\\) - magnitude of a vector</li> <li>\\(\\{unit\\; vector\\}\\) - a special vector with the magnitude of \\(1\\)</li> <li>\\(a \\otimes b\\) - tensor product of two vectors or tensors</li> </ul> <p>Note</p> <p>As of now, all of the C++ physical units libraries on the market besides mp-units do not support the operations mentioned above. They expose only multiplication and division operators, which do not work for linear algebra-based representation types. If a user of those libraries would like to create the quantities provided in the above table properly, this would result in a compile-time error stating that multiplication and division of two linear algebra vectors is impossible.</p>"},{"location":"users_guide/framework_basics/character_of_a_quantity/#characters-dont-apply-to-dimensions-and-units","title":"Characters don't apply to dimensions and units","text":"<p>ISO 80000 explicitly states that dimensions are orthogonal to quantity characters:</p> <p>ISO 80000-1:2009</p> <p>In deriving the dimension of a quantity, no account is taken of its scalar, vector, or tensor character.</p> <p>Also, it explicitly states that:</p> <p>ISO 80000-2</p> <p>All units are scalars.</p>"},{"location":"users_guide/framework_basics/character_of_a_quantity/#defining-vector-and-tensor-quantities","title":"Defining vector and tensor quantities","text":"<p>To specify that a specific quantity has a vector or tensor character a value of <code>quantity_character</code> enumeration can be appended to the <code>quantity_spec</code> describing such a quantity type:</p> C++23C++20Portable <pre><code>inline constexpr struct displacement final : quantity_spec&lt;length, quantity_character::vector&gt; {} displacement;\ninline constexpr struct position_vector final : quantity_spec&lt;displacement&gt; {} position_vector;\n</code></pre> <pre><code>inline constexpr struct displacement final : quantity_spec&lt;displacement, length, quantity_character::vector&gt; {} displacement;\ninline constexpr struct position_vector final : quantity_spec&lt;position_vector, displacement&gt; {} position_vector;\n</code></pre> <pre><code>QUANTITY_SPEC(displacement, length, quantity_character::vector);\nQUANTITY_SPEC(position_vector, displacement);\n</code></pre> <p>With the above, all the quantities derived from <code>position_vector</code> or <code>displacement</code> will have a correct character determined according to the kind of operations included in the quantity equation defining a derived quantity.</p> <p>For example, <code>velocity</code> in the below definition will be defined as a vector quantity (no explicit character override is needed):</p> C++23C++20Portable <pre><code>inline constexpr struct velocity final : quantity_spec&lt;speed, displacement / duration&gt; {} velocity;\n</code></pre> <pre><code>inline constexpr struct velocity final : quantity_spec&lt;velocity, speed, displacement / duration&gt; {} velocity;\n</code></pre> <pre><code>QUANTITY_SPEC(velocity, speed, displacement / duration);\n</code></pre>"},{"location":"users_guide/framework_basics/character_of_a_quantity/#representation-types-for-vector-and-tensor-quantities","title":"Representation types for vector and tensor quantities","text":"<p>As we remember, the <code>quantity</code> class template is defined as follows:</p> <pre><code>template&lt;Reference auto R,\n         RepresentationOf&lt;get_quantity_spec(R)&gt; Rep = double&gt;\nclass quantity;\n</code></pre> <p>The second template parameter is constrained with a <code>RepresentationOf</code> concept that checks if the provided representation type satisfies the requirements for the character associated with this quantity type.</p> <p>Note</p> <p>The current version of the C++ Standard Library does not provide any types that could be used as a representation type for vector and tensor quantities. This is why users are on their own here .</p> <p>To provide examples and implement unit tests, our library uses the types proposed in the P1385 and available as a Conan package in the Conan Center. However, thanks to the provided customization points, any linear algebra library types can be used as a vector or tensor quantity representation type.</p> <p>For example, here is how it can be done for the P1385 types:</p> <pre><code>#include &lt;matrix&gt;\n\nusing la_vector = STD_LA::fixed_size_column_vector&lt;double, 3&gt;;\n\nQuantity auto q = la_vector{1, 2, 3} * isq::velocity[m / s];\n</code></pre> <p>In case there is an ambiguity of <code>operator*</code> between mp-units and a linear algebra library, we can either:</p> <ul> <li> <p>use two-parameter constructor</p> <pre><code>Quantity auto q = quantity{la_vector{1, 2, 3}, isq::velocity[m / s]};\n</code></pre> </li> <li> <p>provide a dedicated overload of <code>operator*</code> that will resolve the ambiguity and wrap the above</p> <pre><code>template&lt;Reference R&gt;\nQuantity auto operator*(la_vector rep, R)\n{\n  return quantity{rep, R{}};\n}\n</code></pre> </li> </ul> <p>Note</p> <p>The following does not work:</p> <pre><code>Quantity auto q1 = la_vector{1, 2, 3} * m / s;\nQuantity auto q2 = isq::velocity(la_vector{1, 2, 3} * m / s);\nquantity&lt;isq::velocity[m/s]&gt; q3{la_vector{1, 2, 3} * m / s};\n</code></pre> <p>In all the cases above, the SI unit <code>m / s</code> has an associated scalar quantity of <code>isq::length / isq::time</code>. <code>la_vector</code> is not a correct representation type for a scalar quantity so the construction fails.</p>"},{"location":"users_guide/framework_basics/concepts/","title":"Concepts","text":"<p>This chapter enumerates all the user-facing concepts in the mp-units library.</p>"},{"location":"users_guide/framework_basics/concepts/#Dimension","title":"<code>Dimension&lt;T&gt;</code>","text":"<p><code>Dimension</code> concept matches a dimension of either a base or derived quantity:</p> <ul> <li>Base dimensions are explicitly defined by the user   by inheriting from the instantiation of a <code>base_dimension</code> class template. It should be instantiated with   a unique symbol identifier describing this dimension in a specific   system of quantities.</li> <li>Derived dimensions are implicitly created   by the library's framework based on the quantity equation   provided in the quantity specification.</li> </ul> <p>All of the above dimensions have to be marked as <code>final</code>.</p>"},{"location":"users_guide/framework_basics/concepts/#DimensionOf","title":"<code>DimensionOf&lt;T, V&gt;</code>","text":"<p><code>DimensionOf</code> concept is satisfied when both arguments satisfy a <code>Dimension</code> concept and when they compare equal.</p>"},{"location":"users_guide/framework_basics/concepts/#QuantitySpec","title":"<code>QuantitySpec&lt;T&gt;</code>","text":"<p><code>QuantitySpec</code> concept matches all the quantity specifications including:</p> <ul> <li>Base quantities defined by a user by inheriting from   the <code>quantity_spec</code> class template instantiated with a base dimension   argument.</li> <li>Derived named quantities defined by a user by   inheriting from the <code>quantity_spec</code> class template instantiated with a result of a   quantity equation passed as an argument.</li> <li>Other named quantities forming a hierarchy of quantities   of the same kind defined by a user by inheriting from the   <code>quantity_spec</code> class template instantiated with another \"parent\" quantity specification passed as an   argument.</li> <li>Quantity kinds describing a family of mutually comparable quantities.</li> <li>Intermediate derived quantity specifications being   a result of a quantity equations on other specifications.</li> </ul> <p>All of the above quantity specifications have to be marked as <code>final</code>.</p>"},{"location":"users_guide/framework_basics/concepts/#QuantitySpecOf","title":"<code>QuantitySpecOf&lt;T, V&gt;</code>","text":"<p><code>QuantitySpecOf</code> concept is satisfied when both arguments satisfy a <code>QuantitySpec</code> concept and when <code>T</code> is implicitly convertible to <code>V</code>.</p>"},{"location":"users_guide/framework_basics/concepts/#UnitMagnitude","title":"<code>UnitMagnitude&lt;T&gt;</code>","text":"<p><code>UnitMagnitude</code> concept is satisfied by all types defining a unit magnitude.</p> <p>Info</p> <p>Unit magnitude implementation is a private implementation detail of the library.</p>"},{"location":"users_guide/framework_basics/concepts/#Unit","title":"<code>Unit&lt;T&gt;</code>","text":"<p><code>Unit</code> concept matches all the units in the library including:</p> <ul> <li>Base units defined by a user by inheriting from the <code>named_unit</code>   class template instantiated with a unique symbol identifier describing this unit in a specific   system of units.</li> <li>Named scaled units defined by a user by inheriting from the <code>named_unit</code> class template instantiated   with a unique symbol identifier and a product of multiplying another unit with some magnitude.</li> <li>Prefixed units defined by a user by inheriting from the <code>prefixed_unit</code> class template instantiated   with a prefix symbol, a magnitude, and a unit to be prefixed.</li> <li>Derived named units defined by a user by inheriting from the   <code>named_unit</code> class template instantiated with a unique symbol identifier and a result of   unit equation passed as an argument.</li> <li>Derived unnamed units being a result of a   unit equations on other units.</li> </ul> <p>All of the above units have to be marked as <code>final</code>.</p> <p>Note</p> <p>In the mp-units library, physical constants are also implemented as units.</p>"},{"location":"users_guide/framework_basics/concepts/#AssociatedUnit","title":"<code>AssociatedUnit&lt;T&gt;</code>","text":"<p><code>AssociatedUnit</code> concept describes a unit with an associated quantity and is satisfied by:</p> <ul> <li>All units derived from a <code>named_unit</code> class template instantiated with a unique symbol identifier   and a <code>QuantitySpec</code> of a quantity kind.</li> <li>All units being a result of unit equations on other   associated units.</li> </ul> Examples <p>All units in the SI have associated quantities. For example, <code>si::second</code> is specified to measure <code>isq::time</code>.</p> <p>Natural units typically do not have an associated quantity. For example, if we assume <code>c = 1</code>, a <code>natural::second</code> unit can be used to measure both <code>time</code> and <code>length</code>. In such case, <code>speed</code> would have a unit of <code>one</code>.</p>"},{"location":"users_guide/framework_basics/concepts/#PrefixableUnit","title":"<code>PrefixableUnit&lt;T&gt;</code>","text":"<p><code>PrefixableUnit</code> concept is satisfied by all units derived from a <code>named_unit</code> class template. Such units can be passed as an argument to a <code>prefixed_unit</code> class template.</p>"},{"location":"users_guide/framework_basics/concepts/#UnitOf","title":"<code>UnitOf&lt;T, V&gt;</code>","text":"<p><code>UnitOf</code> concept is satisfied for all units <code>T</code> for which an associated quantity spec is implicitly convertible to the provided <code>QuantitySpec</code> value.</p>"},{"location":"users_guide/framework_basics/concepts/#Reference","title":"<code>Reference&lt;T&gt;</code>","text":"<p><code>Reference</code> concept is satisfied by all quantity reference types. Such types provide all the meta-information required to create a <code>Quantity</code>. A <code>Reference</code> can either be:</p> <ul> <li>An <code>AssociatedUnit</code>.</li> <li>The instantiation of a <code>reference</code> class template with a <code>QuantitySpec</code> passed as   the first template argument and a <code>Unit</code> passed as the second one.</li> </ul>"},{"location":"users_guide/framework_basics/concepts/#ReferenceOf","title":"<code>ReferenceOf&lt;T, V&gt;</code>","text":"<p><code>ReferenceOf</code> concept is satisfied by references <code>T</code> which have a quantity specification that satisfies <code>QuantitySpecOf&lt;V&gt;</code> concept.</p>"},{"location":"users_guide/framework_basics/concepts/#RepresentationOf","title":"<code>RepresentationOf&lt;T, V&gt;</code>","text":"<p><code>RepresentationOf</code> concept constraints a type of a number that stores the value of a quantity and is satisfied:</p> <ul> <li> <p>if the type of <code>V</code> satisfies <code>QuantitySpec</code>:</p> <ul> <li>by all representation types when <code>V</code> describes   a quantity kind,</li> <li>otherwise, by representation types that are of   a quantity character associated with a provided   quantity specification <code>V</code>.</li> </ul> </li> <li> <p>if <code>V</code> is of <code>quantity_character</code> type:</p> <ul> <li>by representation types that are of a provided   quantity character.</li> </ul> </li> </ul>"},{"location":"users_guide/framework_basics/concepts/#Quantity","title":"<code>Quantity&lt;T&gt;</code>","text":"<p><code>Quantity</code> concept matches every quantity in the library and is satisfied by all types being or deriving from an instantiation of a <code>quantity</code> class template.</p>"},{"location":"users_guide/framework_basics/concepts/#QuantityOf","title":"<code>QuantityOf&lt;T, V&gt;</code>","text":"<p><code>QuantityOf</code> concept is satisfied by all the quantities for which a <code>ReferenceOf&lt;V&gt;</code> is <code>true</code>.</p>"},{"location":"users_guide/framework_basics/concepts/#QuantityLike","title":"<code>QuantityLike&lt;T&gt;</code>","text":"<p><code>QuantityLike</code> concept provides interoperability with other libraries and is satisfied by a type <code>T</code> for which an instantiation of <code>quantity_like_traits</code> type trait yields a valid type that provides:</p> <ul> <li><code>reference</code> static data member that matches the <code>Reference</code> concept,</li> <li><code>rep</code> type that matches <code>RepresentationOf</code> concept with the character provided   in <code>reference</code>,</li> <li><code>explicit_import</code> static data member convertible to <code>bool</code> that specifies that the conversion   from <code>T</code> to a <code>quantity</code> type should happen explicitly (if <code>true</code>),</li> <li><code>explicit_export</code> static data member convertible to <code>bool</code> that specifies that the conversion   from a <code>quantity</code> type to <code>T</code> should happen explicitly (if <code>true</code>),</li> <li><code>to_numerical_value(T)</code> static member function returning a raw value of the quantity,</li> <li><code>from_numerical_value(rep)</code> static member function returning <code>T</code>.</li> </ul> Examples <p>This is how support for <code>std::chrono::seconds</code> can be provided:</p> <pre><code>template&lt;&gt;\nstruct mp_units::quantity_like_traits&lt;std::chrono::seconds&gt; {\n  static constexpr auto reference = si::second;\n  static constexpr bool explicit_import = false;\n  static constexpr bool explicit_export = false;\n  using rep = std::chrono::seconds::rep;\n\n  [[nodiscard]] static constexpr rep to_numerical_value(const std::chrono::seconds&amp; d)\n  {\n    return d.count();\n  }\n\n  [[nodiscard]] static constexpr std::chrono::seconds from_numerical_value(const rep&amp; v)\n  {\n    return std::chrono::seconds(v);\n  }\n};\n\nquantity q = 42s;\nstd::chrono::seconds dur = 42 * s;\n</code></pre>"},{"location":"users_guide/framework_basics/concepts/#PointOrigin","title":"<code>PointOrigin&lt;T&gt;</code>","text":"<p><code>PointOrigin</code> concept matches all quantity point origins in the library. It is satisfied by either:</p> <ul> <li>All types derived from an <code>absolute_point_origin</code> class template.</li> <li>All types derived from a <code>relative_point_origin</code> class template.</li> </ul>"},{"location":"users_guide/framework_basics/concepts/#PointOriginFor","title":"<code>PointOriginFor&lt;T, V&gt;</code>","text":"<p><code>PointOriginFor</code> concept is satisfied by all <code>PointOrigin</code> types that have quantity type implicitly convertible from quantity specification <code>V</code>, which means that <code>V</code> must satisfy <code>QuantitySpecOf&lt;T::quantity_spec&gt;</code>.</p> Examples <p><code>si::ice_point</code> can serve as a point origin for points of <code>isq::Celsius_temperature</code> because this quantity type implicitly converts to <code>isq::thermodynamic_temperature</code>.</p> <p>However, if we define <code>mean_sea_level</code> in the following way:</p> <pre><code>inline constexpr struct mean_sea_level final : absolute_point_origin&lt;isq::altitude&gt; {} mean_sea_level;\n</code></pre> <p>then it can't be used as a point origin for points of <code>isq::length</code> or <code>isq::width</code> as none of them is implicitly convertible to <code>isq::altitude</code>:</p> <ul> <li>not every length is an altitude,</li> <li>width is not compatible with altitude.</li> </ul>"},{"location":"users_guide/framework_basics/concepts/#QuantityPoint","title":"<code>QuantityPoint&lt;T&gt;</code>","text":"<p><code>QuantityPoint</code> concept is satisfied by all types being either a specialization or derived from <code>quantity_point</code> class template.</p>"},{"location":"users_guide/framework_basics/concepts/#QuantityPointOf","title":"<code>QuantityPointOf&lt;T, V&gt;</code>","text":"<p><code>QuantityPointOf</code> concept is satisfied by all the quantity points <code>T</code> that match the following value <code>V</code>:</p> <code>V</code> Condition <code>QuantitySpec</code> The quantity point quantity specification satisfies <code>ReferenceOf&lt;V&gt;</code> concept. <code>PointOrigin</code> The point and <code>V</code> have the same absolute point origin."},{"location":"users_guide/framework_basics/concepts/#QuantityPointLike","title":"<code>QuantityPointLike&lt;T&gt;</code>","text":"<p><code>QuantityPointLike</code> concept provides interoperability with other libraries and is satisfied by a type <code>T</code> for which an instantiation of <code>quantity_point_like_traits</code> type trait yields a valid type that provides:</p> <ul> <li><code>reference</code> static data member that matches the <code>Reference</code> concept.</li> <li><code>point_origin</code> static data member that matches the <code>PointOrigin</code> concept.</li> <li><code>rep</code> type that matches <code>RepresentationOf</code> concept with the character provided   in <code>reference</code>.</li> <li><code>explicit_import</code> static data member convertible to <code>bool</code> that specifies that the conversion   from <code>T</code> to a <code>quantity_point</code> type should happen explicitly (if <code>true</code>),</li> <li><code>explicit_export</code> static data member convertible to <code>bool</code> that specifies that the conversion   from a <code>quantity_point</code> type to <code>T</code> should happen explicitly (if <code>true</code>),</li> <li><code>to_numerical_value(T)</code> static member function returning a raw value of the quantity being the offset   of the point from the origin,</li> <li><code>from_numerical_value(rep)</code> static member function returning <code>T</code>.</li> </ul> Examples <p>This is how support for a <code>std::chrono::time_point</code> of <code>std::chrono::seconds</code> can be provided:</p> <pre><code>template&lt;typename C&gt;\nstruct mp_units::quantity_point_like_traits&lt;std::chrono::time_point&lt;C, std::chrono::seconds&gt;&gt; {\n  static constexpr auto reference = si::second;\n  static constexpr struct point_origin_ final : absolute_point_origin&lt;isq::time&gt; {} point_origin{};\n  static constexpr bool explicit_import = false;\n  static constexpr bool explicit_export = false;\n  using rep = std::chrono::seconds::rep;\n  using T = std::chrono::time_point&lt;C, std::chrono::seconds&gt;;\n\n  [[nodiscard]] static constexpr rep to_numerical_value(const T&amp; tp)\n  {\n    return tp.time_since_epoch().count();\n  }\n\n  [[nodiscard]] static constexpr T from_numerical_value(const rep&amp; v)\n  {\n    return T(std::chrono::seconds(v));\n  }\n};\n\nquantity_point qp = time_point_cast&lt;std::chrono::seconds&gt;(std::chrono::system_clock::now());\nstd::chrono::sys_seconds q = qp + 42 * s;\n</code></pre>"},{"location":"users_guide/framework_basics/design_overview/","title":"Design Overview","text":"<p>The most important entities in the mp-units library are:</p> <ul> <li>quantity,</li> <li>quantity point,</li> <li>unit,</li> <li>dimension,</li> <li>quantity specification</li> <li>quantity reference,</li> <li>quantity representation.</li> </ul> <p>The graph provided below presents how those and a few other entities depend on each other:</p> <pre><code>flowchart TD\n    Unit --- Reference\n    Dimension --- QuantitySpec[\"Quantity specification\"]\n    quantity_character[\"Quantity character\"] --- QuantitySpec\n    QuantitySpec --- Reference[\"Quantity reference\"]\n    Reference --- Quantity\n    quantity_character -.- Representation\n    Representation --- Quantity\n    Quantity --- QuantityPoint[\"Quantity point\"]\n    PointOrigin[\"Point origin\"] --- QuantityPoint\n\n    click Dimension \"#dimension\"\n    click quantity_character \"#quantity-character\"\n    click QuantitySpec \"#quantity-specification\"\n    click Unit \"#unit\"\n    click Reference \"#quantity-reference\"\n    click Representation \"#quantity-representation\"\n    click Quantity \"#quantity\"\n    click PointOrigin \"#point-origin\"\n    click QuantityPoint \"#quantity-point\"</code></pre>"},{"location":"users_guide/framework_basics/design_overview/#dimension","title":"Dimension","text":"<p>Dimension specifies the dependence of a quantity on the base quantities of a particular system of quantities. It is represented as a product of powers of factors corresponding to the base quantities, omitting any numerical factor.</p> <p>In the mp-units library, we use the terms:</p> <ul> <li>base dimension to refer to the dimension of a base quantity,</li> <li>derived dimension to refer to the dimension of a derived quantity.</li> </ul> <p>For example:</p> <ul> <li>length (\\(\\mathsf{L}\\)), mass (\\(\\mathsf{M}\\)), time (\\(\\mathsf{T}\\)), electric current (\\(\\mathsf{I}\\)),   thermodynamic temperature (\\(\\mathsf{\u0398}\\)), amount of substance (\\(\\mathsf{N}\\)), and   luminous intensity (\\(\\mathsf{J}\\)) are the base dimensions of the ISQ.</li> <li>A derived dimension of force in the ISQ is denoted by   \\(\\textsf{dim }F = \\mathsf{LMT}^{\u20132}\\).</li> <li>The implementation of IEC 80000 in this library provides <code>iec::dim_traffic_intensity</code>   base dimension to extend ISQ with strong information technology quantities.</li> </ul> <p>Base dimensions can be defined by the user in the following way:</p> <pre><code>inline constexpr struct dim_length final : base_dimension&lt;\"L\"&gt; {} dim_length;\ninline constexpr struct dim_time final : base_dimension&lt;\"T\"&gt; {} dim_time;\n</code></pre> <p>Derived dimensions are implicitly created by the library's framework based on the quantity equation provided in the quantity specification:</p> C++23C++20Portable <pre><code>inline constexpr struct length final : quantity_spec&lt;dim_length&gt; {} length;\ninline constexpr struct time final : quantity_spec&lt;dim_time&gt; {} time;\ninline constexpr struct speed final : quantity_spec&lt;length / time&gt; {} speed;\n\nstatic_assert(speed.dimension == dim_length / dim_time);\n</code></pre> <pre><code>inline constexpr struct length final : quantity_spec&lt;length, dim_length&gt; {} length;\ninline constexpr struct time final : quantity_spec&lt;time, dim_time&gt; {} time;\ninline constexpr struct speed final : quantity_spec&lt;speed, length / time&gt; {} speed;\n\nstatic_assert(speed.dimension == dim_length / dim_time);\n</code></pre> <pre><code>QUANTITY_SPEC(length, dim_length);\nQUANTITY_SPEC(time, dim_time);\nQUANTITY_SPEC(speed, length / time);\n\nstatic_assert(speed.dimension == dim_length / dim_time);\n</code></pre> <p>Important</p> <p>Users should not explicitly define any derived dimensions. Those should always be implicitly created by the framework.</p> <p>The multiplication/division on quantity specifications also multiplies/divides their dimensions:</p> <pre><code>static_assert((length / time).dimension == dim_length / dim_time);\n</code></pre> <p>The dimension equation of <code>isq::dim_length / isq::dim_time</code> results in the <code>derived_dimension&lt;isq::dim_length, per&lt;isq::dim_time&gt;&gt;</code> type.</p>"},{"location":"users_guide/framework_basics/design_overview/#quantity-character","title":"Quantity character","text":"<p>ISO 80000 explicitly states that quantities (even of the same kind) may have different characters:</p> <ul> <li>real scalar (e.g., time, width, speed, apparent power),</li> <li>complex scalar (e.g., voltage phasor, complex power, impedance),</li> <li>vector (e.g., displacement, velocity, force),</li> <li>tensor (e.g., moment of inertia, stress, strain).</li> </ul> <p>The quantity character in the mp-units library is implemented with the <code>quantity_character</code> enumeration:</p> <pre><code>enum class quantity_character { real_scalar, complex_scalar, vector, tensor };\n</code></pre> <p>Info</p> <p>You can read more on quantity characters in the \"Character of a Quantity\" chapter.</p>"},{"location":"users_guide/framework_basics/design_overview/#quantity-specification","title":"Quantity specification","text":"<p>Dimension is not enough to describe a quantity. This is why the ISO 80000 provides hundreds of named quantity types. It turns out that there are many more quantity types in the ISQ than the named units in the SI.</p> <p>This is why the mp-units library introduces a quantity specification entity that stores:</p> <ul> <li>dimension,</li> <li>quantity type/name,</li> <li>quantity character,</li> <li>the quantity equation being the recipe to create this quantity   (only for derived quantities that specify such a recipe).</li> </ul> <p>Note</p> <p>We know that it might be sometimes confusing to talk about quantities, quantity types/names, and quantity specifications. However, it might be important to notice here that even the ISO 80000 admits that:</p> <p>It is customary to use the same term, \"quantity\", to refer to both general quantities, such as length, mass, etc., and their instances, such as given lengths, given masses, etc. Accordingly, we are used to saying both that length is a quantity and that a given length is a quantity by maintaining the specification \u2013 \"general quantity, \\(Q\\)\" or \"individual quantity, \\(Q_\\textsf{a}\\)\" \u2013 implicit and exploiting the linguistic context to remove the ambiguity.</p> <p>In the mp-units library, we have a:</p> <ul> <li>quantity - implemented as a <code>quantity</code> class template,</li> <li>quantity specification - implemented with a <code>quantity_spec</code> class template that among others identifies   a specific quantity type/name.</li> </ul> <p>For example:</p> <ul> <li><code>isq::length</code>, <code>isq::mass</code>, <code>isq::time</code>, <code>isq::electric_current</code>, <code>isq::thermodynamic_temperature</code>,   <code>isq::amount_of_substance</code>, and <code>isq::luminous_intensity</code> are the specifications of base quantities   in the ISQ.</li> <li><code>isq::width</code>, <code>isq::height</code>, <code>isq::radius</code>, and <code>isq::position_vector</code> are only a few of many    quantities of a kind length specified in the ISQ.</li> <li><code>isq::area</code>, <code>isq::speed</code>, <code>isq::moment_of_force</code> are only a few of many derived quantities provided   in the ISQ.</li> </ul> <p>Quantity specification  can be defined by the user in one of the following ways:</p> C++23C++20Portable <pre><code>inline constexpr struct length final : quantity_spec&lt;dim_length&gt; {} length;\ninline constexpr struct height final : quantity_spec&lt;length&gt; {} height;\ninline constexpr struct speed final : quantity_spec&lt;length / time&gt; {} speed;\n</code></pre> <pre><code>inline constexpr struct length final : quantity_spec&lt;length, dim_length&gt; {} length;\ninline constexpr struct height final : quantity_spec&lt;height, length&gt; {} height;\ninline constexpr struct speed final : quantity_spec&lt;speed, length / time&gt; {} speed;\n</code></pre> <pre><code>QUANTITY_SPEC(length, dim_length);\nQUANTITY_SPEC(height, length);\nQUANTITY_SPEC(speed, length / time);\n</code></pre> <p>The quantity equation of <code>isq::length / isq::time</code> results in the <code>derived_quantity_spec&lt;isq::length, per&lt;isq::time&gt;&gt;</code> type.</p>"},{"location":"users_guide/framework_basics/design_overview/#unit","title":"Unit","text":"<p>A unit is a concrete amount of a quantity that allows us to measure the values of quantities of the same kind and represent the result as a number being the ratio of the two quantities.</p> <p>For example:</p> <ul> <li><code>si::second</code>, <code>si::metre</code>, <code>si::kilogram</code>, <code>si::ampere</code>, <code>si::kelvin</code>, <code>si::mole</code>, and <code>si::candela</code>   are the base units of the SI.</li> <li><code>si::kilo&lt;si::metre&gt;</code> is a prefixed unit of length.</li> <li><code>si::radian</code>, <code>si::newton</code>, and <code>si::watt</code> are examples of named derived units within the   SI.</li> <li><code>non_si::minute</code> is an example of a scaled unit of time.</li> <li><code>si::si2019::speed_of_light_in_vacuum</code> is a physical constant standardized by the SI in 2019.</li> </ul> <p>Note</p> <p>In the mp-units library, physical constants are also implemented as units.</p> <p>A unit can be defined by the user in one of the following ways:</p> <pre><code>template&lt;PrefixableUnit U&gt; struct kilo_ : prefixed_unit&lt;\"k\", mag_power&lt;10, 3&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit auto U&gt; constexpr kilo_&lt;decltype(U)&gt; kilo;\n\ninline constexpr struct second final : named_unit&lt;\"s\", kind_of&lt;isq::time&gt;&gt; {} second;\ninline constexpr struct minute final : named_unit&lt;\"min\", mag&lt;60&gt; * second&gt; {} minute;\ninline constexpr struct gram   final : named_unit&lt;\"g\", kind_of&lt;isq::mass&gt;&gt; {} gram;\ninline constexpr auto kilogram = kilo&lt;gram&gt;;\ninline constexpr struct newton final : named_unit&lt;\"N\", kilogram * metre / square(second)&gt; {} newton;\n\ninline constexpr struct speed_of_light_in_vacuum final : named_unit&lt;\"c\", mag&lt;299'792'458&gt; * metre / second&gt; {} speed_of_light_in_vacuum;\n</code></pre> <p>The unit equation of <code>si::metre / si::second</code> results in the <code>derived_unit&lt;si::metre, per&lt;si::second&gt;&gt;</code> type.</p>"},{"location":"users_guide/framework_basics/design_overview/#quantity-reference","title":"Quantity reference","text":"<p>ISO defines a quantity as:</p> <p>Quote</p> <p>property of a phenomenon, body, or substance, where the property has a magnitude that can be expressed as a number and a reference</p> <p>After that, it says:</p> <p>Quote</p> <p>A reference can be a measurement unit, a measurement procedure, a reference material, or a combination of such.</p> <p>In the mp-units library, a quantity reference provides all the domain-specific metadata for the quantity besides its numerical value:</p> <ul> <li>all the data stored in the quantity specification,</li> <li>unit.</li> </ul> <p>Together with the value of a representation type, it forms a quantity.</p> <p>In the library, we have two different ways to provide a reference:</p> <ul> <li>every unit with the associated quantity kind   is a valid reference,</li> <li>providing a unit to an indexing operator of a quantity specification explicitly instantiates   a <code>reference</code> class template with this quantity spec and a unit passed as arguments.</li> </ul> <p>Note</p> <p>All the units of the SI have associated quantity kinds and may serve as a reference.</p> <p>For example:</p> <ul> <li><code>si::metre</code> is defined in the SI as a unit of <code>isq::length</code>   and thus can be used as a reference to instantiate a quantity of length (e.g., <code>42 * m</code>).</li> <li>The expression <code>isq::height[m]</code> results with <code>reference&lt;isq::height, si::metre&gt;</code>, which can be used to   instantiate a quantity of <code>isq::height</code> with a unit of <code>si::metre</code> (e.g., <code>42 * isq::height[m]</code>).</li> </ul>"},{"location":"users_guide/framework_basics/design_overview/#quantity-representation","title":"Quantity representation","text":"<p>Quantity representation defines the type used to store the numerical value of a quantity. Such a type should be of a specific quantity character provided in the quantity specification.</p> <p>Note</p> <p>By default, all floating-point and integral (besides <code>bool</code>) types are treated as scalars.</p>"},{"location":"users_guide/framework_basics/design_overview/#quantity","title":"Quantity","text":"<p>ISO defines a quantity as:</p> <p>Quote</p> <p>property of a phenomenon, body, or substance, where the property has a magnitude that can be expressed as a number and a reference</p> <p>This is why a <code>quantity</code> class template is defined in the library as:</p> <pre><code>template&lt;Reference auto R,\n         RepresentationOf&lt;get_quantity_spec(R)&gt; Rep = double&gt;\nclass quantity;\n</code></pre> <p>Its value can be easily created by multiplying/dividing the numerical value and a reference.</p> <p>For example:</p> <ul> <li>All of <code>42 * m</code>, <code>42 * si::metre</code>, <code>42 * isq::height[m]</code>, and <code>isq::height(42 * m)</code> create a quantity.</li> <li>A quantity type can also be specified explicitly (e.g., <code>quantity&lt;si::metre, int&gt;</code>,   <code>quantity&lt;isq::height[m]&gt;</code>).</li> </ul>"},{"location":"users_guide/framework_basics/design_overview/#point-origin","title":"Point origin","text":"<p>In the affine space theory, the point origin specifies where the \"zero\" of our measurement's scale is.</p> <p>In the mp-units library, we have two types of point origins:</p> <ul> <li>absolute - defines an absolute \"zero\" for our point,</li> <li>relative - defines an origin that has some \"offset\" relative   to an absolute point.</li> </ul> <p>For example:</p> <ul> <li>the absolute point origin can be defined in the following way:</li> </ul> <pre><code>inline constexpr struct absolute_zero final : absolute_point_origin&lt;isq::thermodynamic_temperature&gt; {} absolute_zero;\n</code></pre> <ul> <li>the relative point origin can be defined in the following way:</li> </ul> <pre><code>inline constexpr struct ice_point final : relative_point_origin&lt;absolute_zero + 273'150 * milli&lt;kelvin&gt;&gt; {} ice_point;\n</code></pre>"},{"location":"users_guide/framework_basics/design_overview/#quantity-point","title":"Quantity point","text":"<p>Quantity point implements a point in the affine space theory.</p> <p>In the mp-units library, the quantity point is implemented as:</p> <pre><code>template&lt;Reference auto R,\n         PointOriginFor&lt;get_quantity_spec(R)&gt; auto PO,\n         RepresentationOf&lt;get_quantity_spec(R)&gt; Rep = double&gt;\nclass quantity_point;\n</code></pre> <p>Its value can be easily created by adding/subtracting the quantity with a point origin.</p> <p>For example:</p> <ul> <li>The following specifies a quantity point defined in terms of an <code>ice_point</code> provided in   the previous example:</li> </ul> <pre><code>constexpr auto room_reference_temperature = ice_point + delta&lt;isq::Celsius_temperature[deg_C]&gt;(21);\n</code></pre>"},{"location":"users_guide/framework_basics/dimensionless_quantities/","title":"Dimensionless Quantities","text":"<p>The quantities we discussed so far always had some specific type and physical dimension. However, this is not always the case. While performing various computations, we sometimes end up with so-called \"dimensionless\" quantities, which ISO defines as quantities of dimension one:</p> <p>ISO/IEC Guide 99</p> <ul> <li>Quantity for which all the exponents of the factors corresponding to the base quantities in   its quantity dimension are zero.</li> <li>The measurement units and values of quantities of dimension one are numbers, but such quantities   convey more information than a number.</li> <li>Some quantities of dimension one are defined as the ratios of two quantities of the same kind.</li> <li>Numbers of entities are quantities of dimension one.</li> </ul>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#dividing-two-quantities-of-the-same-kind","title":"Dividing two quantities of the same kind","text":"<p>Dividing two quantities of the same kind always results in a quantity of dimension one. However, depending on what type of quantities we divide or what their units are, we may end up with slightly different results.</p> <p>Note</p> <p>In mp-units, dividing two quantities of the same dimension always results in a quantity with the dimension being <code>dimension_one</code>. This is often different for other physical units libraries, which may return a raw representation type for such cases. A raw value is also always returned from the division of two <code>std::chrono::duration</code> objects.</p> <p>To read more about the reasoning for this design decision, please check our FAQ.</p>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#dividing-quantities-of-the-same-type","title":"Dividing quantities of the same type","text":"<p>First, let's analyze what happens if we divide two quantities of the same type:</p> <pre><code>constexpr QuantityOf&lt;dimensionless&gt; auto q = isq::height(200 * m) / isq::height(50 * m);\n</code></pre> <p>In such a case, we end up with a dimensionless quantity that has the following properties:</p> <pre><code>static_assert(q.quantity_spec == dimensionless);\nstatic_assert(q.dimension == dimension_one);\nstatic_assert(q.unit == one);\n</code></pre> <p>In case we would like to print its value, we would see a raw value of <code>4</code> in the output with no unit being printed.</p>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#dividing-quantities-of-different-types","title":"Dividing quantities of different types","text":"<p>Now let's see what happens if we divide quantities of the same dimension and unit but which have different quantity types:</p> <pre><code>constexpr QuantityOf&lt;dimensionless&gt; auto q = isq::work(200 * J) / isq::heat(50 * J);\n</code></pre> <p>Again we end up with <code>dimension_one</code> and <code>one</code>, but this time:</p> <pre><code>static_assert(q.quantity_spec == isq::work / isq::heat);\n</code></pre> <p>As shown above, the result is not of a <code>dimensionless</code> type anymore. Instead, we get a quantity type derived from the performed quantity equation. According to the ISQ, work divided by heat is the recipe for the thermodynamic efficiency quantity, thus:</p> <pre><code>static_assert(implicitly_convertible(q.quantity_spec, isq::efficiency_thermodynamics));\n</code></pre> <p>Note</p> <p>The quantity of <code>isq::efficiency_thermodynamics</code> is of a kind <code>dimensionless</code>, so it is implicitly convertible to <code>dimensionless</code> and satisfies the <code>QuantityOf&lt;dimensionless&gt;</code> concept.</p>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#dividing-quantities-of-different-units","title":"Dividing quantities of different units","text":"<p>Now, let's see what happens when we divide two quantities of the same type but different units:</p> <pre><code>constexpr QuantityOf&lt;dimensionless&gt; auto q = isq::height(4 * km) / isq::height(2 * m);\n</code></pre> <p>This time, we still get a quantity of the <code>dimensionless</code> type with a <code>dimension_one</code> as its dimension. However, the resulting unit is not <code>one</code> anymore:</p> <pre><code>static_assert(q.unit == mag_power&lt;10, 3&gt; * one);\n</code></pre> <p>In case we would print the text output of this quantity, we would not see a raw value of <code>2000</code>, but <code>2 km/m</code>.</p> <p>First, it may look surprising, but this is consistent with dividing quantities of different dimensions. For example, if we divide <code>4 * km / 2 * s</code>, we do not expect <code>km</code> to be \"expanded\" to <code>m</code> before the division, right? We would expect the result of <code>2 km/s</code>, which is exactly what we get when we divide quantities of the same kind.</p> <p>This is a compelling feature that allows us to express huge or tiny ratios without the need for big and expensive representation types. With this, we can easily define things like a Hubble's constant that uses a unit that is proportional to the ratio of kilometers per megaparsecs, which are both units of length:</p> <pre><code>inline constexpr struct hubble_constant final :\n    named_unit&lt;{u8\"H\u2080\", \"H_0\"}, mag_ratio&lt;701, 10&gt; * si::kilo&lt;si::metre&gt; / si::second / si::mega&lt;parsec&gt;&gt; {} hubble_constant;\n</code></pre>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#counts-of-things","title":"Counts of things","text":"<p>Another important use case for dimensionless quantities is to provide strong types for counts of things. For example:</p> <ul> <li>ISO-80000-3 provides a rotation quantity defined as the number of revolutions,</li> <li>IEC-80000-6 provides a number of turns in a winding quantity,</li> <li>IEC-80000-13 provides a Hamming distance quantity defined as the number of digit positions   in which the corresponding digits of two words of the same length are different.</li> </ul> <p>Thanks to assigning strong names to such quantities, later on, they can be explicitly used as arguments in the quantity equations of other quantities deriving from them.</p>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#predefined-units-of-the-dimensionless-quantity","title":"Predefined units of the dimensionless quantity","text":"<p>As we observed above, the most common unit for dimensionless quantities is <code>one</code>. It has the ratio of <code>1</code> and does not output any textual symbol.</p> <p>Important: <code>one</code> is an identity</p> <p>A unit <code>one</code> is special in the entire type system of units as it is considered to be an identity operand in the unit symbolic expressions. This means that, for example:</p> <pre><code>static_assert(one * one == one);\nstatic_assert(one * si::metre == si::metre);\nstatic_assert(si::metre / si::metre == one);\n</code></pre> <p>The same is also true for <code>dimension_one</code> and <code>dimensionless</code> in the domains of dimensions and quantity specifications.</p> <p>Besides the unit <code>one</code>, there are a few other scaled units predefined in the library for usage with dimensionless quantities:</p> <pre><code>inline constexpr struct percent final : named_unit&lt;\"%\", mag_ratio&lt;1, 100&gt; * one&gt; {} percent;\ninline constexpr struct per_mille final : named_unit&lt;{u8\"\u2030\", \"%o\"}, mag_ratio&lt;1, 1000&gt; * one&gt; {} per_mille;\ninline constexpr struct parts_per_million final : named_unit&lt;\"ppm\", mag_ratio&lt;1, 1'000'000&gt; * one&gt; {} parts_per_million;\ninline constexpr auto ppm = parts_per_million;\n</code></pre>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#superpowers-of-the-unit-one","title":"Superpowers of the unit <code>one</code>","text":"<p>Quantities implicitly convertible to <code>dimensionless</code> with the unit equivalent to <code>one</code> are the only ones that are:</p> <ul> <li>implicitly constructible from the raw value,</li> <li>explicitly convertible to a raw value,</li> <li>comparable to a raw value.</li> </ul> <pre><code>quantity&lt;one&gt; inc(quantity&lt;one&gt; q) { return q + 1; }\nvoid legacy(double) { /* ... */ }\n\nif (auto q = inc(42); q != 0)\n  legacy(static_cast&lt;int&gt;(q));\n</code></pre> <p>This property also expands to usual arithmetic operators.</p> <p>Note</p> <p>Those rules do not apply to all the dimensionless quantities. It would be unsafe and misleading to allow such operations on units with a magnitude different than <code>1</code> (e.g., <code>percent</code>) or for quantities that are not implicitly convertible to <code>dimensionless</code> (e.g., <code>angular_measure</code>).</p>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#angular-quantities","title":"Angular quantities","text":"<p>Special, often controversial, examples of dimensionless quantities are an angular measure and solid angular measure quantities that are defined in the ISQ to be the result of a division of \\(arc\\; length / radius\\) and \\(area / radius^2\\) respectively. Moreover, ISQ also explicitly states that both can be expressed in the unit <code>one</code>. This means that both angular measure and solid angular measure should be of a kind dimensionless.</p> <p>On the other hand, ISQ also specifies that a unit radian can be used for angular measure, and a unit steradian can be used for solid angular measure. Those should not be mixed or used to express other types of dimensionless quantities. This means that both angular measure and solid angular measure should also be quantity kinds by themselves.</p> <p>Note</p> <p>Many people claim that angle being a dimensionless quantity is a bad idea. There are proposals submitted to make an angle a base quantity and <code>rad</code> to become a base unit. More on this topic can be found in the \"Strong Angular System\" chapter.</p>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#radians-and-degrees-support","title":"Radians and degrees support","text":"<p>Thanks to the usage of magnitudes the library provides efficient strong types for all angular types. This means that with the built-in support for magnitudes of \\(\\pi\\) we can provide accurate conversions between radians and degrees. The library also provides common trigonometric functions for angular quantities:</p> <pre><code>using namespace mp_units::si::unit_symbols;\nusing mp_units::angular::unit_symbols::rad;\nusing mp_units::angular::unit_symbols::deg;\nusing mp_units::angular::unit_symbols::grad;\n\nquantity speed = 110 * km / h;\nquantity rate_of_climb = -0.63657 * m / s;\nquantity glide_ratio = speed / -rate_of_climb;\nquantity glide_angle = angular::asin(1 / glide_ratio);\n\nstd::println(\"Glide ratio: {::N[.1f]}\", glide_ratio.in(one));\nstd::println(\"Glide angle:\");\nstd::println(\" - {::N[.4f]}\", glide_angle.in(rad));\nstd::println(\" - {::N[.2f]}\", glide_angle.in(deg));\nstd::println(\" - {::N[.2f]}\", glide_angle.in(grad));\n</code></pre> <p>The above program prints:</p> <pre><code>Glide ratio: 48.0\nGlide angle:\n - 0.0208 rad\n - 1.19\u00b0\n - 1.33\u1d4d\n</code></pre> <p>Note</p> <p>In the production code the above <code>speed</code> and <code>rate_of_climb</code> quantities should probably be modelled as separate typed quantities of the same kind.</p>"},{"location":"users_guide/framework_basics/dimensionless_quantities/#nested-quantity-kinds","title":"Nested quantity kinds","text":"<p>Angular quantities are not the only ones with such a \"strange\" behavior. Another but a similar case is a storage capacity quantity specified in IEC-80000-13 that again allows expressing it in both <code>one</code> and <code>bit</code> units.</p> <p>Those cases make dimensionless quantities an exceptional tree in the library. This quantity hierarchy contains more than one quantity kind and more than one unit in its tree:</p> <pre><code>flowchart TD\n    dimensionless[\"&lt;b&gt;dimensionless&lt;/b&gt;&lt;br&gt;[one]\"]\n    dimensionless --- rotation[\"&lt;b&gt;rotation&lt;/b&gt;\"]\n    dimensionless --- thermodynamic_efficiency[\"&lt;b&gt;thermodynamic_efficiency&lt;/b&gt;&lt;br&gt;&lt;i&gt;(work / heat)&lt;/i&gt;\"]\n    dimensionless --- angular_measure[\"&lt;b&gt;angular_measure&lt;/b&gt;&lt;br&gt;&lt;i&gt;(arc_length / radius)&lt;/i&gt;&lt;br&gt;[rad]\"]\n    angular_measure --- rotational_displacement[\"&lt;b&gt;rotational_displacement&lt;/b&gt;&lt;br&gt;&lt;i&gt;(path_length / radius)&lt;/i&gt;\"]\n    angular_measure --- phase_angle[\"&lt;b&gt;phase_angle&lt;/b&gt;\"]\n    dimensionless --- solid_angular_measure[\"&lt;b&gt;solid_angular_measure&lt;/b&gt;&lt;br&gt;&lt;i&gt;(area / pow&lt;2&gt;(radius))&lt;/i&gt;&lt;br&gt;[sr]\"]\n    dimensionless --- drag_factor[\"&lt;b&gt;drag_factor&lt;/b&gt;&lt;br&gt;&lt;i&gt;(drag_force / (mass_density * pow&lt;2&gt;(speed) * area))&lt;/i&gt;\"]\n    dimensionless --- storage_capacity[\"&lt;b&gt;storage_capacity&lt;/b&gt;&lt;br&gt;[bit]\"] --- equivalent_binary_storage_capacity[\"&lt;b&gt;equivalent_binary_storage_capacity&lt;/b&gt;\"]\n    dimensionless --- ...</code></pre> <p>To provide such support in the library, we provided an <code>is_kind</code> specifier that can be appended to the quantity specification:</p> C++23C++20Portable <pre><code>inline constexpr struct angular_measure final : quantity_spec&lt;dimensionless, arc_length / radius, is_kind&gt; {} angular_measure;\ninline constexpr struct solid_angular_measure final : quantity_spec&lt;dimensionless, area / pow&lt;2&gt;(radius), is_kind&gt; {} solid_angular_measure;\ninline constexpr struct storage_capacity final : quantity_spec&lt;dimensionless, is_kind&gt; {} storage_capacity;\n</code></pre> <pre><code>inline constexpr struct angular_measure final : quantity_spec&lt;angular_measure, dimensionless, arc_length / radius, is_kind&gt; {} angular_measure;\ninline constexpr struct solid_angular_measure final : quantity_spec&lt;solid_angular_measure, dimensionless, area / pow&lt;2&gt;(radius), is_kind&gt; {} solid_angular_measure;\ninline constexpr struct storage_capacity final : quantity_spec&lt;storage_capacity, dimensionless, is_kind&gt; {} storage_capacity;\n</code></pre> <pre><code>QUANTITY_SPEC(angular_measure, dimensionless, arc_length / radius, is_kind);\nQUANTITY_SPEC(solid_angular_measure, dimensionless, area / pow&lt;2&gt;(radius), is_kind);\nQUANTITY_SPEC(storage_capacity, dimensionless, is_kind);\n</code></pre> <p>With the above, we can constrain <code>radian</code>, <code>steradian</code>, and <code>bit</code> to be allowed for usage with specific quantity kinds only:</p> <pre><code>inline constexpr struct radian final : named_unit&lt;\"rad\", metre / metre, kind_of&lt;isq::angular_measure&gt;&gt; {} radian;\ninline constexpr struct steradian final : named_unit&lt;\"sr\", square(metre) / square(metre), kind_of&lt;isq::solid_angular_measure&gt;&gt; {} steradian;\ninline constexpr struct bit final : named_unit&lt;\"bit\", one, kind_of&lt;storage_capacity&gt;&gt; {} bit;\n</code></pre> <p>but still allow the usage of <code>one</code> and its scaled versions for such quantities.</p> <p>Info</p> <p>It is worth mentioning here that converting up the hierarchy beyond a subkind requires an explicit conversion. For example:</p> <pre><code>static_assert(implicitly_convertible(isq::rotation, dimensionless));\nstatic_assert(!implicitly_convertible(isq::angular_measure, dimensionless));\nstatic_assert(explicitly_convertible(isq::angular_measure, dimensionless));\n</code></pre> <p>This increases type safety and prevents accidental quantities with invalid units. For example, a result of a conversion from <code>isq::angular_measure[rad]</code> to <code>dimensionless</code> would be a reference of <code>dimensionless[rad]</code>, which contains an incorrect unit for a <code>dimensionless</code> quantity. Such a conversion must be explicit and be preceded by an explicit unit conversion:</p> <pre><code>quantity q1 = isq::angular_measure(42. * rad);\nquantity&lt;dimensionless[one]&gt; q2 = dimensionless(q1.in(one));\n</code></pre>"},{"location":"users_guide/framework_basics/faster_than_lightspeed_constants/","title":"Faster-than-lightspeed Constants","text":"<p>In most libraries, physical constants are implemented as constant (possibly <code>constexpr</code>) quantity values. Such an approach has some disadvantages, often affecting the run time performance and causing a loss of precision.</p>"},{"location":"users_guide/framework_basics/faster_than_lightspeed_constants/#simplifying-constants-in-an-equation","title":"Simplifying constants in an equation","text":"<p>When dealing with equations involving physical constants, they often occur more than once in an expression. Such a constant may appear both in a numerator and denominator of a quantity equation. As we know from fundamental physics, we can simplify such an expression by striking a constant out of the equation. Supporting such behavior allows a faster runtime performance and often a better precision of the resulting value.</p>"},{"location":"users_guide/framework_basics/faster_than_lightspeed_constants/#physical-constants-as-units","title":"Physical constants as units","text":"<p>The mp-units library allows and encourages the implementation of physical constants as regular units. With that, the constant's value is handled at compile-time, and under favorable circumstances, it can be simplified in the same way as all other repeated units do. If it is not simplified, the value is stored in a type, and the expensive multiplication or division operations can be delayed in time until a user selects a specific unit to represent/print the data.</p> <p>Such a feature often also allows using simpler or faster representation types in the equation. For example, instead of always having to multiply a small integral value with a big floating-point constant number, we can just use the integral type all the way. Only in case a constant will not simplify in the equation, and the user will require a specific unit, such a multiplication will be lazily invoked, and the representation type will need to be expanded to facilitate that. With that, addition, subtractions, multiplications, and divisions will always be the fastest - compiled away or done in out-of-order execution.</p> <p>To benefit from all of the above, in the mp-units library, SI defining and other constants are implemented as units in the following way:</p> <pre><code>namespace si {\n\nnamespace si2019 {\n\ninline constexpr struct speed_of_light_in_vacuum final :\n  named_unit&lt;\"c\", mag&lt;299'792'458&gt; * metre / second&gt; {} speed_of_light_in_vacuum;\n\n}  // namespace si2019\n\ninline constexpr struct magnetic_constant final :\n  named_unit&lt;{u8\"\u03bc\u2080\", \"u_0\"}, mag&lt;4&gt; * mag&lt;\u03c0&gt; * mag_power&lt;10, -7&gt; * henry / metre&gt; {} magnetic_constant;\n\n}  // namespace mp_units::si\n</code></pre>"},{"location":"users_guide/framework_basics/faster_than_lightspeed_constants/#usage-examples","title":"Usage examples","text":"<p>With the above definitions, we can calculate vacuum permittivity as:</p> <pre><code>constexpr auto permeability_of_vacuum = 1. * si::magnetic_constant;\nconstexpr auto speed_of_light_in_vacuum = 1 * si::si2019::speed_of_light_in_vacuum;\n\nQuantityOf&lt;isq::permittivity_of_vacuum&gt; auto q = 1 / (permeability_of_vacuum * pow&lt;2&gt;(speed_of_light_in_vacuum));\n\nstd::println(\"permittivity of vacuum = {} = {::N[.3e]}\", q, q.in(F / m));\n</code></pre> <p>The above first prints the following:</p> <pre><code>permittivity of vacuum = 1  \u03bc\u2080\u207b\u00b9 c\u207b\u00b2 = 8.854e-12 F/m\n</code></pre> <p>As we can clearly see, all the calculations above were just about multiplying and dividing the number <code>1</code> with the rest of the information provided as a compile-time type. Only when a user wants a specific SI unit as a result, the unit ratios are lazily resolved.</p> <p>Another similar example can be an equation for total energy:</p> <pre><code>QuantityOf&lt;isq::mechanical_energy&gt; auto total_energy(QuantityOf&lt;isq::momentum&gt; auto p,\n                                                     QuantityOf&lt;isq::mass&gt; auto m,\n                                                     QuantityOf&lt;isq::speed&gt; auto c)\n{\n  return isq::mechanical_energy(sqrt(pow&lt;2&gt;(p * c) + pow&lt;2&gt;(m * pow&lt;2&gt;(c))));\n}\n</code></pre> <pre><code>constexpr auto GeV = si::giga&lt;si::electronvolt&gt;;\nconstexpr QuantityOf&lt;isq::speed&gt; auto c = 1. * si::si2019::speed_of_light_in_vacuum;\nconstexpr auto c2 = pow&lt;2&gt;(c);\n\nconst auto p1 = isq::momentum(4. * GeV / c);\nconst QuantityOf&lt;isq::mass&gt; auto m1 = 3. * GeV / c2;\nconst auto E = total_energy(p1, m1, c);\n\nstd::cout &lt;&lt; \"in `GeV` and `c`:\\n\"\n          &lt;&lt; \"p = \" &lt;&lt; p1 &lt;&lt; \"\\n\"\n          &lt;&lt; \"m = \" &lt;&lt; m1 &lt;&lt; \"\\n\"\n          &lt;&lt; \"E = \" &lt;&lt; E &lt;&lt; \"\\n\";\n\nconst auto p2 = p1.in(GeV / (m / s));\nconst auto m2 = m1.in(GeV / pow&lt;2&gt;(m / s));\nconst auto E2 = total_energy(p2, m2, c).in(GeV);\n\nstd::cout &lt;&lt; \"\\nin `GeV`:\\n\"\n          &lt;&lt; \"p = \" &lt;&lt; p2 &lt;&lt; \"\\n\"\n          &lt;&lt; \"m = \" &lt;&lt; m2 &lt;&lt; \"\\n\"\n          &lt;&lt; \"E = \" &lt;&lt; E2 &lt;&lt; \"\\n\";\n\nconst auto p3 = p1.in(kg * m / s);\nconst auto m3 = m1.in(kg);\nconst auto E3 = total_energy(p3, m3, c).in(J);\n\nstd::cout &lt;&lt; \"\\nin SI base units:\\n\"\n          &lt;&lt; \"p = \" &lt;&lt; p3 &lt;&lt; \"\\n\"\n          &lt;&lt; \"m = \" &lt;&lt; m3 &lt;&lt; \"\\n\"\n          &lt;&lt; \"E = \" &lt;&lt; E3 &lt;&lt; \"\\n\";\n</code></pre> <p>The above prints the following:</p> <pre><code>in `GeV` and `c`:\np = 4 GeV/c\nm = 3 GeV/c\u00b2\nE = 5 GeV\n\nin `GeV`:\np = 1.33426e-08 GeV s/m\nm = 3.33795e-17 GeV s\u00b2/m\u00b2\nE = 5 GeV\n\nin SI base units:\np = 2.13771e-18 kg m/s\nm = 5.34799e-27 kg\nE = 8.01088e-10 J\n</code></pre>"},{"location":"users_guide/framework_basics/generic_interfaces/","title":"Generic Interfaces","text":"<p>Using a concrete unit in the interface often makes a lot of sense. It is especially useful if we store the data internally in the object. In such a case, we have to select a specific unit anyway.</p> <p>For example, let's consider a simple storage tank:</p> <pre><code>class StorageTank {\n  quantity&lt;horizontal_area[m2]&gt; base_;\n  quantity&lt;isq::height[m]&gt; height_;\n  quantity&lt;isq::mass_density[kg / m3]&gt; density_ = air_density;\npublic:\n  constexpr StorageTank(const quantity&lt;horizontal_area[m2]&gt;&amp; base, const quantity&lt;isq::height[m]&gt;&amp; height) :\n      base_(base), height_(height)\n  {\n  }\n\n  // ...\n};\n</code></pre> <p>As the quantities provided in the function's interface are then stored in the class, there is probably no sense in using generic interfaces here.</p>"},{"location":"users_guide/framework_basics/generic_interfaces/#the-issues-with-unit-specific-interfaces","title":"The issues with unit-specific interfaces","text":"<p>However, in many cases, using a specific unit in the interface is counterproductive. Let's consider the following function:</p> <pre><code>quantity&lt;km / h&gt; avg_speed(quantity&lt;km&gt; distance, quantity&lt;h&gt; duration)\n{\n  return distance / duration;\n}\n</code></pre> <p>Everything seems fine for now. It also works great if we call it with:</p> <pre><code>quantity&lt;km / h&gt; s1 = avg_speed(220 * km, 2 * h);\n</code></pre> <p>However, if the user starts doing the following:</p> <pre><code>quantity&lt;mi / h&gt; s2 = avg_speed(140 * mi, 2 * h);\nquantity&lt;m / s&gt; s3 = avg_speed(20 * m, 2 * s);\n</code></pre> <p>some issues start to be clearly visible:</p> <ol> <li>The arguments must be converted to units mandated by the function's parameters at each call.    This involves potentially expensive multiplication/division operations at runtime.</li> <li>After the function returns the speed in a unit of <code>km/h</code>, another potentially expensive    multiplication/division operations must be performed to convert the resulting quantity into    a unit being the derived unit of the initial function's arguments.</li> <li>Besides the obvious runtime cost, some unit conversions may result in a value truncation, which    means that the result will not be exactly equal to a direct division of the function's arguments.</li> <li> <p>We have to use a floating-point representation type (the <code>quantity</code> class template by default uses    <code>double</code> as a representation type) which is considered    value-preserving.    Trying to use an integral type in this scenario will work only for <code>s1</code>, while <code>s2</code> and <code>s3</code>    will fail to compile. Failing to compile is a good thing here as the library tries to prevent    the user from doing a clearly wrong thing. To make the code compile, the user needs to use    dedicated <code>value_cast</code> or <code>force_in</code> like this:</p> <pre><code>quantity&lt;isq::speed[mi / h]&gt; s2 = avg_speed(value_cast&lt;km&gt;(140 * mi), 2 * h);\nquantity&lt;isq::speed[m / s]&gt; s3 = avg_speed((20 * m).force_in(km), (2 * s).force_in(h));\n</code></pre> <p>but the above will obviously provide an incorrect behavior (e.g., division by <code>0</code> in the evaluation of <code>s3</code>).</p> </li> </ol>"},{"location":"users_guide/framework_basics/generic_interfaces/#a-naive-solution","title":"A naive solution","text":"<p>A naive solution here would be to implement the function as an unconstrained function template:</p> <pre><code>auto avg_speed(auto distance, auto duration)\n{\n  return distance / duration;\n}\n</code></pre> <p>Beware, this is not a good solution. The above code is too generic. Such a function template accepts everything:</p> <ul> <li>quantities of other types<ul> <li>the compiler will not prevent accidental reordering of the function's arguments,</li> <li>quantities of different types can be passed as well,</li> </ul> </li> <li>plain <code>double</code> arguments,</li> <li><code>std::vector</code> and <code>std::lock_guard</code> will be accepted as well (of course, this will fail in the   instantiation of a function's body later in the compilation process).</li> </ul> <p>Note</p> <p>The usage of <code>auto</code> instead of a function parameter type is a C++20 feature. It makes such a code a function template where the type of such a parameter will be deduced during the template instantiation process from the argument type passed by the user.</p>"},{"location":"users_guide/framework_basics/generic_interfaces/#constraining-function-template-arguments-with-concepts","title":"Constraining function template arguments with concepts","text":"<p>Much better generic code can be implemented using basic concepts provided with the library:</p> Original template notationThe shorthand notationTerse notation <pre><code>template&lt;typename Distance, typename Duration&gt;\n  requires QuantityOf&lt;Distance, isq::length&gt; &amp;&amp; QuantityOf&lt;Duration, isq::time&gt;\nauto avg_speed(Distance distance, Duration duration)\n{\n  return isq::speed(distance / duration);\n}\n</code></pre> <pre><code>template&lt;QuantityOf&lt;isq::length&gt; Distance, QuantityOf&lt;isq::time&gt; Duration&gt;\nauto avg_speed(Distance distance, Duration duration)\n{\n  return isq::speed(distance / duration);\n}\n</code></pre> <pre><code>auto avg_speed(QuantityOf&lt;isq::length&gt; auto distance,\n               QuantityOf&lt;isq::time&gt; auto duration)\n{\n  return isq::speed(distance / duration);\n}\n</code></pre> <p>This explicitly states that the arguments passed by the user must not only satisfy a <code>Quantity</code> concept, but also their quantity specification must be implicitly convertible to <code>isq::length</code> and <code>isq::time</code> accordingly. This no longer leaves room for error while still allowing the compiler to generate the most efficient code.</p> <p>Tip</p> <p>Please note that now it is safe just to use integral types all the way which again improves the runtime performance as the multiplication/division operations are often faster on the integral rather than floating-point types.</p>"},{"location":"users_guide/framework_basics/generic_interfaces/#constraining-function-template-return-type","title":"Constraining function template return type","text":"<p>The above function template resolves all of the issues described before. However, we can do even better here by additionally constraining the return type:</p> <pre><code>QuantityOf&lt;isq::speed&gt; auto avg_speed(QuantityOf&lt;isq::length&gt; auto distance,\n                                      QuantityOf&lt;isq::time&gt; auto duration)\n{\n  return isq::speed(distance / duration);\n}\n</code></pre> <p>Doing so has two important benefits:</p> <ol> <li>It informs the users of our interface about what to expect to be the result of a function    invocation. It is superior to just returning <code>auto</code>, which does not provide any hint about    the thing being returned there.</li> <li>Such a concept constrains the type returned from the function. This means that it works as    a unit test to verify if our function actually performs what it is supposed to do. If there is    an error in quantity equations, we will learn    about it right away.</li> </ol>"},{"location":"users_guide/framework_basics/generic_interfaces/#constraining-a-variable-on-the-stack","title":"Constraining a variable on the stack","text":"<p>If we know precisely what the function does in its internals and if we know the exact argument types passed to such a function, we often know the exact type that will be returned from its invocation.</p> <p>However, if we care about performance, we should often use the generic interfaces described in this chapter. A side effect is that we sometimes are unsure about the return type. Even if we know it today, it might change a week from now due to some code refactoring.</p> <p>In such cases, we can again use <code>auto</code> to denote the type:</p> <pre><code>auto s1 = avg_speed(220 * km, 2 * h);\nauto s2 = avg_speed(140 * mi, 2 * h);\nauto s3 = avg_speed(20 * m, 2 * s);\n</code></pre> <p>or benefit from CTAD:</p> <pre><code>quantity s1 = avg_speed(220 * km, 2 * h);\nquantity s2 = avg_speed(140 * mi, 2 * h);\nquantity s3 = avg_speed(20 * m, 2 * s);\n</code></pre> <p>In both cases, it is probably OK to do so as the <code>avg_speed</code> function name explicitly provides the information on what to expect as a result.</p> <p>In other scenarios where the returned quantity type is not so obvious, it is again helpful to constrain the type with a concept like so:</p> <pre><code>QuantityOf&lt;isq::speed&gt; auto s1 = avg_speed(220 * km, 2 * h);\nQuantityOf&lt;isq::speed&gt; auto s2 = avg_speed(140 * mi, 2 * h);\nQuantityOf&lt;isq::speed&gt; auto s3 = avg_speed(20 * m, 2 * s);\n</code></pre> <p>The above explicitly provides additional information about the quantity we are dealing with in the code, and it serves as a unit test checking if the \"thing\" returned from a function is actually what we expected here.</p> <p>Note</p> <p>The <code>QuantityOf</code> and <code>QuantityPointOf</code> concepts are probably the most useful, but there are a few more to play with. A list of all the concepts can be found in the Basic Concepts chapter.</p>"},{"location":"users_guide/framework_basics/interface_introduction/","title":"Interface Introduction","text":""},{"location":"users_guide/framework_basics/interface_introduction/#new-style-of-definitions","title":"New style of definitions","text":"<p>The mp-units library decided to use a rather unusual pattern to define entities. Here is how we define <code>metre</code> and <code>second</code> SI base units:</p> <pre><code>inline constexpr struct metre final : named_unit&lt;\"m\", kind_of&lt;isq::length&gt;&gt; {} metre;\ninline constexpr struct second final : named_unit&lt;\"s\", kind_of&lt;isq::time&gt;&gt; {} second;\n</code></pre> <p>Please note that the above reuses the same identifier for a type and its value. The rationale behind this is that:</p> <ul> <li>Users always work with values and never have to spell such a type name.</li> <li>The types appear in the compilation errors and during debugging.</li> </ul> <p>Important</p> <p>To improve compiler errors' readability and make it easier to correlate them with a user's written code, a new idiom in the library is to use the same identifier for a type and its instance.</p> <p>Also, to prevent possible issues in compile-time logic, all of the library's entities must be marked <code>final</code>. This prevents the users to derive own strong types from them, which would prevent symbolic expressions simplification of equivalent entities.</p>"},{"location":"users_guide/framework_basics/interface_introduction/#strong-types-instead-of-aliases","title":"Strong types instead of aliases","text":"<p>Let's look again at the above units definitions. Another important point to notice is that all the types describing entities in the library are short, nicely named identifiers that derive from longer, more verbose class template instantiations. This is really important to improve the user experience while debugging the program or analyzing the compilation error.</p> <p>Note</p> <p>Such a practice is rare in the industry. Some popular C++ physical units libraries generate enormously long error messages where even only the first line failed to fit on a slide with a tiny font.</p>"},{"location":"users_guide/framework_basics/interface_introduction/#entities-composability","title":"Entities composability","text":"<p>Many physical units libraries (in C++ or any other programming language) assign strong types to library entities (e.g., derived units). While <code>metre_per_second</code> as a type may not look too scary, consider, for example, units of angular momentum. If we followed this path, its coherent unit would look like <code>kilogram_metre_sq_per_second</code>. Now, consider how many scaled versions of this unit you would predefine in the library to ensure that all users are happy with your choice? How expensive would it be from the implementation point of view? What about potential future standardization efforts?</p> <p>This is why in mp-units, we put a strong requirement to make everything as composable as possible. For example, to create a quantity with a unit of speed, one may write:</p> <pre><code>quantity&lt;si::metre / si::second&gt; q;\n</code></pre> <p>In case we use such a unit often and would prefer to have a handy helper for it, we can always do something like this:</p> <pre><code>constexpr auto metre_per_second = si::metre / si::second;\nquantity&lt;metre_per_second&gt; q;\n</code></pre> <p>or choose any shorter identifier of our choice.</p> <p>Coming back to the angular momentum case, thanks to the composability of units, a user can create such a quantity in the following way:</p> <pre><code>using namespace mp_units::si::unit_symbols;\nauto q = la_vector{1, 2, 3} * isq::angular_momentum[kg * m2 / s];\n</code></pre> <p>It is a much better solution. It is terse and easy to understand. Please also notice how easy it is to obtain any scaled version of such a unit (e.g., <code>mg * square(mm) / min</code>) without having to introduce hundreds of types to predefine them.</p>"},{"location":"users_guide/framework_basics/interface_introduction/#value-based-equations","title":"Value-based equations","text":"<p>The mp-units library is based on C++20, significantly improving user experience. One of such improvements is the usage of value-based equations.</p> <p>As we have learned above, the entities are being used as values in the code, and they compose. Moreover, derived entities can be defined in the library using such value-based equations. This is a huge improvement compared to what we can find in other physical units libraries or what we have to deal with when we want to write some equations for <code>std::ratio</code>.</p> <p>For example, below are a few definitions of the SI derived units showing the power of C++20 extensions to Non-Type Template Parameters, which allow us to directly pass a result of the value-based unit equation to a class template definition:</p> <pre><code>inline constexpr struct newton final : named_unit&lt;\"N\", kilogram * metre / square(second)&gt; {} newton;\ninline constexpr struct pascal final : named_unit&lt;\"Pa\", newton / square(metre)&gt; {} pascal;\ninline constexpr struct joule  final : named_unit&lt;\"J\", newton * metre&gt; {} joule;\n</code></pre>"},{"location":"users_guide/framework_basics/interface_introduction/#symbolic-expressions","title":"Symbolic expressions","text":"<p>The previous chapter provided a rationale for not having predefined types for derived entities. In many libraries, such an approach results in long and unreadable compilation errors, as framework-generated types are typically far from being easy to read and understand.</p> <p>The mp-units library greatly improves the user experience by extensively using symbolic expressions. Such expressions are used consistently throughout the entire library to describe the results of:</p> <ul> <li>dimension equation - the result is put into   the <code>derived_dimension&lt;&gt;</code> class template</li> <li>quantity equation - the result is put into   the <code>derived_quantity_spec&lt;&gt;</code> class template</li> <li>unit equation - the result is put into the   <code>derived_unit&lt;&gt;</code> class template</li> </ul> <p>For example, if we take the above-defined base units and put the results of their division into the quantity class template like this:</p> <pre><code>quantity&lt;metre / second&gt; q;\n</code></pre> <p>we will observe the following type in the debugger</p> <pre><code>(gdb) ptype q\ntype = class mp_units::quantity&lt;mp_units::derived_unit&lt;metre, mp_units::per&lt;second&gt;&gt;(), double&gt; [with Rep = double] {\n</code></pre> <p>The same type identifier will be visible in the compilation error (in case it happens).</p> <p>Important</p> <p>Expressions templates are extensively used throughout the library to improve the readability of the resulting types.</p>"},{"location":"users_guide/framework_basics/interface_introduction/#identities","title":"Identities","text":"<p>As mentioned above, equations can be performed on dimensions, quantities, and units. Each such domain must introduce an identity object that can be used in the resulting expressions. Here is the list of identities used in the library:</p> Domain Concept Identity <code>Dimension</code> <code>dimension_one</code> <code>QuantitySpec</code> <code>dimensionless</code> <code>Unit</code> <code>one</code> <p>In the equations, a user can explicitly refer to an identity object. For example:</p> <pre><code>constexpr auto my_unit = one / second;\n</code></pre> <p>Note</p> <p>Another way to achieve the same result is to call an <code>inverse()</code> function:</p> <pre><code>constexpr auto my_unit = inverse(second);\n</code></pre> <p>Both cases will result in the same symbolic expression being generated and put into the wrapper class template.</p>"},{"location":"users_guide/framework_basics/interface_introduction/#supported-operations-and-their-results","title":"Supported operations and their results","text":"<p>There are only a few operations that one can do on such entities, and the result of each of them has its unique representation in the library:</p> Operation Resulting template expression arguments <code>A * B</code> <code>A, B</code> <code>B * A</code> <code>A, B</code> <code>A * A</code> <code>power&lt;A, 2&gt;</code> <code>{identity} * A</code> <code>A</code> <code>A * {identity}</code> <code>A</code> <code>A / B</code> <code>A, per&lt;B&gt;</code> <code>A / A</code> <code>{identity}</code> <code>A / {identity}</code> <code>A</code> <code>{identity} / A</code> <code>{identity}, per&lt;A&gt;</code> <code>pow&lt;2&gt;(A)</code> <code>power&lt;A, 2&gt;</code> <code>pow&lt;2&gt;({identity})</code> <code>{identity}</code> <code>sqrt(A)</code> or <code>pow&lt;1, 2&gt;(A)</code> <code>power&lt;A, 1, 2&gt;</code> <code>sqrt({identity})</code> or <code>pow&lt;1, 2&gt;({identity})</code> <code>{identity}</code>"},{"location":"users_guide/framework_basics/interface_introduction/#simplifying-the-resulting-symbolic-expressions","title":"Simplifying the resulting symbolic expressions","text":"<p>To limit the length and improve the readability of generated types, there are many rules to simplify the resulting symbolic expression.</p> <ol> <li> <p>Ordering</p> <p>The resulting comma-separated arguments of multiplication are always sorted according to a specific predicate. This is why:</p> <pre><code>static_assert(A * B == B * A);\nstatic_assert(std::is_same_v&lt;decltype(A * B), decltype(B * A)&gt;);\n</code></pre> <p>This is probably the most important of all the steps, as it allows comparing types and enables the rest of the simplification rules.</p> </li> <li> <p>Aggregation</p> <p>In case two of the same identifiers are found next to each other on the argument list they will be aggregated in one entry:</p> Before After <code>A, A</code> <code>power&lt;A, 2&gt;</code> <code>A, power&lt;A, 2&gt;</code> <code>power&lt;A, 3&gt;</code> <code>power&lt;A, 1, 2&gt;, power&lt;A, 2&gt;</code> <code>power&lt;A, 5, 2&gt;</code> <code>power&lt;A, 1, 2&gt;, power&lt;A, 1, 2&gt;</code> <code>A</code> </li> <li> <p>Simplification</p> <p>In case two of the same identifiers are found in the numerator and denominator argument lists; they are being simplified into one entry:</p> Before After <code>A, per&lt;A&gt;</code> <code>{identity}</code> <code>power&lt;A, 2&gt;, per&lt;A&gt;</code> <code>A</code> <code>power&lt;A, 3&gt;, per&lt;A&gt;</code> <code>power&lt;A, 2&gt;</code> <code>A, per&lt;power&lt;A, 2&gt;&gt;</code> <code>{identity}, per&lt;A&gt;</code> <p>It is important to notice here that only the elements with exactly the same type are being simplified. This means that, for example, <code>m/m</code> results in <code>one</code>, but <code>km/m</code> will not be simplified. The resulting derived unit will preserve both symbols and their relative magnitude. This allows us to properly print symbols of some units or constants that require such behavior. For example, the Hubble constant is expressed in <code>km\u22c5s\u207b\u00b9\u22c5Mpc\u207b\u00b9</code>, where both <code>km</code> and <code>Mpc</code> are units of length.</p> <p>Also, to prevent possible issues in compile-time logic, all of the library's entities must be marked <code>final</code>. This prevents the users to derive own strong types from them, which would prevent symbolic expression simplification of equivalent entities.</p> </li> <li> <p>Repacking</p> <p>In case an expression uses two results of other operations, the components of its arguments are repacked into one resulting type and simplified there.</p> <p>For example, assuming:</p> <pre><code>constexpr auto X = A / B;\n</code></pre> <p>then:</p> Operation Resulting template expression arguments <code>X * B</code> <code>A</code> <code>X * A</code> <code>power&lt;A, 2&gt;, per&lt;B&gt;</code> <code>X * X</code> <code>power&lt;A, 2&gt;, per&lt;power&lt;B, 2&gt;&gt;</code> <code>X / X</code> <code>{identity}</code> <code>X / A</code> <code>{identity}, per&lt;B&gt;</code> <code>X / B</code> <code>A, per&lt;power&lt;B, 2&gt;&gt;</code> </li> </ol>"},{"location":"users_guide/framework_basics/interface_introduction/#example","title":"Example","text":"<p>Thanks to all of the features described above, a user may write the code like this one:</p> <pre><code>using namespace mp_units::si::unit_symbols;\nquantity speed = 60. * isq::speed[km / h];\nquantity duration = 8 * s;\nquantity acceleration = speed / duration;\nstd::cout &lt;&lt; \"acceleration: \" &lt;&lt; acceleration &lt;&lt; \" (\" &lt;&lt; acceleration.in(m / s2) &lt;&lt; \")\\n\";\n</code></pre> <p>The <code>acceleration</code> quantity, being the result of the above code, has the following type (after stripping the <code>mp_units</code> namespace for brevity):</p> <pre><code>quantity&lt;reference&lt;derived_quantity_spec&lt;isq::speed, per&lt;isq::time&gt;&gt;{}, derived_unit&lt;si::kilo_&lt;si::metre{}&gt;, per&lt;non_si::hour, si::second&gt;&gt;{}&gt;{}, int&gt;\n</code></pre> <p>and the text output presents:</p> <pre><code>acceleration: 7.5 km h\u207b\u00b9 s\u207b\u00b9 (2.08333 m/s\u00b2)\n</code></pre>"},{"location":"users_guide/framework_basics/obtaining_metadata/","title":"Obtaining Metadata","text":""},{"location":"users_guide/framework_basics/obtaining_metadata/#quantity-spec","title":"quantity spec","text":""},{"location":"users_guide/framework_basics/obtaining_metadata/#unit","title":"unit","text":""},{"location":"users_guide/framework_basics/obtaining_metadata/#reference","title":"reference","text":""},{"location":"users_guide/framework_basics/obtaining_metadata/#quantity","title":"quantity","text":""},{"location":"users_guide/framework_basics/quantity_arithmetics/","title":"Quantity Arithmetics","text":""},{"location":"users_guide/framework_basics/quantity_arithmetics/#quantity-is-a-numeric-wrapper","title":"<code>quantity</code> is a numeric wrapper","text":"<p>If we think about it, the <code>quantity</code> class template is just a \"smart\" numeric wrapper. It exposes properly constrained set of arithmetic operations on one or two operands.</p> <p>Important: <code>quantity</code> propagates the underlying interface</p> <p>Every single arithmetic operator is exposed by the <code>quantity</code> class template only if the underlying representation type provides it as well, and when its implementation has proper semantics (e.g., returns a reasonable type).</p> <p>For example, in the following code, <code>-a</code> will compile only if <code>MyInt</code> exposes such an operation as well:</p> <pre><code>quantity a = MyInt{42} * m;\nquantity b = -a;\n</code></pre> <p>Assuming that:</p> <ul> <li><code>q</code> is our quantity,</li> <li><code>qi</code> is a quantity implicitly convertible to <code>q</code>,</li> <li><code>qk</code> is a quantity of the same kind as <code>q</code>,</li> <li><code>q1</code> is a quantity of <code>dimension_one</code> with the unit <code>one</code>,</li> <li><code>qq</code> is any other quantity,</li> <li><code>number</code> is a value of a type \"compatible\" with <code>q</code>'s representation type,</li> </ul> <p>here is the list of all the supported operators:</p> <ul> <li>unary:<ul> <li><code>+q</code></li> <li><code>-q</code></li> <li><code>++q</code></li> <li><code>q++</code></li> <li><code>--q</code></li> <li><code>q--</code></li> </ul> </li> <li>compound assignment:<ul> <li><code>q += qi</code></li> <li><code>q -= qi</code></li> <li><code>q %= qi</code></li> <li><code>q *= number</code></li> <li><code>q *= q1</code></li> <li><code>q /= number</code></li> <li><code>q /= q1</code></li> </ul> </li> <li>binary:<ul> <li><code>q + qk</code></li> <li><code>q - qk</code></li> <li><code>q % qk</code></li> <li><code>q * qq</code></li> <li><code>q * number</code></li> <li><code>number * q</code></li> <li><code>q / qq</code></li> <li><code>q / number</code></li> <li><code>number / q</code></li> </ul> </li> <li>ordering and comparison:<ul> <li><code>q == qk</code></li> <li><code>q &lt;=&gt; qk</code></li> </ul> </li> </ul> <p>As we can see, there are plenty of operations one can do on a value of a <code>quantity</code> type. As most of them are obvious, in the following chapters, we will discuss only the most important or non-trivial aspects of quantity arithmetics.</p>"},{"location":"users_guide/framework_basics/quantity_arithmetics/#addition-and-subtraction","title":"Addition and subtraction","text":"<p>Quantities can easily be added or subtracted from each other:</p> <pre><code>static_assert(1 * m + 1 * m == 2 * m);\nstatic_assert(2 * m - 1 * m == 1 * m);\nstatic_assert(isq::height(1 * m) + isq::height(1 * m) == isq::height(2 * m));\nstatic_assert(isq::height(2 * m) - isq::height(1 * m) == isq::height(1 * m));\n</code></pre> <p>The above uses the same types for LHS, RHS, and the result, but in general, we can add, subtract, or compare the values of any quantity type as long as both quantities are of the same kind. The result of such an operation will be the common type of the arguments:</p> <pre><code>static_assert(1 * km + 1.5 * m == 1001.5 * m);\nstatic_assert(isq::height(1 * m) + isq::width(1 * m) == isq::length(2 * m));\nstatic_assert(isq::height(2 * m) - isq::distance(0.5 * m) == 1.5 * m);\nstatic_assert(isq::radius(1 * m) - 0.5 * m == isq::radius(0.5 * m));\n</code></pre> <p>Note</p> <p>Please note that for the compound assignment operators, we always need to end up with the left-hand-side argument type:</p> <pre><code>static_assert((1 * m += 1 * km) == 1001 * m);\nstatic_assert((isq::length(1 * m) += isq::height(1 * m)) == isq::length(1 * m));\nstatic_assert((isq::height(1.5 * m) -= 1 * m) == isq::height(0.5 * m));\n</code></pre> <p>If we will break typical library's convertibility rules, the following code will not compile:</p> <pre><code>quantity q1 = 1 * m -= 0.5 * m;                         // Compile-time error(1)\nquantity q2 = 1 * km += 1 * m;                          // Compile-time error(2)\nquantity q3 = isq::height(1 * m) += isq::length(1 * m); // Compile-time error(3)\n</code></pre> <ol> <li>Conversion of the floating-point to integral representation type is    considered narrowing.</li> <li>Conversion of quantity with integral representation type from a unit of a higher resolution    to the one with a lower resolution is considered narrowing.</li> <li>Conversion from a more generic quantity type to a more specific one is    considered unsafe.</li> </ol>"},{"location":"users_guide/framework_basics/quantity_arithmetics/#multiplication-and-division","title":"Multiplication and division","text":"<p>Multiplying or dividing a quantity by a number does not change its quantity type or unit. However, its representation type may change. For example:</p> <pre><code>static_assert(isq::height(3 * m) * 0.5 == isq::height(1.5 * m));\n</code></pre> <p>Note</p> <p>Unless we use a compound assignment operator, in which case we always have to result with the type of the left-hand-side argument. This, together with the fact that this library tries to prevent truncation of a quantity value means, that the following does not compile:</p> <pre><code>quantity q = isq::height(3 * m) *= 0.5; // Compile-time error\n</code></pre> <p>However, suppose we multiply or divide quantities of the same or different types or we divide a raw number by a quantity. In that case, we most probably will end up in a quantity of yet another type:</p> <pre><code>static_assert(120 * km / (2 * h) == 60 * km / h);\nstatic_assert(isq::width(2 * m) * isq::length(2 * m) == isq::area(4 * m2));\nstatic_assert(50 / isq::time(1 * s) == isq::frequency(50 * Hz));\n</code></pre> <p>Note</p> <p>An exception from the above rule happens when one of the arguments is a dimensionless quantity. If we multiply or divide by such a quantity, the quantity type will not change. If such a quantity has a unit <code>one</code>, also the unit of a quantity will not change:</p> <pre><code>static_assert(120 * m / (2 * one) == 60 * m);\n</code></pre> <p>An interesting special case happens when we divide the same quantity kinds or multiply a quantity by its inverted type. In such a case, we end up with a dimensionless quantity.</p> <pre><code>static_assert(isq::height(4 * m) / isq::width(2 * m) == 2 * one); // (1)!\nstatic_assert(5 * h / (120 * min) == 0 * one);  // (2)!\nstatic_assert(5. * h / (120 * min) == 2.5 * one);\n</code></pre> <ol> <li>The resulting quantity type of the LHS is <code>isq::height / isq::width</code>, which is a quantity of the dimensionless kind.</li> <li>The resulting quantity of the LHS is <code>0 * dimensionless[h / min]</code>. To be consistent with the division of different quantity types, we do not convert quantity values to a common unit before the division.</li> </ol> <p>Important: Beware of integral division</p> <p>The physical units library can't do any runtime branching logic for the division operator. All logic must be done at compile-time when the actual values are unknown, and the quantity types can't change at runtime.</p> <p>If we expect <code>120 * km / (2 * h)</code> to return <code>60 km / h</code>, we have to agree with the fact that <code>5 * km / (24 * h)</code> returns <code>0 km/h</code>. We can't do a range check at runtime to dynamically adjust scales and types based on the values of provided function arguments.</p> <p>This is why we often prefer floating-point representation types when dealing with units. Some popular physical units libraries even forbid integer division at all.</p>"},{"location":"users_guide/framework_basics/quantity_arithmetics/#modulo","title":"Modulo","text":"<p>Now that we know how addition, subtraction, multiplication, and division work, it is time to discuss modulo. What would we expect to be returned from the following quantity equation?</p> <pre><code>auto q = 5 * h % (120 * min);\n</code></pre> <p>Most of us would probably expect to see <code>1 h</code> or <code>60 min</code> as a result. And this is where the problems start.</p> <p>C++ language defines its <code>/</code> and <code>%</code> operators with the quotient-remainder theorem:</p> <pre><code>q = a / b;\nr = a % b;\nq * b + r == a;\n</code></pre> <p>The important property of the modulo operation is that it only works for integral representation types (it is undefined what modulo for floating-point types means). However, as we saw in the previous chapter, integral types are tricky because they often truncate the value.</p> <p>From the quotient-remainder theorem, the result of modulo operation is <code>r = a - q * b</code>. Let's see what we get from such a quantity equation on integral representation types:</p> <pre><code>const quantity a = 5 * h;\nconst quantity b = 120 * min;\nconst quantity q = a / b;\nconst quantity r = a - q * b;\n\nstd::cout &lt;&lt; \"reminder: \" &lt;&lt; r &lt;&lt; \"\\n\";\n</code></pre> <p>The above code outputs:</p> <pre><code>reminder: 5 h\n</code></pre> <p>And now, a tough question needs an answer. Do we really want modulo operation on physical units to be consistent with the quotient-remainder theorem and return <code>5 h</code> for <code>5 * h % (120 * min)</code>?</p> <p>This is exactly why we decided not to follow this hugely surprising path in the mp-units library. The selected approach was also consistent with the feedback from the C++ experts. For example, this is what Richard Smith said about this issue:</p> <p>Richard Smith</p> <p>I think the quotient-remainder property is a less important motivation here than other factors -- the constraints on <code>%</code> and <code>/</code> are quite different, so they lack the inherent connection they have for integers. In particular, I would expect that <code>A / B</code> works for all quantities <code>A</code> and <code>B</code>, whereas <code>A % B</code> is only meaningful when <code>A</code> and <code>B</code> have the same dimension. It seems like a nice-to-have for the property to apply in the case where both <code>/</code> and <code>%</code> are defined, but internal consistency of <code>/</code> across all cases seems much more important to me.</p> <p>I would expect <code>61 min % 1 h</code> to be <code>1 min</code>, and <code>1 h % 59 min</code> to also be <code>1 min</code>, so my intuition tells me that the result type of <code>A % B</code>, where <code>A</code> and <code>B</code> have the same dimension, should have the smaller unit of <code>A</code> and <code>B</code> (and if the smaller one doesn't divide the larger one, we should either use the <code>gcd / std::common_type</code> of the units of <code>A</code> and <code>B</code> or perhaps just produce an error). I think any other behavior for <code>%</code> is hard to defend.</p> <p>On the other hand, for division it seems to me that the choice of unit should probably not affect the result, and so if we want that <code>5 mm / 120 min = 0 mm/min</code>, then <code>5 h / 120 min == 0 hc</code> (where <code>hc</code> is a dimensionless \"hexaconta\", or <code>60x</code>, unit). I don't like the idea of taking SI base units into account; that seems arbitrary and like it would do the wrong thing as often as it does the right thing, especially when the units have a multiplier that is very large or small. We could special-case the situation of a dimensionless quantity, but that could lead to problematic overflow pretty easily: a calculation such as <code>10 s * 5 GHz * 2 uW</code> would overflow an <code>int</code> if it produces a dimensionless quantity for <code>10 s * 5 GHz</code>, but it could equally produce <code>50 G * 2 uW = 100 kW</code> without any overflow, and presumably would if the terms were merely reordered.</p> <p>If people want to use integer-valued quantities, I think it's fundamental that you need to know what the units of the result of an operation will be, and take that into account in how you express computations; the simplest rule for heterogeneous operators like <code>*</code> or <code>/</code> seems to be that the units of the result are determined by applying the operator to the units of the operands -- and for homogeneous operators like <code>+</code> or <code>%</code>, it seems like the only reasonable option is that you get the <code>std::common_type</code> of the units of the operands.</p> <p>To summarize, the modulo operation on physical units has more in common with addition and division operators than with the quotient-remainder theorem. To avoid surprising results, the operation uses a common unit to do the calculation and provide its result:</p> <pre><code>static_assert(5 * h / (120 * min) == 0 * one);\nstatic_assert(5 * h % (120 * min) == 60 * min);\nstatic_assert(61 * min % (1 * h) == 1 * min);\nstatic_assert(1 * h % (59 * min) == 1 * min);\n</code></pre>"},{"location":"users_guide/framework_basics/quantity_arithmetics/#comparison-against-zero","title":"Comparison against zero","text":"<p>In our code, we often want to compare the value of a quantity against zero. For example, we do it every time we want to ensure that we deal with a non-zero or positive value.</p> <p>We could implement such checks in the following way:</p> <pre><code>if (q1 / q2 != 0 * m / s)\n  // ...\n</code></pre> <p>The above would work (assuming we are dealing with the quantity of speed) but could be suboptimal if the result of <code>q1 / q2</code> is not expressed in <code>m / s</code>. To eliminate the need for conversion, we need to write:</p> <pre><code>if (auto q = q1 / q2; q != q.zero())\n  // ...\n</code></pre> <p>but that is a bit inconvenient, and inexperienced users could be unaware of this technique and its reasons.</p> <p>For the above reasons, the library provides dedicated interfaces to compare against zero that follow the naming convention of named comparison functions in the C++ Standard Library. The mp-units/compare.h header file exposes the following functions:</p> <ul> <li><code>is_eq_zero</code></li> <li><code>is_neq_zero</code></li> <li><code>is_lt_zero</code></li> <li><code>is_gt_zero</code></li> <li><code>is_lteq_zero</code></li> <li><code>is_gteq_zero</code></li> </ul> <p>Thanks to them, to save typing and not pay for unneeded conversions, our check could be implemented as follows:</p> <pre><code>if (is_neq_zero(q1 / q2))\n  // ...\n</code></pre> <p>Tip</p> <p>Those functions will work with any type <code>T</code> that exposes <code>zero()</code> member function returning something comparable to <code>T</code>. Thanks to that, we can use them not only with quantities but also with <code>std::chrono::duration</code> or any other type that exposes such an interface.</p>"},{"location":"users_guide/framework_basics/quantity_arithmetics/#other-maths","title":"Other maths","text":"<p>This chapter scopes only on the <code>quantity</code> type's operators. However, there are many named math functions taking quantities as arguments. Those can be found in the mp-units/math.h header file. Among others, we can find there the following:</p> <ul> <li><code>pow()</code>, <code>sqrt()</code>, <code>cbrt()</code>,</li> <li><code>exp()</code>,</li> <li><code>abs()</code>,</li> <li><code>epsilon()</code>,</li> <li><code>fma()</code>, <code>fmod()</code>, <code>remainder()</code>,</li> <li><code>isfinite()</code>, <code>isinf()</code>, <code>isnan()</code>,</li> <li><code>floor()</code>, <code>ceil()</code>, <code>round()</code>,</li> <li><code>inverse()</code>,</li> <li><code>hypot()</code>,</li> <li><code>sin()</code>, <code>cos()</code>, <code>tan()</code>,</li> <li><code>asin()</code>, <code>acos()</code>, <code>atan()</code>, <code>atan2()</code>.</li> </ul> <p>In the library, we can also find mp-units/random.h header file with all the pseudo-random number generators working on quantity types.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/","title":"Simple and Typed Quantities","text":"<p>ISO defines a quantity as:</p> <p>Quote</p> <p>property of a phenomenon, body, or substance, where the property has a magnitude that can be expressed as a number and a reference</p> <p>After that, it says:</p> <p>Quote</p> <p>A reference can be a measurement unit, a measurement procedure, a reference material, or a combination of such.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#quantity-class-template","title":"<code>quantity</code> class template","text":"<p>In the mp-units library, a quantity is represented with the following class template:</p> <pre><code>template&lt;Reference auto R,\n         RepresentationOf&lt;get_quantity_spec(R)&gt; Rep = double&gt;\nclass quantity;\n</code></pre> <p>The concept <code>Reference</code> is satisfied by a type that provides all the domain-specific metadata describing a quantity (besides the representation type and its value). Such a type can be either:</p> <ul> <li>a unit with an associated quantity type (e.g., <code>si::metre</code>, <code>m / s</code>),</li> <li>a reference type explicitly specifying the quantity type and its unit.</li> </ul> <p>Important</p> <p>All units in the SI system have an associated quantity type.</p> <p>A reference type is implicitly created as a result of the following expression:</p> <pre><code>constexpr auto ref = isq::length[m];\n</code></pre> <p>The above example results in the following type <code>reference&lt;isq::length(), si::metre()&gt;</code> being instantiated.</p> <p>As we have two alternative options that satisfy the <code>Reference</code> concept in the mp-units library, we also have two modes of dealing with quantities.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#simple-quantities","title":"Simple quantities","text":"<p>The simple mode might be preferred by many developers. It is all about units. Quantities using this mode have shorter type identifiers, resulting in easier-to-understand error messages and better debugging experience.</p> <p>Here is a simple example showing how to deal with such quantities:</p> C++ modulesHeader files <pre><code>#include &lt;print&gt;\nimport mp_units;\n\nusing namespace mp_units;\n\nconstexpr quantity&lt;si::metre / si::second&gt; avg_speed(quantity&lt;si::metre&gt; dist,\n                                                     quantity&lt;si::second&gt; time)\n{\n  return dist / time;\n}\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n\n  const quantity distance = 110 * km;\n  const quantity duration = 2 * h;\n  const quantity speed = avg_speed(distance, duration);\n\n  std::println(\"A car driving {} in {} has an average speed of {::N[.4]} ({::N[.4]})\",\n               distance, duration, speed, speed.in(km / h));\n}\n</code></pre> <pre><code>#include &lt;mp-units/systems/si.h&gt;\n#include &lt;print&gt;\n\nusing namespace mp_units;\n\nconstexpr quantity&lt;si::metre / si::second&gt; avg_speed(quantity&lt;si::metre&gt; dist,\n                                                     quantity&lt;si::second&gt; time)\n{\n  return dist / time;\n}\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n\n  const quantity distance = 110 * km;\n  const quantity duration = 2 * h;\n  const quantity speed = avg_speed(distance, duration);\n\n  std::println(\"A car driving {} in {} has an average speed of {::N[.4]} ({::N[.4]})\",\n               distance, duration, speed, speed.in(km / h));\n}\n</code></pre> <p>The code above prints:</p> <pre><code>A car driving 110 km in 2 h has an average speed of 15.28 m/s (55 km/h)\n</code></pre> <p>Try it on Compiler Explorer</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#user-provided-unit-wrappers","title":"User-provided unit wrappers","text":"<p>Sometimes it might be awkward to type some derived units:</p> <pre><code>quantity speed = 60 * km / h;\n</code></pre> <p>In case such a unit is used a lot in the project, a user can easily provide a nicely named wrapper for it with:</p> <pre><code>constexpr auto kmph = km / h;\nquantity speed = 60 * kmph;\n</code></pre>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#easy-to-understand-compilation-error-messages","title":"Easy-to-understand compilation error messages","text":"<p>In case a user makes an error in a quantity equation and the result of the calculation will not match the function return type, the compiler will detect such an issue at compile-time.</p> <p>For example, in case we will make the following error:</p> <pre><code>constexpr quantity&lt;si::metre / si::second&gt; avg_speed(quantity&lt;si::metre&gt; dist,\n                                                     quantity&lt;si::second&gt; time)\n{\n  return dist * time;  // (1)!\n}\n</code></pre> <ol> <li>Quantities multiplied (instead of divided) by accident.</li> </ol> <p>the following compilation error message will be provided:</p> <pre><code>error: no viable conversion from returned value of type\n       'quantity&lt;mp_units::derived_unit&lt;mp_units::si::metre, mp_units::si::second&gt;{{{}}}, [...]&gt;'\n       to function return type\n       'quantity&lt;mp_units::derived_unit&lt;mp_units::si::metre, mp_units::per&lt;mp_units::si::second&gt;&gt;{{{}}}, [...]&gt;'\n   10 |   return dist * time;\n      |          ^~~~~~~~~~~\n</code></pre>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#typed-quantities","title":"Typed quantities","text":"<p>Simple mode is all about and just about units. Typed quantities should be preferred if we also want to be quantity-safe. This, for example, allows us to specify if we deal with width, height, or radius and ensure we will not assign one to another by accident.</p> <p>The previous example can be re-typed using typed quantities in the following way:</p> C++ modulesHeader files <pre><code>#include &lt;print&gt;\nimport mp_units;\n\nusing namespace mp_units;\n\nconstexpr quantity&lt;isq::speed[si::metre / si::second]&gt; avg_speed(quantity&lt;isq::length[si::metre]&gt; dist,\n                                                                 quantity&lt;isq::time[si::second]&gt; time)\n{\n  return dist / time;\n}\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n\n  const quantity distance = isq::distance(110 * km);\n  const quantity duration = isq::time(2 * h);\n  const quantity speed = avg_speed(distance, duration);\n\n  std::println(\"A car driving {} in {} has an average speed of {::N[.4]} ({::N[.4]})\",\n               distance, duration, speed, speed.in(km / h));\n}\n</code></pre> <pre><code>#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#include &lt;print&gt;\n\nusing namespace mp_units;\n\nconstexpr quantity&lt;isq::speed[si::metre / si::second]&gt; avg_speed(quantity&lt;isq::length[si::metre]&gt; dist,\n                                                                 quantity&lt;isq::time[si::second]&gt; time)\n{\n  return dist / time;\n}\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n\n  const quantity distance = isq::distance(110 * km);\n  const quantity duration = isq::time(2 * h);\n  const quantity speed = avg_speed(distance, duration);\n\n  std::println(\"A car driving {} in {} has an average speed of {::N[.4]} ({::N[.4]})\",\n               distance, duration, speed, speed.in(km / h));\n}\n</code></pre> <pre><code>A car driving 110 km in 2 h has an average speed of 15.28 m/s (55 km/h)\n</code></pre> <p>Try it on Compiler Explorer</p> <p>In case we will accidentally make the same calculation error as before, this time, we will get a bit longer error message, this time also containing information about the quantity type:</p> <pre><code>error: no viable conversion from returned value of type\n       'quantity&lt;reference&lt;get_quantity_spec(metre{}) * struct time{{{}}}, metre{} * second{{}}&gt;{}, [...]&gt;'\n       to function return type\n       'quantity&lt;reference&lt;speed{}, derived_unit&lt;metre, per&lt;second&gt;&gt;{}&gt;{}, [...]&gt;'\n   12 |   return dist * time;\n      |          ^~~~~~~~~~~\n</code></pre> <p>As we can see above, the compilation error is longer but still relatively easy to understand.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#quantity-safety-with-typed-quantities","title":"Quantity-safety with typed quantities","text":"<p>Based on the previous example, it might seem that typed quantities are not that useful, more to type and provide harder-to-understand error messages. It might be true in some cases, but there are scenarios where they offer additional level of safety.</p> <p>Let's see another example:</p> C++ modulesHeader files SimpleTyped <pre><code>#include &lt;numbers&gt;\nimport mp_units;\n\nusing namespace mp_units;\n\nclass StorageTank {\n  quantity&lt;square(si::metre)&gt; base_;\n  quantity&lt;si::metre&gt; height_;\npublic:\n  constexpr StorageTank(const quantity&lt;square(si::metre)&gt;&amp; base,\n                        const quantity&lt;si::metre&gt;&amp; height) :\n    base_(base), height_(height)\n  {\n  }\n\n  // ...\n};\n\nclass CylindricalStorageTank : public StorageTank {\npublic:\n  constexpr CylindricalStorageTank(const quantity&lt;si::metre&gt;&amp; radius,\n                                   const quantity&lt;si::metre&gt;&amp; height) :\n    StorageTank(std::numbers::pi * pow&lt;2&gt;(radius), height)\n  {\n  }\n};\n\nclass RectangularStorageTank : public StorageTank {\npublic:\n  constexpr RectangularStorageTank(const quantity&lt;si::metre&gt;&amp; length,\n                                   const quantity&lt;si::metre&gt;&amp; width,\n                                   const quantity&lt;si::metre&gt;&amp; height) :\n    StorageTank(length * width, height)\n  {\n  }\n};\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n  auto tank = RectangularStorageTank(1'000 * mm, 500 * mm, 200 * mm);\n  // ...\n}\n</code></pre> <pre><code>#include &lt;numbers&gt;\nimport mp_units;\n\nusing namespace mp_units;\n\n// add a custom quantity type of kind isq::length\ninline constexpr struct horizontal_length final :\n    quantity_spec&lt;isq::length&gt; {} horizontal_length;\n\n// add a custom derived quantity type of kind isq::area\n// with a constrained quantity equation\ninline constexpr struct horizontal_area final :\n    quantity_spec&lt;isq::area, horizontal_length * isq::width&gt; {} horizontal_area;\n\nclass StorageTank {\n  quantity&lt;horizontal_area[square(si::metre)]&gt; base_;\n  quantity&lt;isq::height[si::metre]&gt; height_;\npublic:\n  constexpr StorageTank(const quantity&lt;horizontal_area[square(si::metre)]&gt;&amp; base,\n                        const quantity&lt;isq::height[si::metre]&gt;&amp; height) :\n    base_(base), height_(height)\n  {\n  }\n\n  // ...\n};\n\nclass CylindricalStorageTank : public StorageTank {\npublic:\n  constexpr CylindricalStorageTank(const quantity&lt;isq::radius[si::metre]&gt;&amp; radius,\n                                   const quantity&lt;isq::height[si::metre]&gt;&amp; height) :\n    StorageTank(quantity_cast&lt;horizontal_area&gt;(std::numbers::pi * pow&lt;2&gt;(radius)),\n                height)\n  {\n  }\n};\n\nclass RectangularStorageTank : public StorageTank {\npublic:\n  constexpr RectangularStorageTank(const quantity&lt;horizontal_length[si::metre]&gt;&amp; length,\n                                   const quantity&lt;isq::width[si::metre]&gt;&amp; width,\n                                   const quantity&lt;isq::height[si::metre]&gt;&amp; height) :\n    StorageTank(length * width, height)\n  {\n  }\n};\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n  auto tank = RectangularStorageTank(horizontal_length(1'000 * mm),\n                                     isq::width(500 * mm),\n                                     isq::height(200 * mm));\n  // ...\n}\n</code></pre> SimpleTyped <pre><code>#include &lt;mp-units/math.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#include &lt;numbers&gt;\n\nusing namespace mp_units;\n\nclass StorageTank {\n  quantity&lt;square(si::metre)&gt; base_;\n  quantity&lt;si::metre&gt; height_;\npublic:\n  constexpr StorageTank(const quantity&lt;square(si::metre)&gt;&amp; base,\n                        const quantity&lt;si::metre&gt;&amp; height) :\n    base_(base), height_(height)\n  {\n  }\n\n  // ...\n};\n\nclass CylindricalStorageTank : public StorageTank {\npublic:\n  constexpr CylindricalStorageTank(const quantity&lt;si::metre&gt;&amp; radius,\n                                   const quantity&lt;si::metre&gt;&amp; height) :\n    StorageTank(std::numbers::pi * pow&lt;2&gt;(radius), height)\n  {\n  }\n};\n\nclass RectangularStorageTank : public StorageTank {\npublic:\n  constexpr RectangularStorageTank(const quantity&lt;si::metre&gt;&amp; length,\n                                   const quantity&lt;si::metre&gt;&amp; width,\n                                   const quantity&lt;si::metre&gt;&amp; height) :\n    StorageTank(length * width, height)\n  {\n  }\n};\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n  auto tank = RectangularStorageTank(1'000 * mm, 500 * mm, 200 * mm);\n  // ...\n}\n</code></pre> <pre><code>#include &lt;mp-units/math.h&gt;\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#include &lt;numbers&gt;\n\nusing namespace mp_units;\n\n// add a custom quantity type of kind isq::length\ninline constexpr struct horizontal_length final :\n    quantity_spec&lt;isq::length&gt; {} horizontal_length;\n\n// add a custom derived quantity type of kind isq::area\n// with a constrained quantity equation\ninline constexpr struct horizontal_area final :\n    quantity_spec&lt;isq::area, horizontal_length * isq::width&gt; {} horizontal_area;\n\nclass StorageTank {\n  quantity&lt;horizontal_area[square(si::metre)]&gt; base_;\n  quantity&lt;isq::height[si::metre]&gt; height_;\npublic:\n  constexpr StorageTank(const quantity&lt;horizontal_area[square(si::metre)]&gt;&amp; base,\n                        const quantity&lt;isq::height[si::metre]&gt;&amp; height) :\n    base_(base), height_(height)\n  {\n  }\n\n  // ...\n};\n\nclass CylindricalStorageTank : public StorageTank {\npublic:\n  constexpr CylindricalStorageTank(const quantity&lt;isq::radius[si::metre]&gt;&amp; radius,\n                                   const quantity&lt;isq::height[si::metre]&gt;&amp; height) :\n    StorageTank(quantity_cast&lt;horizontal_area&gt;(std::numbers::pi * pow&lt;2&gt;(radius)),\n                height)\n  {\n  }\n};\n\nclass RectangularStorageTank : public StorageTank {\npublic:\n  constexpr RectangularStorageTank(const quantity&lt;horizontal_length[si::metre]&gt;&amp; length,\n                                   const quantity&lt;isq::width[si::metre]&gt;&amp; width,\n                                   const quantity&lt;isq::height[si::metre]&gt;&amp; height) :\n    StorageTank(length * width, height)\n  {\n  }\n};\n\nint main()\n{\n  using namespace mp_units::si::unit_symbols;\n  auto tank = RectangularStorageTank(horizontal_length(1'000 * mm),\n                                     isq::width(500 * mm),\n                                     isq::height(200 * mm));\n  // ...\n}\n</code></pre> <p>In the above example, the highlighted call doesn't look that safe anymore in the case of simple quantities, right? Suppose someone, either by mistake or due to some refactoring, will call the function with an invalid order of arguments. In that case, the program will compile fine but not work as expected.</p> <p>Let's see what will happen if we reorder the arguments in the case of typed quantities:</p> <pre><code>auto tank = RectangularStorageTank(horizontal_length(1'000 * mm),\n                                   isq::height(200 * mm),\n                                   isq::width(500 * mm));\n</code></pre> <p>This time, a compiler provides the following compilation error:</p> <pre><code>&lt;source&gt;:53:15: error: no matching constructor for initialization of 'RectangularStorageTank'\n   53 |   auto tank = RectangularStorageTank(horizontal_length(1'000 * mm),\n      |               ^                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   54 |                                      isq::height(200 * mm),\n      |                                      ~~~~~~~~~~~~~~~~~~~~~~\n   55 |                                      isq::width(500 * mm));\n      |                                      ~~~~~~~~~~~~~~~~~~~~\n&lt;source&gt;:43:13: note: candidate constructor not viable: no known conversion from\n                'quantity&lt;mp_units::reference&lt;mp_units::isq::height{{{{{}}}}},\n                                              mp_units::si::milli_&lt;mp_units::si::metre{{}}&gt;{{{{}}}}&gt;{}, int&gt;' to\n                'const quantity&lt;reference&lt;width{}, metre{}&gt;{}, (default) double&gt;' for 2nd argument\n   43 |   constexpr RectangularStorageTank(const quantity&lt;horizontal_length[m]&gt;&amp; length,\n      |             ^\n   44 |                                    const quantity&lt;isq::width[m]&gt;&amp; width,\n      |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>What about derived quantities? In the above example, you probably noticed that we also defined a custom <code>horizontal_area</code> quantity of kind <code>isq::area</code>. This quantity has the unique property of being implicitly constructible only from the result of the multiplication of quantities of <code>horizontal_area</code> and <code>isq::width</code> or the ones that implicitly convert to them.</p> <p>Based on the above error message, we already know that a quantity of <code>isq::height</code> is not implicitly constructible to the quantity of <code>isq::width</code>. This property is transitively passed to derived quantities using them. If by accident, we will try to create a <code>StorageTank</code> base class in the following way:</p> <pre><code>class RectangularStorageTank : public StorageTank {\npublic:\n  constexpr RectangularStorageTank(const quantity&lt;horizontal_length[m]&gt;&amp; length,\n                                   const quantity&lt;isq::width[m]&gt;&amp; width,\n                                   const quantity&lt;isq::height[m]&gt;&amp; height) :\n    StorageTank(length * height, height)\n  {\n  }\n};\n</code></pre> <p>we will again get a compilation error message like this one:</p> <pre><code>error: no matching constructor for initialization of 'StorageTank'\n   46 |     StorageTank(length * height, height)\n      |     ^           ~~~~~~~~~~~~~~~~~~~~~~~\n&lt;source&gt;:22:13: note: candidate constructor not viable: no known conversion from\n                'quantity&lt;mp_units::reference&lt;mp_units::derived_quantity_spec&lt;horizontal_length, mp_units::isq::height&gt;{{}, {{}}},\n                                              mp_units::derived_unit&lt;mp_units::power&lt;mp_units::si::metre, 2&gt;&gt;{{{}}}&gt;{}, [...]&gt;' to\n                'const quantity&lt;reference&lt;horizontal_area{}, derived_unit&lt;power&lt;metre, 2&gt;&gt;{}&gt;{}, [...]&gt;' for 1st argument\n   22 |   constexpr StorageTank(const quantity&lt;horizontal_area[m2]&gt;&amp; base,\n      |             ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre> <p>Tip</p> <p>If you need to use various quantities of the same kind, consider using typed quantities to bring an additional level of safety to your project.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#quantity_cast-to-force-unsafe-conversions","title":"<code>quantity_cast()</code> to force unsafe conversions","text":"<p>Did you notice the <code>quantity_cast()</code> usage in the other child class?</p> <pre><code>class CylindricalStorageTank : public StorageTank {\npublic:\n  constexpr CylindricalStorageTank(const quantity&lt;isq::radius[m]&gt;&amp; radius,\n                                   const quantity&lt;isq::height[m]&gt;&amp; height) :\n    StorageTank(quantity_cast&lt;horizontal_area&gt;(std::numbers::pi * pow&lt;2&gt;(radius)),\n                height)\n  {\n  }\n};\n</code></pre> <p>As <code>isq::radius</code> is not convertible to <code>horizontal_length</code>, the derived quantity of <code>pow&lt;2&gt;(radius)</code> can't be converted to <code>horizontal_area</code> as well. It would be unsafe to allow such a conversion as not all of the circles lie flat on the ground, right?</p> <p>In such a case, the user has to explicitly force such an unsafe conversion with the help of a <code>quantity_cast()</code>. This function name is easy to spot in code reviews or while searching the project for problems if something goes sideways. In case of unexpected quantities-related issues, this should be the first function to look for.</p> <p>Tip</p> <p>Do not overuse <code>quantity_cast()</code>. Use it only when necessary and ensure that the requested conversion is exactly what you need in this case.</p>"},{"location":"users_guide/framework_basics/simple_and_typed_quantities/#which-mode-should-i-use-in-my-project","title":"Which mode should I use in my project?","text":"<p>We have good news for you if you wonder which mode you should choose for your project. Simple and typed quantity modes can be freely mixed with each other. When you use different quantities of the same kind (e.g., radius, wavelength, altitude, ...), you should probably reach for typed quantities to bring additional safety for those cases. Otherwise, just use simple mode for the remaining quantities. The mp-units library will do its best to protect your project based on the information provided.</p> <p>Tip</p> <p>You can easily mix simple and typed quantities in your project.</p>"},{"location":"users_guide/framework_basics/systems_of_quantities/","title":"Systems of Quantities","text":"<p>The physical units libraries on the market typically only scope on modeling one or more systems of units. However, this is not the only system kind to model. Another, and maybe even more important, system kind is a system of quantities.</p> <p>Info</p> <p>Please note that the mp-units is probably the first library on the Open Source market (in any programming language) that models the ISQ with all its definitions provided in ISO 80000. Please provide feedback if something looks odd or could be improved.</p>"},{"location":"users_guide/framework_basics/systems_of_quantities/#dimension-is-not-enough-to-describe-a-quantity","title":"Dimension is not enough to describe a quantity","text":"<p>Most of the products on the market are aware of physical dimensions. However, a dimension is not enough to describe a quantity. For example, let's see the following implementation:</p> <pre><code>class Box {\n  area base_;\n  length height_;\npublic:\n  Box(length l, length w, length h) : base_(l * w), height_(h) {}\n  // ...\n};\n\nBox my_box(2 * m, 3 * m, 1 * m);\n</code></pre> <p>How do you like such an interface? It turns out that in most existing strongly-typed libraries this is often the best we can do </p> <p>Another typical question many users ask is how to deal with work and torque. Both of those have the same dimension but are different quantities.</p> <p>A similar issue is related to figuring out what should be the result of:</p> <pre><code>auto res = 1 * Hz + 1 * Bq + 1 * Bd;\n</code></pre> <p>where:</p> <ul> <li><code>Hz</code> (hertz) - unit of frequency</li> <li><code>Bq</code> (becquerel) - unit of activity</li> <li><code>Bd</code> (baud) - unit of modulation rate</li> </ul> <p>All of those quantities have the same dimension, namely \\(\\mathsf{T}^{-1}\\), but probably it is not wise to allow adding, subtracting, or comparing them, as they describe vastly different physical properties.</p> <p>If the above example seems too abstract, let's consider a fuel consumption (fuel volume divided by distance, e.g., <code>6.7 l/km</code>) and an area. Again, both have the same dimension \\(\\mathsf{L}^{2}\\), but probably it wouldn't be wise to allow adding, subtracting, or comparing a fuel consumption of a car and the area of a football field. Such an operation does not have any physical sense and should fail to compile.</p> <p>Important</p> <p>More than one quantity may be defined for the same dimension:</p> <ul> <li>quantities of different kinds (e.g. frequency, modulation rate, activity, ...)</li> <li>quantities of the same kind (e.g. length, width, altitude, distance, radius,   wavelength, position vector, ...)</li> </ul> <p>It turns out that the above issues can't be solved correctly without proper modeling of a system of quantities.</p>"},{"location":"users_guide/framework_basics/systems_of_quantities/#quantities-of-the-same-kind","title":"Quantities of the same kind","text":"<p>ISO 80000-1</p> <ul> <li>Quantities may be grouped together into categories of quantities that are   mutually comparable</li> <li>Mutually comparable quantities are called quantities of the same kind</li> <li>Two or more quantities cannot be added or subtracted unless they belong to the same category   of mutually comparable quantities</li> <li>Quantities of the same kind within a given system of quantities have the same quantity   dimension</li> <li>Quantities of the same dimension are not necessarily of the same kind</li> </ul> <p>The above quotes from ISO 80000 provide answers to all the issues above. Two quantities can't be added, subtracted, or compared unless they belong to the same kind. As frequency, activity, and modulation rate are of different kinds, the expression provided above should not compile.</p>"},{"location":"users_guide/framework_basics/systems_of_quantities/#system-of-quantities-is-not-only-about-kinds","title":"System of quantities is not only about kinds","text":"<p>ISO 80000 specify hundreds of different quantities. There are plenty of different kinds provided and often each kind contains more than one quantity. In fact, it turns out that such quantities form a hierarchy of quantities of the same kind.</p> <p>For example, here are all quantities of the kind length provided in the ISO 80000:</p> <pre><code>flowchart TD\n    length[\"&lt;b&gt;length&lt;/b&gt;&lt;br&gt;[m]\"]\n    length --- width[\"&lt;b&gt;width&lt;/b&gt; / &lt;b&gt;breadth&lt;/b&gt;\"]\n    length --- height[\"&lt;b&gt;height&lt;/b&gt; / &lt;b&gt;depth&lt;/b&gt; / &lt;b&gt;altitude&lt;/b&gt;\"]\n    width --- thickness[\"&lt;b&gt;thickness&lt;/b&gt;\"]\n    width --- diameter[\"&lt;b&gt;diameter&lt;/b&gt;\"]\n    width --- radius[\"&lt;b&gt;radius&lt;/b&gt;\"]\n    length --- path_length[\"&lt;b&gt;path_length&lt;/b&gt;\"]\n    path_length --- distance[\"&lt;b&gt;distance&lt;/b&gt;\"]\n    distance --- radial_distance[\"&lt;b&gt;radial_distance&lt;/b&gt;\"]\n    length --- wavelength[\"&lt;b&gt;wavelength&lt;/b&gt;\"]\n    length --- displacement[\"&lt;b&gt;displacement&lt;/b&gt;&lt;br&gt;{vector}\"]\n    displacement --- position_vector[\"&lt;b&gt;position_vector&lt;/b&gt;\"]\n    radius --- radius_of_curvature[\"&lt;b&gt;radius_of_curvature&lt;/b&gt;\"]</code></pre> <p>Each of the above quantities expresses some kind of length, and each can be measured with <code>si::metre</code>. However, each of them has different properties, usage, and sometimes even requires a different representation type (notice that <code>position_vector</code> and <code>displacement</code> are vector quantities).</p> <p>Forming such a hierarchy helps us in defining arithmetics and conversion rules for various quantities of the same kind.</p>"},{"location":"users_guide/framework_basics/systems_of_quantities/#defining-quantities","title":"Defining quantities","text":"<p>In the mp-units library all the information about the quantity is provided with the <code>quantity_spec</code> class template. In order to define a specific quantity a user should inherit a strong type from such an instantiation.</p> <p>Tip</p> <p>Quantity specification definitions benefit from an explicit object parameter added in C++23 to remove the need for CRTP idiom, which significantly simplifies the code. However, as C++23 is far from being mainstream today, a portability macro <code>QUANTITY_SPEC()</code> is provided and used consistently through the library to allow the code to compile with C++20 compilers, thanks to the CRTP usage under the hood.</p> <p>See more in the C++ compiler support chapter.</p> <p>For example, here is how the above quantity kind tree can be modeled in the library:</p> C++23C++20Portable <pre><code>inline constexpr struct length final : quantity_spec&lt;dim_length&gt; {} length;\ninline constexpr struct width final : quantity_spec&lt;length&gt; {} width;\ninline constexpr auto breadth = width;\ninline constexpr struct height final : quantity_spec&lt;length&gt; {} height;\ninline constexpr auto depth = height;\ninline constexpr auto altitude = height;\ninline constexpr struct thickness final : quantity_spec&lt;width&gt; {} thickness;\ninline constexpr struct diameter final : quantity_spec&lt;width&gt; {} diameter;\ninline constexpr struct radius final : quantity_spec&lt;width&gt; {} radius;\ninline constexpr struct radius_of_curvature final : quantity_spec&lt;radius&gt; {} radius_of_curvature;\ninline constexpr struct path_length final : quantity_spec&lt;length&gt; {} path_length;\ninline constexpr auto arc_length = path_length;\ninline constexpr struct distance final : quantity_spec&lt;path_length&gt; {} distance;\ninline constexpr struct radial_distance final : quantity_spec&lt;distance&gt; {} radial_distance;\ninline constexpr struct wavelength final : quantity_spec&lt;length&gt; {} wavelength;\ninline constexpr struct displacement final : quantity_spec&lt;length, quantity_character::vector&gt; {} displacement;\ninline constexpr struct position_vector final : quantity_spec&lt;displacement&gt; {} position_vector;\n</code></pre> <pre><code>inline constexpr struct length final : quantity_spec&lt;length, dim_length&gt; {} length;\ninline constexpr struct width final : quantity_spec&lt;width, length&gt; {} width;\ninline constexpr auto breadth = width;\ninline constexpr struct height final : quantity_spec&lt;height, length&gt; {} height;\ninline constexpr auto depth = height;\ninline constexpr auto altitude = height;\ninline constexpr struct thickness final : quantity_spec&lt;thickness, width&gt; {} thickness;\ninline constexpr struct diameter final : quantity_spec&lt;diameter, width&gt; {} diameter;\ninline constexpr struct radius final : quantity_spec&lt;radius, width&gt; {} radius;\ninline constexpr struct radius_of_curvature final : quantity_spec&lt;radius_of_curvature, radius&gt; {} radius_of_curvature;\ninline constexpr struct path_length final : quantity_spec&lt;path_length, length&gt; {} path_length;\ninline constexpr auto arc_length = path_length;\ninline constexpr struct distance final : quantity_spec&lt;distance, path_length&gt; {} distance;\ninline constexpr struct radial_distance final : quantity_spec&lt;radial_distance, distance&gt; {} radial_distance;\ninline constexpr struct wavelength final : quantity_spec&lt;wavelength, length&gt; {} wavelength;\ninline constexpr struct displacement final : quantity_spec&lt;displacement, length, quantity_character::vector&gt; {} displacement;\ninline constexpr struct position_vector final : quantity_spec&lt;position_vector, displacement&gt; {} position_vector;\n</code></pre> <pre><code>QUANTITY_SPEC(length, dim_length);\nQUANTITY_SPEC(width, length);\ninline constexpr auto breadth = width;\nQUANTITY_SPEC(height, length);\ninline constexpr auto depth = height;\ninline constexpr auto altitude = height;\nQUANTITY_SPEC(thickness, width);\nQUANTITY_SPEC(diameter, width);\nQUANTITY_SPEC(radius, width);\nQUANTITY_SPEC(radius_of_curvature, radius);\nQUANTITY_SPEC(path_length, length);\ninline constexpr auto arc_length = path_length;\nQUANTITY_SPEC(distance, path_length);\nQUANTITY_SPEC(radial_distance, distance);\nQUANTITY_SPEC(wavelength, length);\nQUANTITY_SPEC(displacement, length, quantity_character::vector);\nQUANTITY_SPEC(position_vector, displacement);\n</code></pre> <p>Note</p> <p>More information on how to define a system of quantities can be found in the \"International System of Quantities (ISQ)\" chapter.</p>"},{"location":"users_guide/framework_basics/systems_of_quantities/#comparing-adding-and-subtracting-quantities","title":"Comparing, adding, and subtracting quantities","text":"<p>ISO 80000 explicitly states that width and height are quantities of the same kind, and as such they:</p> <ul> <li>are mutually comparable,</li> <li>can be added and subtracted.</li> </ul> <p>If we take the above for granted, the only reasonable result of <code>1 * width + 1 * height</code> is <code>2 * length</code>, where the result of <code>length</code> is known as a common quantity type. A result of such an equation is always the first common node in a hierarchy tree of the same kind. For example:</p> <pre><code>static_assert(get_common_quantity_spec(isq::width, isq::height) == isq::length);\nstatic_assert(get_common_quantity_spec(isq::thickness, isq::radius) == isq::width);\nstatic_assert(get_common_quantity_spec(isq::distance, isq::path_length) == isq::path_length);\n</code></pre>"},{"location":"users_guide/framework_basics/systems_of_quantities/#converting-between-quantities","title":"Converting between quantities","text":"<p>Based on the same hierarchy of quantities of kind length, we can define quantity conversion rules.</p> <ol> <li> <p>Implicit conversions</p> <ul> <li>every width is a length</li> <li>every radius is a width</li> </ul> <pre><code>static_assert(implicitly_convertible(isq::width, isq::length));\nstatic_assert(implicitly_convertible(isq::radius, isq::width));\nstatic_assert(implicitly_convertible(isq::radius, isq::length));\n</code></pre> <p>Implicit conversions are allowed on copy-initialization:</p> <pre><code>void foo(quantity&lt;isq::length[m]&gt; q);\n</code></pre> <pre><code>quantity&lt;isq::width[m]&gt; q1 = 42 * m;\nquantity&lt;isq::length[m]&gt; q2 = q1;  // implicit quantity conversion\nfoo(q1);                           // implicit quantity conversion\n</code></pre> </li> <li> <p>Explicit conversions</p> <ul> <li>not every length is a width</li> <li>not every width is a radius</li> </ul> <pre><code>static_assert(!implicitly_convertible(isq::length, isq::width));\nstatic_assert(!implicitly_convertible(isq::width, isq::radius));\nstatic_assert(!implicitly_convertible(isq::length, isq::radius));\nstatic_assert(explicitly_convertible(isq::length, isq::width));\nstatic_assert(explicitly_convertible(isq::width, isq::radius));\nstatic_assert(explicitly_convertible(isq::length, isq::radius));\n</code></pre> <p>Explicit conversions are forced by passing the quantity to a call operator of a <code>quantity_spec</code> type or by calling <code>quantity</code>'s explicit constructor:</p> <pre><code>void foo(quantity&lt;isq::height[m]&gt; q);\n</code></pre> <pre><code>quantity&lt;isq::length[m]&gt; q1 = 42 * m;\nquantity&lt;isq::height[m]&gt; q2 = isq::height(q1);  // explicit quantity conversion\nquantity&lt;isq::height[m]&gt; q3(q1);                // direct initialization\nfoo(isq::height(q1));                           // explicit quantity conversion\n</code></pre> </li> <li> <p>Explicit casts</p> <ul> <li>height is not a width</li> <li>both height and width are quantities of kind length</li> </ul> <pre><code>static_assert(!implicitly_convertible(isq::height, isq::width));\nstatic_assert(!explicitly_convertible(isq::height, isq::width));\nstatic_assert(castable(isq::height, isq::width));\n</code></pre> <p>Explicit casts are forced with a dedicated <code>quantity_cast</code> function:</p> <pre><code>void foo(quantity&lt;isq::height[m]&gt; q);\n</code></pre> <pre><code>quantity&lt;isq::width[m]&gt; q1 = 42 * m;\nquantity&lt;isq::height[m]&gt; q2 = quantity_cast&lt;isq::height&gt;(q1);  // explicit quantity cast\nfoo(quantity_cast&lt;isq::height&gt;(q1));                           // explicit quantity cast\n</code></pre> </li> <li> <p>No conversion</p> <ul> <li>time has nothing in common with length</li> </ul> <pre><code>static_assert(!implicitly_convertible(isq::time, isq::length));\nstatic_assert(!explicitly_convertible(isq::time, isq::length));\nstatic_assert(!castable(isq::time, isq::length));\n</code></pre> <p>Even the explicit casts will not force such a conversion:</p> <pre><code>void foo(quantity&lt;isq::length[m]&gt;);\n</code></pre> <pre><code>quantity&lt;isq::length[m]&gt; q1 = 42 * s;    // Compile-time error\nfoo(quantity_cast&lt;isq::length&gt;(42 * s)); // Compile-time error\n</code></pre> </li> </ol>"},{"location":"users_guide/framework_basics/systems_of_quantities/#hierarchies-of-derived-quantities","title":"Hierarchies of derived quantities","text":"<p>Derived quantity equations often do not automatically form a hierarchy tree. This is why it is sometimes not obvious what such a tree should look like. Also, ISO explicitly states:</p> <p>ISO/IEC Guide 99</p> <p>The division of \u2018quantity\u2019 according to \u2018kind of quantity\u2019 is, to some extent, arbitrary.</p> <p>The below presents some arbitrary hierarchy of derived quantities of kind energy:</p> <pre><code>flowchart TD\n    energy[\"&lt;b&gt;energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * length&lt;sup&gt;2&lt;/sup&gt; / time&lt;sup&gt;2&lt;/sup&gt;)&lt;/i&gt;&lt;br&gt;[J]\"]\n    energy --- mechanical_energy[\"&lt;b&gt;mechanical_energy&lt;/b&gt;\"]\n    mechanical_energy --- potential_energy[\"&lt;b&gt;potential_energy&lt;/b&gt;\"]\n    potential_energy --- gravitational_potential_energy[\"&lt;b&gt;gravitational_potential_energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * acceleration_of_free_fall * height)&lt;/i&gt;\"]\n    potential_energy --- elastic_potential_energy[\"&lt;b&gt;elastic_potential_energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(spring_constant * amount_of_compression&lt;sup&gt;2&lt;/sup&gt;)&lt;/i&gt;\"]\n    mechanical_energy --- kinetic_energy[\"&lt;b&gt;kinetic_energy&lt;/b&gt;&lt;br&gt;&lt;i&gt;(mass * speed&lt;sup&gt;2&lt;/sup&gt;)&lt;/i&gt;\"]\n    energy --- enthalpy[\"&lt;b&gt;enthalpy&lt;/b&gt;\"]\n    enthalpy --- internal_energy[\"&lt;b&gt;internal_energy&lt;/b&gt; / &lt;b&gt;thermodynamic_energy&lt;/b&gt;\"]\n    internal_energy --- Helmholtz_energy[\"&lt;b&gt;Helmholtz_energy&lt;/b&gt; / &lt;b&gt;Helmholtz_function&lt;/b&gt;\"]\n    enthalpy --- Gibbs_energy[\"&lt;b&gt;Gibbs_energy&lt;/b&gt; / &lt;b&gt;Gibbs_function&lt;/b&gt;\"]\n    energy --- active_energy[\"&lt;b&gt;active_energy&lt;/b&gt;\"]</code></pre> <p>Notice, that even though all of those quantities have the same dimension and can be expressed in the same units, they have different quantity equations that can be used to create them implicitly:</p> <ul> <li> <p>energy is the most generic one and thus can be created from base quantities of mass, length,   and time. As those are also the roots of quantities of their kinds and all other quantities from their   trees are implicitly convertible to them (we agreed on that \"every width is a length\" already),   it means that an energy can be implicitly constructed from any quantity of mass, length, and time:</p> <pre><code>static_assert(implicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time), isq::energy));\nstatic_assert(implicitly_convertible(isq::mass * pow&lt;2&gt;(isq::height) / pow&lt;2&gt;(isq::time), isq::energy));\n</code></pre> </li> <li> <p>mechanical energy is a more \"specialized\" quantity than energy (not every energy is   a mechanical energy). It is why an explicit cast is needed to convert from either energy or   the results of its quantity equation:</p> <pre><code>static_assert(!implicitly_convertible(isq::energy, isq::mechanical_energy));\nstatic_assert(explicitly_convertible(isq::energy, isq::mechanical_energy));\nstatic_assert(!implicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time),\n                                      isq::mechanical_energy));\nstatic_assert(explicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time),\n                                     isq::mechanical_energy));\n</code></pre> </li> <li> <p>gravitational potential energy is not only even more specialized one but additionally,   it is special in a way that it provides its own \"constrained\"   quantity equation. Maybe not every   <code>mass * pow&lt;2&gt;(length) / pow&lt;2&gt;(time)</code> is a gravitational potential energy, but every   <code>mass * acceleration_of_free_fall * height</code> is.</p> <pre><code>static_assert(!implicitly_convertible(isq::energy, gravitational_potential_energy));\nstatic_assert(explicitly_convertible(isq::energy, gravitational_potential_energy));\nstatic_assert(!implicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time),\n                                      gravitational_potential_energy));\nstatic_assert(explicitly_convertible(isq::mass * pow&lt;2&gt;(isq::length) / pow&lt;2&gt;(isq::time),\n                                     gravitational_potential_energy));\nstatic_assert(implicitly_convertible(isq::mass * isq::acceleration_of_free_fall * isq::height,\n                                     gravitational_potential_energy));\n</code></pre> </li> </ul>"},{"location":"users_guide/framework_basics/systems_of_quantities/#modeling-a-quantity-kind","title":"Modeling a quantity kind","text":"<p>In the physical units library, we also need an abstraction describing an entire family of quantities of the same kind. Such quantities have not only the same dimension but also can be expressed in the same units.</p> <p>To annotate a quantity to represent its kind (and not just a hierarchy tree's root quantity) we introduced a <code>kind_of&lt;&gt;</code> specifier. For example, to express any quantity of length, we need to type <code>kind_of&lt;isq::length&gt;</code>.</p> <p>Important</p> <p><code>isq::length</code> and <code>kind_of&lt;isq::length&gt;</code> are two different things.</p> <p>Such an entity behaves as any quantity of its kind. This means that it is implicitly convertible to any quantity in a tree.</p> <pre><code>static_assert(!implicitly_convertible(isq::length, isq::height));\nstatic_assert(implicitly_convertible(kind_of&lt;isq::length&gt;, isq::height));\n</code></pre> <p>Additionally, the result of operations on quantity kinds is also a quantity kind:</p> <pre><code>static_assert(same_type&lt;kind_of&lt;isq::length&gt; / kind_of&lt;isq::time&gt;, kind_of&lt;isq::length / isq::time&gt;&gt;);\n</code></pre> <p>However, if at least one equation's operand is not a quantity kind, the result becomes a \"strong\" quantity where all the kinds are converted to the hierarchy tree's root quantities:</p> <pre><code>static_assert(!same_type&lt;kind_of&lt;isq::length&gt; / isq::time, kind_of&lt;isq::length / isq::time&gt;&gt;);\nstatic_assert(same_type&lt;kind_of&lt;isq::length&gt; / isq::time, isq::length / isq::time&gt;);\n</code></pre> <p>Info</p> <p>Only a root quantity from the hierarchy tree or the one marked with <code>is_kind</code> specifier in the <code>quantity_spec</code> definition can be put as a template parameter to the <code>kind_of</code> specifier. For example, <code>kind_of&lt;isq::width&gt;</code> will fail to compile. However, we can call <code>get_kind(q)</code> to obtain a kind of any quantity:</p> <pre><code>static_assert(get_kind(isq::width) == kind_of&lt;isq::length&gt;);\n</code></pre>"},{"location":"users_guide/framework_basics/systems_of_units/","title":"Systems of Units","text":"<p>Modeling a system of units is probably the most important feature and a selling point of every physical units library. Thanks to that, the library can protect users from performing invalid operations on quantities and provide automated conversion factors between various compatible units.</p> <p>Probably all the libraries in the wild model the SI and many of them provide support for additional units belonging to various other systems (e.g., imperial, cgs, etc).</p>"},{"location":"users_guide/framework_basics/systems_of_units/#systems-of-units-are-based-on-systems-of-quantities","title":"Systems of Units are based on Systems of Quantities","text":"<p>Systems of quantities specify a set of quantities and equations relating to those quantities. Those equations do not take any unit or a numerical representation into account at all. To create a quantity, we need to add those missing pieces of information. This is where a system of units kicks in.</p> <p>The SI is explicitly stated to be based on the ISQ. Among others, it defines <code>7</code> base units, one for each base quantity. In the mp-units this is expressed by associating a quantity kind (that we discussed in detail in the previous chapter) with a unit that is used to express it:</p> <pre><code>inline constexpr struct metre final : named_unit&lt;\"m\", kind_of&lt;isq::length&gt;&gt; {} metre;\n</code></pre> <p>Important</p> <p>The <code>kind_of&lt;isq::length&gt;</code> above states explicitly that this unit has an associated quantity kind. In other words, <code>si::metre</code> (and scaled units based on it) can be used to express the amount of any quantity of kind length.</p>"},{"location":"users_guide/framework_basics/systems_of_units/#units-compose","title":"Units compose","text":"<p>One of the most vital points of the SI system is that its units compose. This allows providing thousands of different units for hundreds of various quantities with a tiny set of predefined units and prefixes.</p> <p>The same is modeled in the mp-units library, which also allows composing predefined units to create a nearly infinite number of different derived units. For example, one can write:</p> <pre><code>quantity&lt;si::metre / si::second&gt; q;\n</code></pre> <p>to express a quantity of speed. The resulting quantity type is implicitly inferred from the unit equation by repeating the same operations on the associated quantity kinds.</p>"},{"location":"users_guide/framework_basics/systems_of_units/#many-shades-of-the-same-unit","title":"Many shades of the same unit","text":"<p>The SI provides the names for 22 common coherent units of 22 derived quantities.</p> <p>Each such named derived unit is a result of a specific predefined unit equation. For example, a unit of power quantity is defined in the library as:</p> <pre><code>inline constexpr struct watt final : named_unit&lt;\"W\", joule / second&gt; {} watt;\n</code></pre> <p>However, a power quantity can be expressed in other units as well. For example, the following:</p> <pre><code>auto q1 = 42 * W;\nstd::cout &lt;&lt; q1 &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; q1.in(J / s) &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; q1.in(N * m / s) &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; q1.in(kg * m2 / s3) &lt;&lt; \"\\n\";\n</code></pre> <p>prints:</p> <pre><code>42 W\n42 J/s\n42 N m/s\n42 kg m\u00b2/s\u00b3\n</code></pre> <p>All of the above quantities are equivalent and mean exactly the same.</p> <p>Note</p> <p>The above code example may give the impression that the order of components in a derived unit is determined by the multiplication order. This is not the case. As stated in Simplifying the resulting symbolic expressions, to be able to reason about and simplify units, the library needs to order them in an appropriate order. This will affect the order of components in a resulting type and text output.</p> <p>Please refer to our FAQ for more information.</p>"},{"location":"users_guide/framework_basics/systems_of_units/#constraining-a-derived-unit-to-work-only-with-a-specific-derived-quantity","title":"Constraining a derived unit to work only with a specific derived quantity","text":"<p>Some derived units are valid only for specific derived quantities. For example, SI specifies both <code>hertz</code> and <code>becquerel</code> derived units with the same unit equation <code>1 / s</code>. However, it also explicitly states:</p> <p>SI Brochure</p> <p>The hertz shall only be used for periodic phenomena and the becquerel shall only be used for stochastic processes in activity referred to a radionuclide.</p> <p>The above means that the usage of <code>becquerel</code> as a unit of a frequency quantity is an error.</p> <p>The library allows constraining such units to work only with quantities of a specific kind in the following way:</p> <pre><code>inline constexpr struct hertz final : named_unit&lt;\"Hz\", one / second, kind_of&lt;isq::frequency&gt;&gt; {} hertz;\ninline constexpr struct becquerel final : named_unit&lt;\"Bq\", one / second, kind_of&lt;isq::activity&gt;&gt; {} becquerel;\n</code></pre> <p>With the above, <code>hertz</code> can only be used with frequencies, while <code>becquerel</code> should only be used with quantities of activity. This means that the following equation will not compile:</p> <pre><code>auto q = 1 * Hz + 1 * Bq;   // Fails to compile\n</code></pre> <p>This is exactly what we wanted to achieve to improve the type-safety of the library.</p>"},{"location":"users_guide/framework_basics/systems_of_units/#prefixed-units","title":"Prefixed units","text":"<p>Besides named units, the SI specifies also 24 prefixes (all being a power of <code>10</code>) that can be prepended to all named units to obtain various scaled versions of them.</p> <p>Implementation of <code>std::ratio</code> provided by all major compilers is able to express only 16 of them. This is why, in the mp-units, we had to find an alternative way to represent unit magnitude in a more flexible way.</p> <p>Each prefix is implemented similarly to the following:</p> <pre><code>template&lt;PrefixableUnit U&gt; struct quecto_ : prefixed_unit&lt;\"q\", mag_power&lt;10, -30&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit auto U&gt; constexpr quecto_&lt;decltype(U)&gt; quecto;\n</code></pre> <p>and then a PrefixableUnit can be prefixed in the following way:</p> <pre><code>inline constexpr auto qm = quecto&lt;metre&gt;;\n</code></pre> <p>The usage of <code>mag_power</code> not only enables providing support for SI prefixes, but it can also efficiently represent any rational magnitude. For example, IEC 80000 prefixes used in the IT industry can be implemented as:</p> <pre><code>template&lt;PrefixableUnit U&gt; struct yobi_ : prefixed_unit&lt;\"Yi\", mag_power&lt;2, 80&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit auto U&gt; constexpr yobi_&lt;decltype(U)&gt; yobi;\n</code></pre>"},{"location":"users_guide/framework_basics/systems_of_units/#scaled-units","title":"Scaled units","text":"<p>In the SI, all units are either base or derived units or prefixed versions of those. However, those are only some of the options possible.</p> <p>For example, there is a list of off-system units accepted for use with SI. Those are scaled versions of the SI units with ratios that can't be explicitly expressed with predefined SI prefixes. Those include units like minute, hour, or electronvolt:</p> <pre><code>inline constexpr struct minute final : named_unit&lt;\"min\", mag&lt;60&gt; * si::second&gt; {} minute;\ninline constexpr struct hour final : named_unit&lt;\"h\", mag&lt;60&gt; * minute&gt; {} hour;\ninline constexpr struct electronvolt final : named_unit&lt;\"eV\", mag_ratio&lt;1'602'176'634, 1'000'000'000&gt; * mag_power&lt;10, -19&gt; * si::joule&gt; {} electronvolt;\n</code></pre> <p>Also, units of other systems of units are often defined in terms of scaled versions of the SI units. For example, the international yard is defined as:</p> <pre><code>inline constexpr struct yard final : named_unit&lt;\"yd\", mag_ratio&lt;9'144, 10'000&gt; * si::metre&gt; {} yard;\n</code></pre> <p>For some units, a magnitude might also be irrational. The best example here is a <code>degree</code> which is defined using a floating-point magnitude having a factor of the number \u03c0 (Pi):</p> <pre><code>inline constexpr struct pi final : mag_constant&lt;symbol_text{u8\"\u03c0\", \"pi\"}, std::numbers::pi_v&lt;long double&gt;&gt; {} pi;\ninline constexpr auto \u03c0 = pi;\n</code></pre> <pre><code>inline constexpr struct degree final : named_unit&lt;{u8\"\u00b0\", \"deg\"}, mag&lt;\u03c0&gt; / mag&lt;180&gt; * si::radian&gt; {} degree;\n</code></pre>"},{"location":"users_guide/framework_basics/systems_of_units/#unit-symbols","title":"Unit symbols","text":"<p>Units are available via their full names or through their short symbols. To use a long version, it is enough to type:</p> <pre><code>quantity q1 = 42 * si::metre / si::second;\nquantity q2 = 42 * si::kilo&lt;si::metre&gt; / si::hour;\n</code></pre> <p>To simplify how we spell it a short, user-friendly symbols are provided in a dedicated subnamespace in systems definitions:</p> <pre><code>namespace si::unit_symbols {\n\nconstexpr auto m = si::metre;\nconstexpr auto km = si::kilo&lt;si::metre&gt;;\nconstexpr auto s = si::second;\nconstexpr auto h = si::hour;\n\n}\n</code></pre> <p>Unit symbols introduce a lot of short identifiers into the current namespace. This is why they are opt-in. A user has to explicitly \"import\" them from a dedicated <code>unit_symbols</code> namespace:</p> using-declarationusing-directive <pre><code>using namespace si::unit_symbols;\n\nquantity q1 = 42 * m / s;\nquantity q2 = 42 * km / h;\n</code></pre> <pre><code>using si::unit_symbols::m;\nusing si::unit_symbols::km;\nusing si::unit_symbols::s;\nusing si::unit_symbols::h;\n\nquantity q1 = 42 * m / s;\nquantity q2 = 42 * km / h;\n</code></pre> <p>We also provide alternative object identifiers using UTF-8 characters in their names for most unit symbols. The code using UTF-8 looks nicer, but it is harder to type on the keyboard. This is why we provide both versions of identifiers for such units.</p> PortableWith UTF-8 glyphs <pre><code>quantity resistance = 60 * kohm;\nquantity capacitance = 100 * uF;\n</code></pre> <pre><code>quantity resistance = 60 * k\u03a9;\nquantity capacitance = 100 * \u00b5F;\n</code></pre>"},{"location":"users_guide/framework_basics/systems_of_units/#common-units","title":"Common units","text":"<p>Adding, subtracting, or comparing two quantities of different units will force the library to find a common unit for those. This is to prevent data truncation. For the cases when one of the units is an integral multiple of the another, the resulting quantity will use a \"smaller\" one in its result. For example:</p> <pre><code>static_assert((1 * kg + 1 * g).unit == g);\nstatic_assert((1 * km + 1 * mm).unit == mm);\nstatic_assert((1 * yd + 1 * mi).unit == yd);\n</code></pre> <p>However, in many cases an arithmetic operation on quantities of different units will result in a yet another unit. This happens when none of the source units is an integral multiple of another. In such cases, the library returns a special type that denotes that we are dealing with a common unit of such an equation:</p> <pre><code>quantity q1 = 1 * km + 1 * mi;     // quantity&lt;common_unit&lt;international::mile, si::kilo_&lt;si::metre&gt;&gt;{}, int&gt;\nquantity q2 = 1. * rad + 1. * deg; // quantity&lt;common_unit&lt;si::degree, si::radian&gt;{}, double&gt;\n</code></pre> <p>Note</p> <p>A user should never explicitly instantiate a <code>common_unit</code> class template. The library's framework will do it based on the provided quantity equation.</p>"},{"location":"users_guide/framework_basics/text_output/","title":"Text Output","text":"<p>Besides providing dimensional analysis and unit conversions, the library also tries hard to print any quantity in the most user-friendly way. We can print the entire quantity or its selected parts (numerical value, unit, or dimension).</p> <p>Note</p> <p>The library does not provide a text output for quantity points. The quantity stored inside is just an implementation detail of this type. It is a vector from a specific origin. Without the knowledge of the origin, the vector by itself is useless as we can't determine which point it describes.</p> <p>In the current library design, point origin does not provide any text in its definition. Even if we could add such information to the point's definition, we would not know how to output it in the text. There may be many ways to do it. For example, should we prepend or append the origin part to the quantity text?</p> <p>For example, the text output of <code>42 m</code> for a quantity point may mean many things. It may be an offset from the mountain top, sea level, or maybe the center of Mars. Printing <code>42 m AMSL</code> for altitudes above mean sea level is a much better solution, but the library does not have enough information to print it that way by itself.</p> <p>Please let us know if you have a good idea of how to solve this issue.</p>"},{"location":"users_guide/framework_basics/text_output/#predefined-symbols","title":"Predefined symbols","text":"<p>The definitions of dimensions, units, prefixes, and constants require assigning text symbols for each entity. Those symbols will be composed by the library's framework to express dimensions and units of derived quantities.</p> DimensionsUnitsPrefixesConstants <pre><code>inline constexpr struct dim_length final : base_dimension&lt;\"L\"&gt; {} dim_length;\ninline constexpr struct dim_mass final : base_dimension&lt;\"M\"&gt; {} dim_mass;\ninline constexpr struct dim_time final : base_dimension&lt;\"T\"&gt; {} dim_time;\ninline constexpr struct dim_electric_current final : base_dimension&lt;\"I\"&gt; {} dim_electric_current;\ninline constexpr struct dim_thermodynamic_temperature final : base_dimension&lt;{u8\"\u0398\", \"O\"}&gt; {} dim_thermodynamic_temperature;\ninline constexpr struct dim_amount_of_substance final : base_dimension&lt;\"N\"&gt; {} dim_amount_of_substance;\ninline constexpr struct dim_luminous_intensity final : base_dimension&lt;\"J\"&gt; {} dim_luminous_intensity;\n</code></pre> <pre><code>inline constexpr struct second final : named_unit&lt;\"s\", kind_of&lt;isq::time&gt;&gt; {} second;\ninline constexpr struct metre final : named_unit&lt;\"m\", kind_of&lt;isq::length&gt;&gt; {} metre;\ninline constexpr struct gram final : named_unit&lt;\"g\", kind_of&lt;isq::mass&gt;&gt; {} gram;\ninline constexpr auto kilogram = kilo&lt;gram&gt;;\n\ninline constexpr struct newton final : named_unit&lt;\"N\", kilogram * metre / square(second)&gt; {} newton;\ninline constexpr struct joule final : named_unit&lt;\"J\", newton * metre&gt; {} joule;\ninline constexpr struct watt final : named_unit&lt;\"W\", joule / second&gt; {} watt;\ninline constexpr struct coulomb final : named_unit&lt;\"C\", ampere * second&gt; {} coulomb;\ninline constexpr struct volt final : named_unit&lt;\"V\", watt / ampere&gt; {} volt;\ninline constexpr struct farad final : named_unit&lt;\"F\", coulomb / volt&gt; {} farad;\ninline constexpr struct ohm final : named_unit&lt;{u8\"\u03a9\", \"ohm\"}, volt / ampere&gt; {} ohm;\n</code></pre> <pre><code>template&lt;PrefixableUnit U&gt; struct micro_ : prefixed_unit&lt;{u8\"\u00b5\", \"u\"}, mag_power&lt;10, -6&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit U&gt; struct milli_ : prefixed_unit&lt;\"m\", mag_power&lt;10, -3&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit U&gt; struct centi_ : prefixed_unit&lt;\"c\", mag_power&lt;10, -2&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit U&gt; struct deci_  : prefixed_unit&lt;\"d\", mag_power&lt;10, -1&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit U&gt; struct deca_  : prefixed_unit&lt;\"da\", mag_power&lt;10, 1&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit U&gt; struct hecto_ : prefixed_unit&lt;\"h\", mag_power&lt;10, 2&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit U&gt; struct kilo_  : prefixed_unit&lt;\"k\", mag_power&lt;10, 3&gt;, U{}&gt; {};\ntemplate&lt;PrefixableUnit U&gt; struct mega_  : prefixed_unit&lt;\"M\", mag_power&lt;10, 6&gt;, U{}&gt; {};\n</code></pre> <pre><code>inline constexpr struct hyperfine_structure_transition_frequency_of_cs final : named_unit&lt;{u8\"\u0394\u03bd_Cs\", \"dv_Cs\"}, mag&lt;9'192'631'770&gt; * hertz&gt; {} hyperfine_structure_transition_frequency_of_cs;\ninline constexpr struct speed_of_light_in_vacuum final : named_unit&lt;\"c\", mag&lt;299'792'458&gt; * metre / second&gt; {} speed_of_light_in_vacuum;\ninline constexpr struct planck_constant final : named_unit&lt;\"h\", mag_ratio&lt;662'607'015, 100'000'000&gt; * mag_power&lt;10, -34&gt; * joule * second&gt; {} planck_constant;\ninline constexpr struct elementary_charge final : named_unit&lt;\"e\", mag_ratio&lt;1'602'176'634, 1'000'000'000&gt; * mag_power&lt;10, -19&gt; * coulomb&gt; {} elementary_charge;\ninline constexpr struct boltzmann_constant final : named_unit&lt;\"k\", mag_ratio&lt;1'380'649, 1'000'000&gt; * mag_power&lt;10, -23&gt; * joule / kelvin&gt; {} boltzmann_constant;\ninline constexpr struct avogadro_constant final : named_unit&lt;\"N_A\", mag_ratio&lt;602'214'076, 100'000'000&gt; * mag_power&lt;10, 23&gt; / mole&gt; {} avogadro_constant;\ninline constexpr struct luminous_efficacy final : named_unit&lt;\"K_cd\", mag&lt;683&gt; * lumen / watt&gt; {} luminous_efficacy;\n</code></pre> <p>Important</p> <p>Two symbols always have to be provided if the primary symbol contains characters outside of the basic literal character set. The first must be provided as a UTF-8 literal and may contain any Unicode characters. The second one must provide an alternative spelling and only use characters from within of basic literal character set.</p> <p>Note</p> <p>Unicode provides only a minimal set of characters available as subscripts, which are often used to differentiate various constants and quantities of the same kind. To workaround this issue, mp-units uses the '_' character to specify that the following characters should be considered a subscript of the symbol.</p> <p>Tip</p> <p>For older compilers, it might be required to specify a <code>symbol_text</code> class explicitly template name to initialize it with two symbols:</p> <pre><code>inline constexpr struct ohm final : named_unit&lt;symbol_text{u8\"\u03a9\", \"ohm\"}, volt / ampere&gt; {} ohm;\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#symbols-for-derived-entities","title":"Symbols for derived entities","text":""},{"location":"users_guide/framework_basics/text_output/#text_encoding","title":"<code>text_encoding</code>","text":"<p>ISQ and SI standards always specify symbols using UTF-8 encoding. This is why it is a default and primary target for text output. However, in some applications or environments, a standard portable text output using only the characters from the basic literal character set can be preferred by users.</p> <p>This is why the library provides an option to change the default encoding to the portable one with:</p> <pre><code>enum class text_encoding : std::int8_t {\n  utf8,       // \u00b5s; m\u00b3;  L\u00b2MT\u207b\u00b3\n  portable,   // us; m^3; L^2MT^-3\n  default_encoding = utf8\n};\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#symbols-of-derived-dimensions","title":"Symbols of derived dimensions","text":""},{"location":"users_guide/framework_basics/text_output/#dimension_symbol_formatting","title":"<code>dimension_symbol_formatting</code>","text":"<p><code>dimension_symbol_formatting</code> is a data type describing the configuration of the symbol generation algorithm.</p> <pre><code>struct dimension_symbol_formatting {\n  text_encoding encoding = text_encoding::default_encoding;\n};\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#dimension_symbol","title":"<code>dimension_symbol()</code>","text":"<p>Returns a <code>std::string_view</code> with the symbol of a dimension for the provided configuration:</p> <pre><code>template&lt;dimension_symbol_formatting fmt = dimension_symbol_formatting{}, typename CharT = char, Dimension D&gt;\n[[nodiscard]] consteval std::string_view dimension_symbol(D);\n</code></pre> <p>For example:</p> <pre><code>static_assert(dimension_symbol&lt;{.encoding = text_encoding::portable}&gt;(isq::power.dimension) == \"L^2MT^-3\");\n</code></pre> <p>Note</p> <p><code>std::string_view</code> is returned only when C++23 is available. Otherwise, an instance of a <code>basic_fixed_string</code> is being returned.</p>"},{"location":"users_guide/framework_basics/text_output/#dimension_symbol_to","title":"<code>dimension_symbol_to()</code>","text":"<p>Inserts the generated dimension symbol into the output text iterator at runtime.</p> <pre><code>template&lt;typename CharT = char, std::output_iterator&lt;CharT&gt; Out, Dimension D&gt;\nconstexpr Out dimension_symbol_to(Out out, D d, dimension_symbol_formatting fmt = dimension_symbol_formatting{});\n</code></pre> <p>For example:</p> <pre><code>std::string txt;\ndimension_symbol_to(std::back_inserter(txt), isq::power.dimension, {.encoding = text_encoding::portable});\nstd::cout &lt;&lt; txt &lt;&lt; \"\\n\";\n</code></pre> <p>The above prints:</p> <pre><code>L^2MT^-3\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#symbols-of-derived-units","title":"Symbols of derived units","text":""},{"location":"users_guide/framework_basics/text_output/#unit_symbol_formatting","title":"<code>unit_symbol_formatting</code>","text":"<p><code>unit_symbol_formatting</code> is a data type describing the configuration of the symbol generation algorithm. It contains three orthogonal fields, each with a default value.</p> <pre><code>enum class unit_symbol_solidus : std::int8_t {\n  one_denominator,  // m/s;   kg m\u207b\u00b9 s\u207b\u00b9\n  always,           // m/s;   kg/(m s)\n  never,            // m s\u207b\u00b9; kg m\u207b\u00b9 s\u207b\u00b9\n  default_denominator = one_denominator\n};\n\nenum class unit_symbol_separator : std::int8_t {\n  space,          // kg m\u00b2/s\u00b2\n  half_high_dot,  // kg\u22c5m\u00b2/s\u00b2  (valid only for utf8 encoding)\n  default_separator = space\n};\n\nstruct unit_symbol_formatting {\n  text_encoding encoding = text_encoding::default_encoding;\n  unit_symbol_solidus solidus = unit_symbol_solidus::default_denominator;\n  unit_symbol_separator separator = unit_symbol_separator::default_separator;\n};\n</code></pre> <p><code>unit_symbol_solidus</code> impacts how the division of unit symbols is being presented in the text output. By default, the '/' will be printed if only one unit component is in the denominator. Otherwise, the exponent syntax will be used.</p> <p><code>unit_symbol_separator</code> specifies how multiple multiplied units should be separated from each other. By default, the space (' ') will be used as a separator.</p>"},{"location":"users_guide/framework_basics/text_output/#unit_symbol","title":"<code>unit_symbol()</code>","text":"<p>Returns a <code>std::string_view</code> with the symbol of a unit for the provided configuration:</p> <pre><code>template&lt;unit_symbol_formatting fmt = unit_symbol_formatting{}, typename CharT = char, Unit U&gt;\n[[nodiscard]] consteval std::string_view unit_symbol(U);\n</code></pre> <p>For example:</p> <pre><code>static_assert(unit_symbol&lt;{.solidus = unit_symbol_solidus::never,\n                           .separator = unit_symbol_separator::half_high_dot}&gt;(kg * m / s2) == \"kg\u22c5m\u22c5s\u207b\u00b2\");\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#unit_symbol_to","title":"<code>unit_symbol_to()</code>","text":"<p>Inserts the generated unit symbol into the output text iterator at runtime.</p> <pre><code>template&lt;typename CharT = char, std::output_iterator&lt;CharT&gt; Out, Unit U&gt;\nconstexpr Out unit_symbol_to(Out out, U u, unit_symbol_formatting fmt = unit_symbol_formatting{});\n</code></pre> <p>For example:</p> <pre><code>std::string txt;\nunit_symbol_to(std::back_inserter(txt), kg * m / s2,\n               {.solidus = unit_symbol_solidus::never, .separator = unit_symbol_separator::half_high_dot});\nstd::cout &lt;&lt; txt &lt;&lt; \"\\n\";\n</code></pre> <p>The above prints:</p> <pre><code>kg\u22c5m\u22c5s\u207b\u00b2\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#symbols-of-scaled-units","title":"Symbols of scaled units","text":"<p>In most cases scaled units are hidden behind named units. However, there are a few real-life where a user directly faces a scaled unit. For example:</p> <pre><code>constexpr Unit auto L_per_100km = L / (mag&lt;100&gt; * km);\n</code></pre> <p>The above is a derived unit of litre divided by a scaled unit of 100 kilometers. As we can see a scaled unit has a magnitude and a reference unit. To denote the scope of such a unit, we enclose it in <code>[...]</code>. For example, the following:</p> <pre><code>std::cout &lt;&lt; 6.7 * L_per_100km &lt;&lt; \"\\n\";\n</code></pre> <p>prints:</p> <pre><code>6.7 L/[100 km]\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#symbols-of-common-units","title":"Symbols of common units","text":"<p>Some common units expressed with a specialization of the <code>common_unit</code> class template need special printing rules for their symbols. As they represent a minimum set of equivalent common units resulting from the addition or subtraction of multiple quantities, we print all of them as a scaled version of the source unit. For example, the following:</p> <pre><code>std::cout &lt;&lt; 1 * km + 1 * mi &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; 1 * nmi + 1 * mi &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; 1 * km / h + 1 * m / s &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; 1 * rad + 1 * deg &lt;&lt; \"\\n\";\n</code></pre> <p>prints:</p> <pre><code>40771 [(1/25146 mi), (1/15625 km)]\n108167 [(1/50292 mi), (1/57875 nmi)]\n23 [(1/5 km/h), (1/18 m/s)]\n183.142 [(1/\u03c0\u00b0), (1/180 rad)]\n</code></pre> <p>Thanks to the above, it might be easier for the user to reason about the magnitude of the resulting unit and its impact on the value stored in the quantity.</p> <p>Note</p> <p>It is important to note that this output is provided only for intermediate results of the equations, as shown above. A user usually knows which unit should be used, and explicit conversion can be made to achieve that. For example:</p> <pre><code>std::cout &lt;&lt; (1 * km + 1 * mi).in&lt;double&gt;(km) &lt;&lt; \"\\n\";\n</code></pre> <p>prints:</p> <pre><code>2.60934 km\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#space_before_unit_symbol-customization-point","title":"<code>space_before_unit_symbol</code> customization point","text":"<p>The SI Brochure says:</p> <p>SI Brochure</p> <p>The numerical value always precedes the unit and a space is always used to separate the unit from the number. ... The only exceptions to this rule are for the unit symbols for degree, minute and second for plane angle, <code>\u00b0</code>, <code>\u2032</code> and <code>\u2033</code>, respectively, for which no space is left between the numerical value and the unit symbol.</p> <p>There are more units with such properties. For example, percent (<code>%</code>) and per mille(<code>\u2030</code>).</p> <p>To support the above and other similar cases, the library exposes <code>space_before_unit_symbol</code> customization point. By default, its value is <code>true</code> for all the units, so the space between a number and a unit will be inserted in the output text. To change this behavior, we have to provide a partial specialization for a specific unit:</p> <pre><code>template&lt;&gt;\nconstexpr bool space_before_unit_symbol&lt;non_si::degree&gt; = false;\n</code></pre> <p>Note</p> <p>The above works only for the default formatting or for the format strings that use <code>%?</code> placement field (<code>std::format(\"{}\", q)</code> is equivalent to <code>std::format(\"{:%N%?%U}\", q)</code>).</p> <p>In case a user provides custom format specification (e.g., <code>std::format(\"{:%N %U}\", q)</code>), the library will always obey this specification for all the units (no matter what the actual value of the <code>space_before_unit_symbol</code> customization point is) and the separating space will always be used in this case.</p>"},{"location":"users_guide/framework_basics/text_output/#output-streams","title":"Output streams","text":"<p>Tip</p> <p>The output streaming support is opt-in and can be enabled by including the <code>&lt;mp-units/ostream.h&gt;</code> header file.</p> <p>The easiest way to print a dimension, unit, or quantity is to provide its object to the output stream:</p> <pre><code>const QuantityOf&lt;isq::speed&gt; auto v1 = avg_speed(220. * km, 2 * h);\nconst QuantityOf&lt;isq::speed&gt; auto v2 = avg_speed(140. * mi, 2 * h);\nstd::cout &lt;&lt; v1 &lt;&lt; '\\n';            // 110 km/h\nstd::cout &lt;&lt; v2 &lt;&lt; '\\n';            // 70 mi/h\nstd::cout &lt;&lt; v2.unit &lt;&lt; '\\n';       // mi/h\nstd::cout &lt;&lt; v2.dimension &lt;&lt; '\\n';  // LT\u207b\u00b9\n</code></pre> <p>The text output will always print the value using the default formatting for this entity.</p> <p>Important: Don't assume a unit</p> <p>Remember that when we deal with a quantity of an \"unknown\" (e.g., <code>auto</code>) type, it is a good practice to always convert the unit to the expected one before passing it to the text output:</p> <pre><code>std::cout &lt;&lt; v1.in(km / h) &lt;&lt; '\\n';       // 110 km/h\nstd::cout &lt;&lt; v1.force_in(m / s) &lt;&lt; '\\n';  // 30.5556 m/s\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#output-stream-formatting","title":"Output stream formatting","text":"<p>Only basic formatting can be applied to output streams. It includes control over width, fill, and alignment.</p> <p>The numerical value of the quantity will be printed according to the current stream state and standard manipulators may be used to customize that (assuming that the underlying representation type respects them).</p> <pre><code>std::cout &lt;&lt; \"|\" &lt;&lt; std::setw(10) &lt;&lt; 123 * m &lt;&lt; \"|\\n\";                       // |     123 m|\nstd::cout &lt;&lt; \"|\" &lt;&lt; std::setw(10) &lt;&lt; std::left &lt;&lt; 123 * m &lt;&lt; \"|\\n\";          // |123 m     |\nstd::cout &lt;&lt; \"|\" &lt;&lt; std::setw(10) &lt;&lt; std::setfill('*') &lt;&lt; 123 * m &lt;&lt; \"|\\n\";  // |123 m*****|\n</code></pre> <p>Note</p> <p>To have more control over the formatting of the quantity that is printed with the output stream just use <code>std::cout &lt;&lt; std::format(...)</code>.</p>"},{"location":"users_guide/framework_basics/text_output/#text-formatting","title":"Text formatting","text":"<p>The library provides custom formatters for <code>std::format</code> facility, which allows fine-grained control over what and how it is being printed in the text output.</p> <p>Tip</p> <p>The text formatting facility support is opt-in and can be enabled by including the <code>&lt;mp-units/format.h&gt;</code> header file.</p>"},{"location":"users_guide/framework_basics/text_output/#controlling-width-fill-and-alignment","title":"Controlling width, fill, and alignment","text":"<p>Formatting grammar for all the entities provides control over width, fill, and alignment. The C++ standard grammar tokens <code>fill-and-align</code> and <code>width</code> are being used. They treat the entity as a contiguous text to be aligned. For example, here are a few examples of the quantity numerical value and symbol formatting:</p> <pre><code>std::println(\"|{:0}|\", 123 * m);     // |123 m|\nstd::println(\"|{:10}|\", 123 * m);    // |     123 m|\nstd::println(\"|{:&lt;10}|\", 123 * m);   // |123 m     |\nstd::println(\"|{:&gt;10}|\", 123 * m);   // |     123 m|\nstd::println(\"|{:^10}|\", 123 * m);   // |  123 m   |\nstd::println(\"|{:*&lt;10}|\", 123 * m);  // |123 m*****|\nstd::println(\"|{:*&gt;10}|\", 123 * m);  // |*****123 m|\nstd::println(\"|{:*^10}|\", 123 * m);  // |**123 m***|\n</code></pre> <p>It is important to note that in the second line above, the quantity text is aligned to the right by default, which is consistent with the formatting of numeric types. Units and dimensions behave as text and, thus, are aligned to the left by default.</p> <p>Note</p> <p><code>std::println</code> is a C++23 facility. In case we do not have access to C++23, we can obtain the same output with:</p> <pre><code>std::cout &lt;&lt; std::format(\"&lt;format-string&gt;\\n\", &lt;format-args&gt;);\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#dimension-formatting","title":"Dimension formatting","text":"<pre><code>dimension-format-spec = [fill-and-align], [width], [dimension-spec];\ndimension-spec        = [character-set];\ncharacter-set         = 'U' | 'P';\n</code></pre> <p>In the above grammar:</p> <ul> <li><code>fill-and-align</code> and <code>width</code> tokens are defined in the format.string.std   chapter of the C++ standard specification,</li> <li><code>character-set</code> token specifies the symbol text encoding:<ul> <li><code>U</code> (default) uses the UTF-8 symbols defined by [@ISO80000] (e.g., <code>LT\u207b\u00b2</code>),</li> <li><code>P</code> forces non-standard portable output (e.g., <code>LT^-2</code>).</li> </ul> </li> </ul> <p>Dimension symbols of some quantities are specified to use Unicode signs by the ISQ (e.g., <code>\u0398</code> symbol for the thermodynamic temperature dimension). The library follows this by default. From the engineering point of view, sometimes Unicode text might not be the best solution, as terminals of many (especially embedded) devices can output only letters from the basic literal character set. In such a case, the dimension symbol can be forced to be printed using such characters thanks to <code>character-set</code> token:</p> <pre><code>std::println(\"{}\", isq::dim_thermodynamic_temperature);   // \u0398\nstd::println(\"{:P}\", isq::dim_thermodynamic_temperature); // O\nstd::println(\"{}\", isq::power.dimension);                 // L\u00b2MT\u207b\u00b3\nstd::println(\"{:P}\", isq::power.dimension);               // L^2MT^-3\n</code></pre>"},{"location":"users_guide/framework_basics/text_output/#unit-formatting","title":"Unit formatting","text":"<pre><code>unit-format-spec      = [fill-and-align], [width], [unit-spec];\nunit-spec             = [character-set], [unit-symbol-solidus], [unit-symbol-separator], [L]\n                      | [character-set], [unit-symbol-separator], [unit-symbol-solidus], [L]\n                      | [unit-symbol-solidus], [character-set], [unit-symbol-separator], [L]\n                      | [unit-symbol-solidus], [unit-symbol-separator], [character-set], [L]\n                      | [unit-symbol-separator], [character-set], [unit-symbol-solidus], [L]\n                      | [unit-symbol-separator], [unit-symbol-solidus], [character-set], [L];\nunit-symbol-solidus   = '1' | 'a' | 'n';\nunit-symbol-separator = 's' | 'd';\n</code></pre> <p>In the above grammar:</p> <ul> <li><code>fill-and-align</code> and <code>width</code> tokens are defined in the format.string.std   chapter of the C++ standard specification,</li> <li><code>unit-symbol-solidus</code> token specifies how the division of units should look like:<ul> <li>'1' (default) outputs <code>/</code> only when there is only one unit in the denominator, otherwise   negative exponents are printed (e.g., <code>m/s</code>, <code>kg m\u207b\u00b9 s\u207b\u00b9</code>)</li> <li>'a' always uses solidus (e.g., <code>m/s</code>, <code>kg/(m s)</code>)</li> <li>'n' never prints solidus, which means that negative exponents are always used   (e.g., <code>m s\u207b\u00b9</code>, <code>kg m\u207b\u00b9 s\u207b\u00b9</code>)</li> </ul> </li> <li><code>unit-symbol-separator</code> token specifies how multiplied unit symbols should be separated:<ul> <li>'s' (default) uses space as a separator (e.g., <code>kg m\u00b2/s\u00b2</code>)</li> <li>'d' uses half-high dot (<code>\u22c5</code>) as a separator (e.g., <code>kg\u22c5m\u00b2/s\u00b2</code>) (requires the UTF-8 encoding)</li> </ul> </li> <li>'L' is reserved for possible future localization use in case the C++ standard library gets access to   the ICU-like database.</li> </ul> <p>Note</p> <p>The above grammar intended that the elements of <code>unit-spec</code> can appear in any order as they have unique characters. Users shouldn't have to remember the order of those tokens to control the formatting of a unit symbol.</p> <p>Unit symbols of some quantities are specified to use Unicode signs by the SI (e.g., <code>\u03a9</code> symbol for the resistance quantity). The library follows this by default. From the engineering point of view, Unicode text might not be the best solution sometimes, as terminals of many (especially embedded) devices can output only letters from the basic literal character set. In such a case, the unit symbol can be forced to be printed using such characters thanks to <code>character-set</code> token:</p> <pre><code>std::println(\"{}\", si::ohm);      // \u03a9\nstd::println(\"{:P}\", si::ohm);    // ohm\nstd::println(\"{}\", us);           // \u00b5s\nstd::println(\"{:P}\", us);         // us\nstd::println(\"{}\", m / s2);       // m/s\u00b2\nstd::println(\"{:P}\", m / s2);     // m/s^2\n</code></pre> <p>Additionally, both ISO 80000 and SI leave some freedom on how to print unit symbols. This is why two additional tokens were introduced.</p> <p><code>unit-symbol-solidus</code> specifies how the division of units should look like. By default, <code>/</code> will be used only when the denominator contains only one unit. However, with the 'a' or 'n' options, we can force the facility to print the <code>/</code> character always (even when there are more units in the denominator), or never, in which case a parenthesis will be added to enclose all denominator units.</p> <pre><code>std::println(\"{}\", m / s);          // m/s\nstd::println(\"{}\", kg / m / s2);    // kg m\u207b\u00b9 s\u207b\u00b2\nstd::println(\"{:a}\", m / s);        // m/s\nstd::println(\"{:a}\", kg / m / s2);  // kg/(m s\u00b2)\nstd::println(\"{:n}\", m / s);        // m s\u207b\u00b9\nstd::println(\"{:n}\", kg / m / s2);  // kg m\u207b\u00b9 s\u207b\u00b2\n</code></pre> <p>The <code>unit-symbol-separator</code> token allows us to obtain the following outputs:</p> <pre><code>std::println(\"{}\", kg * m2 / s2);    // kg m\u00b2/s\u00b2\nstd::println(\"{:d}\", kg * m2 / s2);  // kg\u22c5m\u00b2/s\u00b2\n</code></pre> <p>Note</p> <p>'d' requires the UTF-8 encoding to be set.</p>"},{"location":"users_guide/framework_basics/text_output/#quantity-formatting","title":"Quantity formatting","text":"<pre><code>quantity-format-spec        = [fill-and-align], [width], [quantity-specs], [defaults-specs];\nquantity-specs              = conversion-spec;\n                            | quantity-specs, conversion-spec;\n                            | quantity-specs, literal-char;\nliteral-char                = ? any character other than '{', '}', or '%' ?;\nconversion-spec             = '%', placement-type;\nplacement-type              = subentity-id | '?' | '%';\ndefaults-specs              = ':', default-spec-list;\ndefault-spec-list           = default-spec;\n                            | default-spec-list, default-spec;\ndefault-spec                = subentity-id, '[' format-spec ']';\nsubentity-id                = 'N' | 'U' | 'D';\nformat-spec                 = ? as specified by the formatter for the argument type ?;\n</code></pre> <p>In the above grammar:</p> <ul> <li><code>fill-and-align</code> and <code>width</code> tokens are defined in the format.string.std   chapter of the C++ standard specification,</li> <li><code>placement-type</code> token specifies which entity should be put and where:<ul> <li>'N' inserts a default-formatted numerical value of the quantity,</li> <li>'U' inserts a default-formatted unit of the quantity,</li> <li>'D' inserts a default-formatted dimension of the quantity,</li> <li>'?' inserts an optional separator between the number and a unit based on the value of   <code>space_before_unit_symbol</code> for this unit,</li> <li>'%' just inserts '%' character.</li> </ul> </li> <li><code>defaults-specs</code> token allows overwriting defaults for the underlying formatters with the custom   format string. Each override starts with a subentity identifier ('N', 'U', or 'D') followed by   the format string enclosed in square brackets.</li> </ul>"},{"location":"users_guide/framework_basics/text_output/#default-formatting","title":"Default formatting","text":"<p>To format <code>quantity</code> values, the formatting facility uses <code>quantity-format-spec</code>. If left empty, the default formatting is applied. The same default formatting is also applied to the output streams. This is why the following code lines produce the same output:</p> <pre><code>std::cout &lt;&lt; \"Distance: \" &lt;&lt; 123 * km &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; std::format(\"Distance: {}\\n\", 123 * km);\nstd::cout &lt;&lt; std::format(\"Distance: {:%N%?%U}\\n\", 123 * km);\n</code></pre> <p>Note</p> <p>For some quantities, the <code>{:%N %U}</code> format may provide a different output than the default one, as some units have <code>space_before_unit_symbol</code> customization point explicitly set to <code>false</code> (e.g., <code>%</code> and <code>\u00b0</code>).</p>"},{"location":"users_guide/framework_basics/text_output/#quantity-numerical-value-unit-symbol-or-both","title":"Quantity numerical value, unit symbol, or both?","text":"<p>Thanks to the grammar provided above, the user can easily decide to either:</p> <ul> <li> <p>print a whole quantity:</p> <pre><code>std::println(\"Speed: {}\", 120 * km / h);\n</code></pre> <pre><code>Speed: 120 km/h\n</code></pre> </li> <li> <p>provide custom quantity formatting:</p> <pre><code>std::println(\"Speed: {:%N in %U}\", 120 * km / h);\n</code></pre> <pre><code>Speed: 120 in km/h\n</code></pre> </li> <li> <p>provide custom formatting for components:</p> <pre><code>std::println(\"Speed: {::N[.2f]U[n]}\", 100. * km / (3 * h));\n</code></pre> <pre><code>Speed: 33.33 km h\u207b\u00b9\n</code></pre> </li> <li> <p>print only specific components (numerical value, unit, or dimension):</p> <pre><code>std::println(\"Speed:\\n- number: {0:%N}\\n- unit: {0:%U}\\n- dimension: {0:%D}\", 120 * km / h);\n</code></pre> <pre><code>Speed:\n- number: 120\n- unit: km/h\n- dimension: LT\u207b\u00b9\n</code></pre> </li> </ul>"},{"location":"users_guide/framework_basics/text_output/#formatting-of-the-quantity-numerical-value","title":"Formatting of the quantity numerical value","text":"<p>The representation type used as a numerical value of a quantity must provide its own formatter specialization. It will be called by the quantity formatter with the format-spec provided by the user in the <code>N</code> defaults specification.</p> <p>In case we use C++ fundamental arithmetic types with our quantities the standard formatter specified in format.string.std will be used. The rest of this chapter assumes that it is the case and provides some usage examples.</p> <p><code>sign</code> token allows us to specify how the value's sign is being printed:</p> <pre><code>std::println(\"{0},{0::N[+]},{0::N[-]},{0::N[ ]}\", 1 * m);   // 1 m,+1 m,1 m, 1 m\nstd::println(\"{0},{0::N[+]},{0::N[-]},{0::N[ ]}\", -1 * m);  // -1 m,-1 m,-1 m,-1 m\n</code></pre> <p>where:</p> <ul> <li><code>+</code> indicates that a sign should be used for both non-negative and negative numbers,</li> <li><code>-</code> indicates that a sign should be used for negative numbers and negative zero only   (this is the default behavior),</li> <li><code>&lt;space&gt;</code> indicates that a leading space should be used for non-negative numbers other   than negative zero, and a minus sign for negative numbers and negative zero.</li> </ul> <p><code>precision</code> token is allowed only for floating-point representation types:</p> <pre><code>std::println(\"{::N[.0]}\", 1.2345 * m);   // 1 m\nstd::println(\"{::N[.1]}\", 1.2345 * m);   // 1 m\nstd::println(\"{::N[.2]}\", 1.2345 * m);   // 1.2 m\nstd::println(\"{::N[.3]}\", 1.2345 * m);   // 1.23 m\nstd::println(\"{::N[.0f]}\", 1.2345 * m);  // 1 m\nstd::println(\"{::N[.1f]}\", 1.2345 * m);  // 1.2 m\nstd::println(\"{::N[.2f]}\", 1.2345 * m);  // 1.23 m\n</code></pre> <p><code>type</code> specifies how a value of the representation type is being printed. For integral types:</p> <pre><code>std::println(\"{::N[b]}\", 42 * m);    // 101010 m\nstd::println(\"{::N[B]}\", 42 * m);    // 101010 m\nstd::println(\"{::N[d]}\", 42 * m);    // 42 m\nstd::println(\"{::N[o]}\", 42 * m);    // 52 m\nstd::println(\"{::N[x]}\", 42 * m);    // 2a m\nstd::println(\"{::N[X]}\", 42 * m);    // 2A m\n</code></pre> <p>The above can be printed in an alternate version thanks to the <code>#</code> token:</p> <pre><code>std::println(\"{::N[#b]}\", 42 * m);   // 0b101010 m\nstd::println(\"{::N[#B]}\", 42 * m);   // 0B101010 m\nstd::println(\"{::N[#o]}\", 42 * m);   // 052 m\nstd::println(\"{::N[#x]}\", 42 * m);   // 0x2a m\nstd::println(\"{::N[#X]}\", 42 * m);   // 0X2A m\n</code></pre> <p>For floating-point values, the <code>type</code> token works as follows:</p> <pre><code>std::println(\"{::N[a]}\",   1.2345678 * m);      // 1.3c0ca2a5b1d5dp+0 m\nstd::println(\"{::N[.3a]}\", 1.2345678 * m);      // 1.3c1p+0 m\nstd::println(\"{::N[A]}\",   1.2345678 * m);      // 1.3C0CA2A5B1D5DP+0 m\nstd::println(\"{::N[.3A]}\", 1.2345678 * m);      // 1.3C1P+0 m\nstd::println(\"{::N[e]}\",   1.2345678 * m);      // 1.234568e+00 m\nstd::println(\"{::N[.3e]}\", 1.2345678 * m);      // 1.235e+00 m\nstd::println(\"{::N[E]}\",   1.2345678 * m);      // 1.234568E+00 m\nstd::println(\"{::N[.3E]}\", 1.2345678 * m);      // 1.235E+00 m\nstd::println(\"{::N[g]}\",   1.2345678 * m);      // 1.23457 m\nstd::println(\"{::N[g]}\",   1.2345678e8 * m);    // 1.23457e+08 m\nstd::println(\"{::N[.3g]}\", 1.2345678 * m);      // 1.23 m\nstd::println(\"{::N[.3g]}\", 1.2345678e8 * m);    // 1.23e+08 m\nstd::println(\"{::N[G]}\",   1.2345678 * m);      // 1.23457 m\nstd::println(\"{::N[G]}\",   1.2345678e8 * m);    // 1.23457E+08 m\nstd::println(\"{::N[.3G]}\", 1.2345678 * m);      // 1.23 m\nstd::println(\"{::N[.3G]}\", 1.2345678e8 * m);    // 1.23E+08 m\n</code></pre>"},{"location":"users_guide/framework_basics/the_affine_space/","title":"The Affine Space","text":"<p>The affine space has two types of entities:</p> <ul> <li>Point - a position specified with coordinate values (e.g., location, address, etc.)</li> <li>Displacement vector - the difference between two points (e.g., shift, offset,   displacement, duration, etc.)</li> </ul> <p>In the following subchapters, we will often refer to displacement vectors simply as vectors for brevity.</p> <p>Note</p> <p>The displacement vector described here is specific to the affine space theory and is not the same thing as the quantity of a vector character that we discussed in the \"Scalars, vectors, and tensors\" chapter (although, in some cases, those terms may overlap).</p>"},{"location":"users_guide/framework_basics/the_affine_space/#operations-in-the-affine-space","title":"Operations in the affine space","text":"<p>Here are the primary operations one can do in the affine space:</p> <ul> <li>vector + vector -&gt; vector</li> <li>vector - vector -&gt; vector</li> <li>-vector -&gt; vector</li> <li>vector * scalar -&gt; vector</li> <li>scalar * vector -&gt; vector</li> <li>vector / scalar -&gt; vector</li> <li>point - point -&gt; vector</li> <li>point + vector -&gt; point</li> <li>vector + point -&gt; point</li> <li>point - vector -&gt; point</li> </ul> <p>Important</p> <p>It is not possible to:</p> <ul> <li>add two points,</li> <li>subtract a point from a vector,</li> <li>multiply nor divide points with anything else.</li> </ul>"},{"location":"users_guide/framework_basics/the_affine_space/#points-are-more-common-than-most-of-us-imagine","title":"Points are more common than most of us imagine","text":"<p>Point abstractions should be used more often in the C++ software. They are not only about temperature or time. Points are everywhere around us and should become more popular in the products we implement. They can be used to implement:</p> <ul> <li>temperature points,</li> <li>timestamps,</li> <li>daily mass readouts from the scale,</li> <li>altitudes of mountain peaks on a map,</li> <li>current path length measured by the car's odometer,</li> <li>today's price of instruments on the market,</li> <li>and many more.</li> </ul> <p>Improving the affine space's Points intuition will allow us to write better and safer software.</p>"},{"location":"users_guide/framework_basics/the_affine_space/#displacement-vector-is-modeled-by-quantity","title":"Displacement vector is modeled by <code>quantity</code>","text":"<p>Up until now, each time we used a <code>quantity</code> in our code, we were modeling some kind of a difference between two things:</p> <ul> <li>the distance between two points,</li> <li>duration between two time points,</li> <li>the difference in speed (even if relative to zero).</li> </ul> <p>As we already know, a <code>quantity</code> type provides all operations required for a displacement vector abstraction in the affine space. It can be constructed with:</p> <ul> <li>the multiply syntax (works for most of the units),</li> <li><code>delta&lt;Reference&gt;</code> construction helper (e.g., <code>delta&lt;isq::height[m]&gt;(42)</code>, <code>delta&lt;deg_C&gt;(3)</code>),</li> <li>two-parameter constructor taking a number and a quantity reference/unit.</li> </ul> <p>Note</p> <p>The multiply syntax support is disabled for units that provide a point origin in their definition (i.e., units of temperature like <code>K</code>, <code>deg_C</code>, and <code>deg_F</code>).</p>"},{"location":"users_guide/framework_basics/the_affine_space/#point-is-modeled-by-quantity_point-and-pointorigin","title":"Point is modeled by <code>quantity_point</code> and <code>PointOrigin</code>","text":"<p>In the mp-units library, the Point abstraction is modelled by:</p> <ul> <li><code>PointOrigin</code> concept that specifies measurement origin, and</li> <li><code>quantity_point</code> class template that specifies a Point relative to a specific predefined origin.</li> </ul>"},{"location":"users_guide/framework_basics/the_affine_space/#quantity_point","title":"<code>quantity_point</code>","text":"<p>The <code>quantity_point</code> class template specifies an absolute quantity measured from a predefined origin:</p> <pre><code>template&lt;Reference auto R,\n         PointOriginFor&lt;get_quantity_spec(R)&gt; auto PO = default_point_origin(R),\n         RepresentationOf&lt;get_quantity_spec(R)&gt; Rep = double&gt;\nclass quantity_point;\n</code></pre> <p>As we can see above, the <code>quantity_point</code> class template exposes one additional parameter compared to <code>quantity</code>. The <code>PO</code> parameter satisfies a <code>PointOriginFor</code> concept and specifies the origin of our measurement scale.</p> <p>Each <code>quantity_point</code> internally stores a <code>quantity</code> object, which represents a displacement vector from the predefined origin. Thanks to this, an instantiation of a <code>quantity_point</code> can be considered as a model of a vector space from such an origin.</p> <p>Forcing the user to manually predefine an origin for every domain may be cumbersome and discourage users from using such abstractions at all. This is why, by default, the <code>PO</code> template parameter is initialized with the <code>default_point_origin(R)</code> that provides the quantity points' scale zeroth point using the following rules:</p> <ul> <li>if the measurement unit of a quantity specifies its point origin in its definition   (e.g., degree Celsius), then this origin is being used,</li> <li>otherwise, an instantiation of <code>zeroth_point_origin&lt;QuantitySpec&gt;</code> is being used which   provides a well-established zeroth point for a specific quantity type.</li> </ul> <p>Quantity points with default point origins may be constructed with the <code>point</code> construction helper or forcing an explicit conversion from the <code>quantity</code>:</p> <pre><code>// quantity_point qp1 = 42 * m;           // Compile-time error\n// quantity_point qp2 = 42 * K;           // Compile-time error\n// quantity_point qp3 = delta&lt;deg_C&gt;(42); // Compile-time error\nquantity_point qp4(42 * m);\nquantity_point qp5(42 * K);\nquantity_point qp6(delta&lt;deg_C&gt;(42));\nquantity_point qp7 = point&lt;m&gt;(42);\nquantity_point qp8 = point&lt;K&gt;(42);\nquantity_point qp9 = point&lt;deg_C&gt;(42);\n</code></pre> <p>Tip</p> <p>The <code>quantity_point</code> definition can be found in the <code>mp-units/quantity_point.h</code> header file.</p>"},{"location":"users_guide/framework_basics/the_affine_space/#zeroth_point_originquantityspec","title":"<code>zeroth_point_origin&lt;QuantitySpec&gt;</code>","text":"<p><code>zeroth_point_origin&lt;QuantitySpec&gt;</code> is meant to be used in cases where the specific domain has a well-established, non-controversial, and unique zeroth point on the measurement scale. This saves the user from the need to write a boilerplate code that would predefine such a type for this domain.</p> <p></p> <pre><code>quantity_point&lt;isq::distance[si::metre]&gt; qp1(100 * m);\nquantity_point&lt;isq::distance[si::metre]&gt; qp2 = point&lt;m&gt;(120);\n\nassert(qp1.quantity_from_zero() == 100 * m);\nassert(qp2.quantity_from_zero() == 120 * m);\nassert(qp2.quantity_from(qp1) == 20 * m);\nassert(qp1.quantity_from(qp2) == -20 * m);\n\nassert(qp2 - qp1 == 20 * m);\nassert(qp1 - qp2 == -20 * m);\n\n// auto res = qp1 + qp2;   // Compile-time error\n</code></pre> <p>In the above code <code>100 * m</code> and <code>120 * m</code> still create two quantities that serve as displacement vectors here. Quantity point objects can be explicitly constructed from such quantities only when their origin is an instantiation of the <code>zeroth_point_origin&lt;QuantitySpec&gt;</code>.</p> <p>It is really important to understand that even though we can use <code>.quantity_from_zero()</code> to obtain the displacement vector of a point from the origin, the point by itself does not represent or have any associated physical value. It is just a point in some space. The same point can be expressed with different displacement vectors from different origins.</p> <p>It is also worth mentioning that simplicity comes with a safety cost here. For some users, it might be surprising that the usage of <code>zeroth_point_origin&lt;QuantitySpec&gt;</code> makes various quantity point objects compatible as long as quantity types used in the origin and reference are compatible:</p> <pre><code>quantity_point&lt;si::metre&gt; qp1{isq::distance(100 * m)};\nquantity_point&lt;si::metre&gt; qp2 = point&lt;isq::height[m]&gt;(120);\n\nassert(qp2.quantity_from(qp1) == 20 * m);\nassert(qp1.quantity_from(qp2) == -20 * m);\nassert(qp2 - qp1 == 20 * m);\nassert(qp1 - qp2 == -20 * m);\n</code></pre>"},{"location":"users_guide/framework_basics/the_affine_space/#absolute-point-origin","title":"Absolute point origin","text":"<p>In cases where we want to implement an isolated independent space in which points are not compatible with other spaces, even of the same quantity type, we should manually predefine an absolute point origin.</p> <p></p> <pre><code>inline constexpr struct origin final : absolute_point_origin&lt;isq::distance&gt; {} origin;\n\n// quantity_point&lt;si::metre, origin&gt; qp1{100 * m};        // Compile-time error\n// quantity_point&lt;si::metre, origin&gt; qp2{delta&lt;m&gt;(120)};  // Compile-time error\nquantity_point&lt;si::metre, origin&gt; qp1 = origin + 100 * m;\nquantity_point&lt;si::metre, origin&gt; qp2 = 120 * m + origin;\n\n// assert(qp1.quantity_from_zero() == 100 * m);   // Compile-time error\n// assert(qp2.quantity_from_zero() == 120 * m);   // Compile-time error\nassert(qp1.quantity_from(origin) == 100 * m);\nassert(qp2.quantity_from(origin) == 120 * m);\nassert(qp2.quantity_from(qp1) == 20 * m);\nassert(qp1.quantity_from(qp2) == -20 * m);\n\nassert(qp1 - origin == 100 * m);\nassert(qp2 - origin == 120 * m);\nassert(qp2 - qp1 == 20 * m);\nassert(qp1 - qp2 == -20 * m);\n\nassert(origin - qp1 == -100 * m);\nassert(origin - qp2 == -120 * m);\n\n// assert(origin - origin == 0 * m);   // Compile-time error\n</code></pre> <p>We can't construct a quantity point directly from the quantity anymore when a custom, named origin is used. To prevent potential safety and maintenance issues, we always need to explicitly provide both a compatible origin and a quantity measured from it to construct a quantity point.</p> <p>Said otherwise, a quantity point defined in terms of a specific origin is the result of adding the origin and the displacement vector measured from it to the point we create.</p> <p>Info</p> <p>A rationale for this longer construction syntax can be found in the Why can't I create a quantity by passing a number to a constructor? chapter.</p> <p>Similarly to creation of a quantity, if someone does not like the operator-based syntax to create a <code>quantity_point</code>, the same results can be achieved with a two-parameter constructor:</p> <pre><code>quantity_point qp1{100 * m, origin};\n</code></pre> <p>Again, CTAD always helps to use precisely the type we need in a current case.</p> <p>Additionally, if a quantity point is defined in terms of a custom, named origin, then we can't use a <code>quantity_from_zero()</code> member function anymore. This is to prevent surprises, as our origin may not necessarily be perceived as an absolute zero in the domain we model. Also, as we will learn soon, we can define several related origins in one space, and then it gets harder to understand which one is the \"zero\" one. This is why, to be specific and always correct about the points we use, a <code>quantity_from(QP)</code> member function can be used (where <code>QP</code> can either be an origin or another quantity point).</p> <p>Finally, please note that it is not allowed to subtract two point origins defined in terms of <code>absolute_point_origin</code> (e.g., <code>origin - origin</code>) as those do not contain information about the unit, so we cannot determine a resulting <code>quantity</code> type.</p>"},{"location":"users_guide/framework_basics/the_affine_space/#modeling-independent-spaces-in-one-domain","title":"Modeling independent spaces in one domain","text":"<p>Absolute point origins are also perfect for establishing independent spaces even if the same quantity type and unit is being used:</p> <p></p> <pre><code>inline constexpr struct origin1 final : absolute_point_origin&lt;isq::distance&gt; {} origin1;\ninline constexpr struct origin2 final : absolute_point_origin&lt;isq::distance&gt; {} origin2;\n\nquantity_point qp1 = origin1 + 100 * m;\nquantity_point qp2 = origin2 + 120 * m;\n\nassert(qp1.quantity_from(origin1) == 100 * m);\nassert(qp2.quantity_from(origin2) == 120 * m);\n\nassert(qp1 - origin1 == 100 * m);\nassert(qp2 - origin2 == 120 * m);\nassert(origin1 - qp1 == -100 * m);\nassert(origin2 - qp2 == -120 * m);\n\n// assert(qp2 - qp1 == 20 * m);                    // Compile-time error\n// assert(qp1 - origin2 == 100 * m);               // Compile-time error\n// assert(qp2 - origin1 == 120 * m);               // Compile-time error\n// assert(qp2.quantity_from(qp1) == 20 * m);       // Compile-time error\n// assert(qp1.quantity_from(origin2) == 100 * m);  // Compile-time error\n// assert(qp2.quantity_from(origin1) == 120 * m);  // Compile-time error\n</code></pre>"},{"location":"users_guide/framework_basics/the_affine_space/#relative-point-origin","title":"Relative Point origin","text":"<p>We often do not have only one ultimate \"zero\" point when we measure things. Often, we have one common scale, but we measure various quantities relative to different points and expect those points to be compatible. There are many examples here, but probably the most common are temperatures, timestamps, and altitudes.</p> <p>For such cases, relative point origins should be used:</p> <p></p> <pre><code>inline constexpr struct A final : absolute_point_origin&lt;isq::distance&gt; {} A;\ninline constexpr struct B final : relative_point_origin&lt;A + 10 * m&gt; {} B;\ninline constexpr struct C final : relative_point_origin&lt;B + 10 * m&gt; {} C;\ninline constexpr struct D final : relative_point_origin&lt;A + 30 * m&gt; {} D;\n\nquantity_point qp1 = C + 100 * m;\nquantity_point qp2 = D + 120 * m;\n\nassert(qp1.quantity_ref_from(qp1.point_origin) == 100 * m);\nassert(qp2.quantity_ref_from(qp2.point_origin) == 120 * m);\n\nassert(qp2.quantity_from(qp1) == 30 * m);\nassert(qp1.quantity_from(qp2) == -30 * m);\nassert(qp2 - qp1 == 30 * m);\nassert(qp1 - qp2 == -30 * m);\n\nassert(qp1.quantity_from(A) == 120 * m);\nassert(qp1.quantity_from(B) == 110 * m);\nassert(qp1.quantity_from(C) == 100 * m);\nassert(qp1.quantity_from(D) == 90 * m);\nassert(qp1 - A == 120 * m);\nassert(qp1 - B == 110 * m);\nassert(qp1 - C == 100 * m);\nassert(qp1 - D == 90 * m);\n\nassert(qp2.quantity_from(A) == 150 * m);\nassert(qp2.quantity_from(B) == 140 * m);\nassert(qp2.quantity_from(C) == 130 * m);\nassert(qp2.quantity_from(D) == 120 * m);\nassert(qp2 - A == 150 * m);\nassert(qp2 - B == 140 * m);\nassert(qp2 - C == 130 * m);\nassert(qp2 - D == 120 * m);\n\nassert(B - A == 10 * m);\nassert(C - A == 20 * m);\nassert(D - A == 30 * m);\nassert(D - C == 10 * m);\n\nassert(B - B == 0 * m);\n// assert(A - A == 0 * m);  // Compile-time error\n</code></pre> <p>Note</p> <p>Even though we can't subtract two absolute point origins from each other, it is possible to subtract relative ones or relative and absolute ones.</p>"},{"location":"users_guide/framework_basics/the_affine_space/#converting-between-different-representations-of-the-same-point","title":"Converting between different representations of the same point","text":"<p>As we might represent the same point with displacement vectors from various origins, the library provides facilities to convert the same point to the <code>quantity_point</code> class templates expressed in terms of different origins.</p> <p></p> <p>For this purpose, we can use either:</p> <ul> <li> <p>A converting constructor:</p> <pre><code>quantity_point&lt;si::metre, C&gt; qp2C = qp2;\nassert(qp2C.quantity_ref_from(qp2C.point_origin) == 130 * m);\n</code></pre> </li> <li> <p>A dedicated conversion interface:</p> <pre><code>quantity_point qp2B = qp2.point_for(B);\nquantity_point qp2A = qp2.point_for(A);\n\nassert(qp2B.quantity_ref_from(qp2B.point_origin) == 140 * m);\nassert(qp2A.quantity_ref_from(qp2A.point_origin) == 150 * m);\n</code></pre> </li> </ul> <p>It is important to understand that all such translations still describe exactly the same point (e.g., all of them compare equal):</p> <pre><code>assert(qp2 == qp2C);\nassert(qp2 == qp2B);\nassert(qp2 == qp2A);\n</code></pre> <p>Important</p> <p>It is only allowed to convert between various origins defined in terms of the same <code>absolute_point_origin</code>. Even if it is possible to express the same point as a displacement vector from another <code>absolute_point_origin</code>, the library will not provide such a conversion. A custom user-defined conversion function will be needed to add such a functionality.</p> <p>Said another way, in the library, there is no way to spell how two distinct <code>absolute_point_origin</code> types relate to each other.</p>"},{"location":"users_guide/framework_basics/the_affine_space/#temperature-support","title":"Temperature support","text":"<p>Support for temperature quantity points is probably one of the most common examples of relative point origins in action that we use in daily life.</p> <p>The SI definition in the library provides a few predefined point origins for this purpose:</p> <pre><code>namespace si {\n\ninline constexpr struct absolute_zero final : absolute_point_origin&lt;isq::thermodynamic_temperature&gt; {} absolute_zero;\ninline constexpr auto zeroth_kelvin = absolute_zero;\n\ninline constexpr struct ice_point final : relative_point_origin&lt;point&lt;milli&lt;kelvin&gt;&gt;(273'150)}&gt; {} ice_point;\ninline constexpr auto zeroth_degree_Celsius = ice_point;\n\n}\n\nnamespace usc {\n\ninline constexpr struct zeroth_degree_Fahrenheit final :\n  relative_point_origin&lt;point&lt;mag_ratio&lt;5, 9&gt; * si::degree_Celsius&gt;(-32)&gt; {} zeroth_degree_Fahrenheit;\n\n}\n</code></pre> <p>The above is a great example of how point origins can be stacked on top of each other:</p> <ul> <li><code>usc::zeroth_degree_Fahrenheit</code> is defined relative to <code>si::zeroth_degree_Celsius</code></li> <li><code>si::zeroth_degree_Celsius</code> is defined relative to <code>si::zeroth_kelvin</code>.</li> </ul> <p>Note</p> <p>Notice that while stacking point origins, we can use different representation types and units for origins and a point. In the above example, the relative point origin for degree Celsius is defined in terms of <code>si::kelvin</code>, while the quantity point for it will use <code>si::degree_Celsius</code> as a unit.</p> <p>The temperature point origins defined above are provided explicitly in the respective units' definitions:</p> <pre><code>namespace si {\n\ninline constexpr struct kelvin final :\n    named_unit&lt;\"K\", kind_of&lt;isq::thermodynamic_temperature&gt;, zeroth_kelvin&gt; {} kelvin;\ninline constexpr struct degree_Celsius final :\n    named_unit&lt;{u8\"\u2103\", \"`C\"}, kelvin, zeroth_degree_Celsius&gt; {} degree_Celsius;\n\n}\n\nnamespace usc {\n\ninline constexpr struct degree_Fahrenheit final :\n    named_unit&lt;{u8\"\u2109\", \"`F\"}, mag_ratio&lt;5, 9&gt; * si::degree_Celsius,\n               zeroth_degree_Fahrenheit&gt; {} degree_Fahrenheit;\n\n}\n</code></pre> <p>As it was described above, <code>default_point_origin(R)</code> returns a <code>zeroth_point_origin&lt;QuantitySpec&gt;</code> when a unit does not provide any origin in its definition. As of today, the units of temperature are the only ones in the entire mp-units library that provide such origins.</p> <p>Now, let's see how we can benefit from the above definitions. We have quite a few alternatives to choose from here. Depending on our needs or tastes, we can:</p> <ul> <li> <p>be explicit about the unit and origin:</p> <pre><code>quantity_point&lt;si::degree_Celsius, si::zeroth_degree_Celsius&gt; q1 = si::zeroth_degree_Celsius + delta&lt;deg_C&gt;(20.5);\nquantity_point&lt;si::degree_Celsius, si::zeroth_degree_Celsius&gt; q2{delta&lt;deg_C&gt;(20.5), si::zeroth_degree_Celsius};\nquantity_point&lt;si::degree_Celsius, si::zeroth_degree_Celsius&gt; q3{delta&lt;deg_C&gt;(20.5)};\nquantity_point&lt;si::degree_Celsius, si::zeroth_degree_Celsius&gt; q4 = point&lt;deg_C&gt;(20.5);\n</code></pre> </li> <li> <p>specify a unit and use its zeroth point origin implicitly:</p> <pre><code>quantity_point&lt;si::degree_Celsius&gt; q5 = si::zeroth_degree_Celsius + delta&lt;deg_C&gt;(20.5);\nquantity_point&lt;si::degree_Celsius&gt; q6{delta&lt;deg_C&gt;(20.5), si::zeroth_degree_Celsius};\nquantity_point&lt;si::degree_Celsius&gt; q7{delta&lt;deg_C&gt;(20.5)};\nquantity_point&lt;si::degree_Celsius&gt; q8 = point&lt;deg_C&gt;(20.5);\n</code></pre> </li> <li> <p>benefit from CTAD:</p> <pre><code>quantity_point q9 = si::zeroth_degree_Celsius + delta&lt;deg_C&gt;(20.5);\nquantity_point q10{delta&lt;deg_C&gt;(20.5), si::zeroth_degree_Celsius};\nquantity_point q11{delta&lt;deg_C&gt;(20.5)};\nquantity_point q12 = point&lt;deg_C&gt;(20.5);\n</code></pre> </li> </ul> <p>In all of the above cases, we end up with the <code>quantity_point</code> of the same type and value.</p> <p>To play a bit more with temperatures, we can implement a simple room AC temperature controller in the following way:</p> <p></p> <pre><code>constexpr struct room_reference_temp final : relative_point_origin&lt;point&lt;deg_C&gt;(21)&gt; {} room_reference_temp;\nusing room_temp = quantity_point&lt;isq::Celsius_temperature[deg_C], room_reference_temp&gt;;\n\nconstexpr auto step_delta = delta&lt;isq::Celsius_temperature&lt;deg_C&gt;&gt;(0.5);\nconstexpr int number_of_steps = 6;\n\nroom_temp room_ref{};\nroom_temp room_low = room_ref - number_of_steps * step_delta;\nroom_temp room_high = room_ref + number_of_steps * step_delta;\n\nstd::println(\"Room reference temperature: {} ({}, {::N[.2f]})\\n\",\n             room_ref.quantity_from_zero(),\n             room_ref.in(usc::degree_Fahrenheit).quantity_from_zero(),\n             room_ref.in(si::kelvin).quantity_from_zero());\n\nstd::println(\"| {:&lt;18} | {:^18} | {:^18} | {:^18} |\",\n             \"Temperature delta\", \"Room reference\", \"Ice point\", \"Absolute zero\");\nstd::println(\"|{0:=^20}|{0:=^20}|{0:=^20}|{0:=^20}|\", \"\");\n\nauto print_temp = [&amp;](std::string_view label, auto v) {\n  std::println(\"| {:&lt;14} | {:^18} | {:^18} | {:^18:N[.2f]} |\", label,\n               v - room_reference_temp, (v - si::ice_point).in(deg_C), (v - si::absolute_zero).in(deg_C));\n};\n\nprint_temp(\"Lowest\", room_low);\nprint_temp(\"Default\", room_ref);\nprint_temp(\"Highest\", room_high);\n</code></pre> <p>The above prints:</p> <pre><code>Room reference temperature: 21 \u2103 (69.8 \u2109, 294.15 K)\n\n| Temperature delta  |   Room reference   |     Ice point      |   Absolute zero    |\n|====================|====================|====================|====================|\n| Lowest             |       -3 \u2103        |       18 \u2103        |     291.15 \u2103      |\n| Default            |        0 \u2103        |       21 \u2103        |     294.15 \u2103      |\n| Highest            |        3 \u2103        |       24 \u2103        |     297.15 \u2103      |\n</code></pre>"},{"location":"users_guide/framework_basics/the_affine_space/#no-text-output-for-points","title":"No text output for Points","text":"<p>The library does not provide a text output for quantity points. The quantity stored inside is just an implementation detail of this type. It is a vector from a specific origin. Without the knowledge of the origin, the vector by itself is useless as we can't determine which point it describes.</p> <p>In the current library design, point origin does not provide any text in its definition. Even if we could add such information to the point's definition, we would not know how to output it in the text. There may be many ways to do it. For example, should we prepend or append the origin part to the quantity text?</p> <p>For example, the text output of <code>42 m</code> for a quantity point may mean many things. It may be an offset from the mountain top, sea level, or maybe the center of Mars. Printing <code>42 m AMSL</code> for altitudes above mean sea level is a much better solution, but the library does not have enough information to print it that way by itself.</p>"},{"location":"users_guide/framework_basics/the_affine_space/#the-affine-space-is-about-type-safety","title":"The affine space is about type-safety","text":"<p>The following operations are not allowed in the affine space:</p> <ul> <li>adding two <code>quantity_point</code> objects<ul> <li>It is physically impossible to add positions of home and Denver airports.</li> </ul> </li> <li>subtracting a <code>quantity_point</code> from a <code>quantity</code><ul> <li>What would it mean to subtract the DEN airport location from the distance to it?</li> </ul> </li> <li>multiplying/dividing a <code>quantity_point</code> with a scalar<ul> <li>What is the position of <code>2 *</code> DEN airport location?</li> </ul> </li> <li>multiplying/dividing a <code>quantity_point</code> with a quantity<ul> <li>What would multiplying the distance with the DEN airport location mean?</li> </ul> </li> <li>multiplying/dividing two <code>quantity_point</code> objects<ul> <li>What would multiplying home and DEN airport location mean?</li> </ul> </li> <li>mixing <code>quantity_points</code> of different quantity kinds<ul> <li>It is physically impossible to subtract time from length.</li> </ul> </li> <li>mixing <code>quantity_points</code> of inconvertible quantities<ul> <li>What does subtracting a distance point to DEN airport from the Mount Everest base camp   altitude mean?</li> </ul> </li> <li>mixing <code>quantity_points</code> of convertible quantities but with unrelated origins<ul> <li>How do we subtract a point on our trip to CppCon measured relatively to our home location from   a point measured relative to the center of the Solar System?</li> </ul> </li> </ul> <p>Important: The affine space improves safety</p> <p>The usage of <code>quantity_point</code> and affine space types, in general, improves expressiveness and type-safety of the code we write.</p>"},{"location":"users_guide/framework_basics/value_conversions/","title":"Value Conversions","text":"<p>One of the most important features of every unit library is to provide support for compile-time-enabled conversions of a numerical value of a quantity.</p> <p>A numerical value of a quantity depends on two elements:</p> <ul> <li>quantity representation type (e.g., <code>int</code>, <code>double</code>) that stores the number expressing the amount   of quantity,</li> <li>unit in which the quantity is being measured.</li> </ul> <p>Changing any of the above may require changing the value stored in a quantity.</p>"},{"location":"users_guide/framework_basics/value_conversions/#value-preserving-conversions","title":"Value-preserving conversions","text":"<pre><code>auto q1 = 5 * km;\nstd::cout &lt;&lt; q1.in(m) &lt;&lt; '\\n';\nquantity&lt;si::metre, int&gt; q2 = q1;\n</code></pre> <p>The second line above converts the current quantity to the one expressed in meters and prints its contents. The third line converts the quantity expressed in kilometers into the one measured in meters.</p> <p>In case a user would like to perform an opposite transformation:</p> <pre><code>auto q1 = 5 * m;\nstd::cout &lt;&lt; q1.in(km) &lt;&lt; '\\n';\nquantity&lt;si::kilo&lt;si::metre&gt;, int&gt; q2 = q1;\n</code></pre> <p>Both conversions will fail to compile.</p> <p>There are two ways to make the above work. The first solution is to use a floating-point representation type:</p> <pre><code>auto q1 = 5. * m;\nstd::cout &lt;&lt; q1.in(km) &lt;&lt; '\\n';\nquantity&lt;si::kilo&lt;si::metre&gt;&gt; q2 = q1;\n</code></pre> <p>or</p> <pre><code>auto q1 = 5 * m;\nstd::cout &lt;&lt; value_cast&lt;double&gt;(q1).in(km) &lt;&lt; '\\n';\nquantity&lt;si::kilo&lt;si::metre&gt;&gt; q2 = q1;  // double by default\n</code></pre> <p>Important</p> <p>The mp-units library follows <code>std::chrono::duration</code> logic and treats floating-point types as value-preserving.</p>"},{"location":"users_guide/framework_basics/value_conversions/#value-truncating-conversions","title":"Value-truncating conversions","text":"<p>The second solution is to force a truncating conversion:</p> <pre><code>auto q1 = 5 * m;\nstd::cout &lt;&lt; value_cast&lt;km&gt;(q1) &lt;&lt; '\\n';\nquantity&lt;si::kilo&lt;si::metre&gt;, int&gt; q2 = q1.force_in(km);\n</code></pre> <p>This explicit cast makes it clear that something unsafe is going on. It is easy to spot in code reviews or while chasing a bug in the source code.</p> <p>Note</p> <p><code>q.force_in(U)</code> is just a shortcut to run <code>value_cast&lt;U&gt;(q)</code>. There is no difference in behavior between those two interfaces. <code>q.force_in(U)</code> was added for consistency with <code>q.in(U)</code> and <code>q.force_numerical_value_in(U)</code>.</p> <p>Another place where this cast is useful is when a user wants to convert a quantity with a floating-point representation to the one using an integral one. Again, this is a truncating conversion, so an explicit cast is needed:</p> <pre><code>quantity&lt;si::metre, int&gt; q3 = value_cast&lt;int&gt;(3.14 * m);\n</code></pre> <p>Info</p> <p>It is often OK to use an integral as a representation type, but in general, floating-point types provide better precision and are privileged in the library as they are considered to be value-preserving.</p> <p>In some cases, a unit and a representation type should be changed simultaneously. Moreover, sometimes, the order of doing those operations matters. In such cases, the library provides the <code>value_cast&lt;U, Rep&gt;(q)</code> which always returns the most precise result:</p> C++23C++20Portable <pre><code>inline constexpr struct dim_currency final : base_dimension&lt;\"$\"&gt; {} dim_currency;\ninline constexpr struct currency final : quantity_spec&lt;dim_currency&gt; {} currency;\n\ninline constexpr struct us_dollar final : named_unit&lt;\"USD\", kind_of&lt;currency&gt;&gt; {} us_dollar;\ninline constexpr struct scaled_us_dollar final : named_unit&lt;\"USD_s\", mag_power&lt;10, -8&gt; * us_dollar&gt; {} scaled_us_dollar;\n\nnamespace unit_symbols {\n\ninline constexpr auto USD = us_dollar;\ninline constexpr auto USD_s = scaled_us_dollar;\n\n}  // namespace unit_symbols\n\nusing Price = quantity_point&lt;currency[us_dollar]&gt;;\nusing Scaled = quantity_point&lt;currency[scaled_us_dollar], zeroth_point_origin&lt;currency&gt;, std::int64_t&gt;;\n</code></pre> <pre><code>inline constexpr struct dim_currency final : base_dimension&lt;\"$\"&gt; {} dim_currency;\ninline constexpr struct currency final : quantity_spec&lt;currency, dim_currency&gt; {} currency;\n\ninline constexpr struct us_dollar final : named_unit&lt;\"USD\", kind_of&lt;currency&gt;&gt; {} us_dollar;\ninline constexpr struct scaled_us_dollar final : named_unit&lt;\"USD_s\", mag_power&lt;10, -8&gt; * us_dollar&gt; {} scaled_us_dollar;\n\nnamespace unit_symbols {\n\ninline constexpr auto USD = us_dollar;\ninline constexpr auto USD_s = scaled_us_dollar;\n\n}  // namespace unit_symbols\n\nusing Price = quantity_point&lt;currency[us_dollar]&gt;;\nusing Scaled = quantity_point&lt;currency[scaled_us_dollar], zeroth_point_origin&lt;currency&gt;, std::int64_t&gt;;\n</code></pre> <pre><code>inline constexpr struct dim_currency final : base_dimension&lt;\"$\"&gt; {} dim_currency;\nQUANTITY_SPEC(currency, dim_currency);\n\ninline constexpr struct us_dollar final : named_unit&lt;\"USD\", kind_of&lt;currency&gt;&gt; {} us_dollar;\ninline constexpr struct scaled_us_dollar final : named_unit&lt;\"USD_s\", mag_power&lt;10, -8&gt; * us_dollar&gt; {} scaled_us_dollar;\n\nnamespace unit_symbols {\n\ninline constexpr auto USD = us_dollar;\ninline constexpr auto USD_s = scaled_us_dollar;\n\n}  // namespace unit_symbols\n\nusing Price = quantity_point&lt;currency[us_dollar]&gt;;\nusing Scaled = quantity_point&lt;currency[scaled_us_dollar], zeroth_point_origin&lt;currency&gt;, std::int64_t&gt;;\n</code></pre> <pre><code>using namespace unit_symbols;\nPrice price{12.95 * USD};\nScaled spx = value_cast&lt;USD_s, std::int64_t&gt;(price);\n</code></pre> <p>As a shortcut, instead of providing a unit and a representation type to <code>value_cast</code>, you may also provide a <code>Quantity</code> type directly, from which unit and representation type are taken. However, <code>value_cast&lt;Quantity&gt;</code>, still only allows for changes in unit and representation type, but not changing the type of the quantity. For that, you will have to use a <code>quantity_cast</code> instead.</p> <p>Overloads are also provided for instances of <code>quantity_point</code>. All variants of <code>value_cast&lt;...&gt;(q)</code> that apply to instances of <code>quantity</code> have a corresponding version applicable to <code>quantity_point</code>, where the <code>point_origin</code> remains untouched, and the cast changes how the \"offset\" from the origin is represented. Specifically, for any <code>quantity_point</code> instance <code>qp</code>, all of the following equivalences hold:</p> <pre><code>static_assert(value_cast&lt;Rep&gt;(qp) == quantity_point{value_cast&lt;Rep&gt;(qp.quantity_from(qp.point_origin)), qp.point_origin});\nstatic_assert(value_cast&lt;U&gt;(qp) == quantity_point{value_cast&lt;U&gt;(qp.quantity_from(qp.point_origin)), qp.point_origin});\nstatic_assert(value_cast&lt;U, Rep&gt;(qp) == quantity_point{value_cast&lt;U, Rep&gt;(qp.quantity_from(qp.point_origin)), qp.point_origin});\nstatic_assert(value_cast&lt;Q&gt;(qp) == quantity_point{value_cast&lt;Q&gt;(qp.quantity_from(qp.point_origin)), qp.point_origin});\n</code></pre> <p>Furthermore, there is one additional overload <code>value_cast&lt;ToQP&gt;(qp)</code>. This overload permits to additionally replace the <code>point_origin</code> with another compatible one, while still representing the same point in the affine space. Thus, it is roughly equivalent to <code>value_cast&lt;ToQP::unit, ToQP::rep&gt;(qp).point_for(ToQP::point_origin)</code>. In contrast to a separate <code>value_cast</code> followed by <code>point_for</code> (or vice-versa), the combined <code>value_cast</code> tries to choose the order of the individual conversion steps in a way to avoid both overflow and unnecessary loss of precision. Overflow is a risk because the change of origin point may require an addition of a potentially large offset (the difference between the origin points), which may well be outside the range of one or both quantity types.</p>"},{"location":"users_guide/framework_basics/value_conversions/#scaling-overflow-prevention","title":"Scaling overflow prevention","text":"<p>In the case of small integral types, it is easy to overflow the representation type for every value besides <code>0</code> while performing simple and popular unit conversions. This is why the library prevents such invalid conversions at compile-time both for explicit and implicit conversions:</p> <pre><code>quantity q1 = std::int8_t(1) * km;\nquantity q2 = q1.force_in(m);   // Compile-time error (1)\nif(q1 != 1 * m) { /* ... */ }   // Compile-time error (2)\n</code></pre> <ol> <li>Forced conversion would overflow on scaling.</li> <li>Implicit conversion that brings arguments to a common unit before comparison would overflow on    scaling.</li> </ol> <p>In the above example, the conversion factor between <code>km</code> and <code>m</code> is <code>1'000</code>, which is larger than the maximum value that can be stored in <code>std::int8_t</code>. Even if we want to convert the smallest possible integral amount (e.g., <code>1 km</code>), we will overflow the quantity representation type. We decided not to allow such conversions for safety reasons despite the value of <code>0 km</code> would work.</p>"},{"location":"users_guide/framework_basics/value_conversions/#value-conversions-summary","title":"Value conversions summary","text":"<p>The table below provides all the value conversion functions that may be run on <code>x</code> being the instance of either <code>quantity</code> or <code>quantity_point</code>:</p> Forcing Representation Unit Member function Non-member function No Same <code>u</code> <code>x.in(u)</code> No <code>T</code> Same <code>x.in&lt;T&gt;()</code> No <code>T</code> <code>u</code> <code>x.in&lt;T&gt;(u)</code> Yes Same <code>u</code> <code>x.force_in(u)</code> <code>value_cast&lt;u&gt;(x)</code> Yes <code>T</code> Same <code>x.force_in&lt;T&gt;()</code> <code>value_cast&lt;T&gt;(x)</code> Yes <code>T</code> <code>u</code> <code>x.force_in&lt;T&gt;(u)</code> <code>value_cast&lt;u, T&gt;(x)</code> or <code>value_cast&lt;T, u&gt;(x)</code>"},{"location":"users_guide/systems/strong_angular_system/","title":"Strong Angular System","text":""},{"location":"users_guide/systems/strong_angular_system/#some-background-information","title":"Some background information","text":"<p>As per today's SI, both radian and steradian are dimensionless. This forces the convention to set the angle <code>1 radian</code> equal to the number <code>1</code> within equations (similar to what natural units system does for <code>c</code> constant).</p> <p>Following Wikipedia:</p> <p>Wikipedia: Radian - Dimensional analysis</p> <p>Giacomo Prando says \"the current state of affairs leads inevitably to ghostly appearances and disappearances of the radian in the dimensional analysis of physical equations.\" For example, a mass hanging by a string from a pulley will rise or drop by \\(y=r\u03b8\\) centimeters, where \\(r\\) is the radius of the pulley in centimeters and \\(\u03b8\\) is the angle the pulley turns in radians. When multiplying \\(r\\) by \\(\u03b8\\) the unit of radians disappears from the result. Similarly in the formula for the angular velocity of a rolling wheel, \\(\u03c9=v/r\\), radians appear in the units of \\(\u03c9\\) but not on the right hand side. Anthony French calls this phenomenon \"a perennial problem in the teaching of mechanics\". Oberhofer says that the typical advice of ignoring radians during dimensional analysis and adding or removing radians in units according to convention and contextual knowledge is \"pedagogically unsatisfying\".</p> <p>At least a dozen scientists have made proposals to treat the radian as a base unit of measure defining its own dimension of \"angle\", as early as 1936 and as recently as 2022. This would bring the advantages of a physics-based, consistent, and logically-robust unit system, with unambiguous units for all physical quantities. At the same time the only notable changes for typical end-users would be: improved units for the quantities torque, angular momentum, and moment of inertia.</p> <p>Paul Quincey in his proposal \"Angles in the SI: a detailed proposal for solving the problem\" states:</p> <p>Paul Quincey: Angles in the SI: a detailed proposal for solving the problem</p> <p>The familiar units assigned to some angular quantities are based on equations that have adopted the radian convention, and so are missing <code>rad</code>s that would be present if the complete equation is used. The physically-correct units are those with the <code>rad</code>s reinstated. Numerical values would not change, and the physical meanings of all quantities would also be unaffected.</p> <p>He proposes the following changes:</p> <ul> <li>The radian would become either a new base unit or a 'complementary' unit</li> <li>The steradian would become a derived unit equal to \\(1\\:rad^2\\)</li> <li> <p>The SI units for</p> <ul> <li>Torque would change from \\(N\\:m\\) (\\(=J\\)) to \\(J\\:rad^{-1}\\)</li> <li>Angular momentum would change from \\(J\\:s\\) to \\(J\\:s\\:rad^{-1}\\) (i.e. \\(J/(rad/s)\\))</li> <li>Moment of inertia would change from \\(kg\\:m^2\\) to \\(kg\\:m^2\\:rad^{-2}\\) (i.e. \\(J/(rad/s)^2\\))</li> </ul> </li> <li> <p>The option to omit the radian from the SI units for angle, angular velocity, angular frequency,   angular acceleration, and angular wavenumber would be removed, the only correct SI units being   \\(rad\\), \\(rad/s\\), \\(rad/s\\), \\(rad/s^2\\) and \\(rad/m\\) respectively.</p> </li> </ul> <p>Paul Quincey summarizes that with the above in action:</p> <p>Paul Quincey: Angles in the SI: a detailed proposal for solving the problem</p> <p>However, the physical clarity this would build into the SI should be recognised very quickly. The units would tell us that \\(torque \\times angle = energy\\), and \\(angular\\:momentum \\times angle = action\\), for example, in the same way that they do for \\(force \\times distance = energy\\), \\(linear\\:momentum \\times distance = action\\), and \\(radiant\\:intensity \\times solid\\:angle = radiant\\:flux\\). Dimensional analysis could be used to its full extent. Software involving angular quantities would be rationalised. Arguments about the correct units for frequency and angular frequency, and the meaning of the unit \\(Hz\\), could be left behind. The explanation of these changes would be considerably easier and more rewarding than explaining how a kilogram-sized mass can be measured in terms of the Planck constant.</p>"},{"location":"users_guide/systems/strong_angular_system/#angular-quantities-in-the-si","title":"Angular quantities in the SI","text":"<p>Even though the SI somehow ignores the dimensionality of angle:</p> <p>SI Brochure</p> <p>Plane and solid angles, when expressed in radians and steradians respectively, are in effect also treated within the SI as quantities with the unit one. The symbols \\(rad\\) and \\(sr\\) are written explicitly where appropriate, in order to emphasize that, for radians or steradians, the quantity being considered is, or involves the plane angle or solid angle respectively. For steradians it emphasizes the distinction between units of flux and intensity in radiometry and photometry for example. However, it is a long-established practice in mathematics and across all areas of science to make use of \\(rad = 1\\) and \\(sr = 1\\). For historical reasons the radian and steradian are treated as derived units.</p> <p>It also explicitly states:</p> <p>SI Brochure</p> <p>The SI unit of frequency is hertz, the SI unit of angular velocity and angular frequency is radian per second, and the SI unit of activity is becquerel, implying counts per second. Although it is formally correct to write all three of these units as the reciprocal second, the use of the different names emphasizes the different nature of the quantities concerned. It is especially important to carefully distinguish frequencies from angular frequencies, because by definition their numerical values differ by a factor of \\(2\\pi\\). Ignoring this fact may cause an error of \\(2\\pi\\). Note that in some countries, frequency values are conventionally expressed using \u201ccycle/s\u201d or \u201ccps\u201d instead of the SI unit \\(Hz\\), although \u201ccycle\u201d and \u201ccps\u201d are not units in the SI. Note also that it is common, although not recommended, to use the term frequency for quantities expressed in \\(rad/s\\). Because of this, it is recommended that quantities called \u201cfrequency\u201d, \u201cangular frequency\u201d, and \u201cangular velocity\u201d always be given explicit units of \\(Hz\\) or \\(rad/s\\) and not \\(s^{-1}\\).</p>"},{"location":"users_guide/systems/strong_angular_system/#strong-angular-extensions-in-the-library","title":"Strong Angular extensions in the library","text":"<p>The mp-units library strives to define physically-correct quantities and their units to provide maximum help to its users. As treating angle as a dimensional quantity can lead to many \"trivial\" mistakes in dimensional analysis and calculation, it was decided to provide additional experimental systems of quantities and units that follow the above approach and treat angle as a base quantity with a base unit of radian and solid angle as its derived quantity.</p> <p>As those (at least for now) are not a part of SI, the plain angle and solid angle definitions can be found in a dedicated <code>angular</code> system. Those definitions are also used in the <code>isq_angle</code> system of quantities to make the recipes for angle-based quantities like torque or angular velocity physically correct:</p> <pre><code>using namespace mp_units;\nusing namespace mp_units::si::unit_symbols;\nusing mp_units::angular::unit_symbols::deg;\nusing mp_units::angular::unit_symbols::rad;\n\nconst quantity lever = isq_angle::position_vector(20 * cm);\nconst quantity force = isq_angle::force(500 * N);\nconst quantity angle = isq_angle::angular_measure(90. * deg);\nconst quantity torque = isq_angle::torque(lever * force * angular::sin(angle) / (1 * isq_angle::cotes_angle));\n\nstd::cout &lt;&lt; \"Applying a perpendicular force of \" &lt;&lt; force &lt;&lt; \" to a \" &lt;&lt; lever &lt;&lt; \" long lever results in \"\n          &lt;&lt; torque.in(N * m / rad) &lt;&lt; \" of torque.\\n\";\n</code></pre> <p>The above program prints:</p> <pre><code>Applying a perpendicular force of 500 N to a 20 cm long lever results in 100 N m/rad of torque.\n</code></pre> <p>Note</p> <p><code>cotes_angle</code> is a constant which represents an angle with the value of exactly <code>1 radian</code>. You can find more information about this constant in Quincey.</p> <p>Try it on Compiler Explorer</p>"},{"location":"users_guide/use_cases/interoperability_with_other_libraries/","title":"Interoperability with Other Libraries","text":"<p>mp-units makes it easy to cooperate with similar entities of other libraries. No matter if we want to provide interoperability with a simple home-grown strongly typed wrapper type (e.g., <code>Meter</code>, <code>Timestamp</code>, ...) or with a feature-rich quantities and units library, we have to provide specializations of:</p> <ul> <li>a <code>quantity_like_traits</code> for external <code>quantity</code>-like type,</li> <li>a <code>quantity_point_like_traits</code> for external <code>quantity_point</code>-like type.</li> </ul>"},{"location":"users_guide/use_cases/interoperability_with_other_libraries/#specifying-a-conversion-kind","title":"Specifying a conversion kind","text":"<p>Before we delve into the template specialization details, let's first decide if we want the conversions to happen implicitly or if explicit ones would be a better choice. Or maybe the conversion should be implicit in one direction only (e.g., into mp-units abstractions) while the explicit conversions in the other direction should be preferred?</p> <p>There is no one unified answer to the above questions. Everything depends on the use case.</p> <p>Typically, the implicit conversions are allowed in cases where:</p> <ul> <li>both abstractions mean exactly the same, and interchanging them in the code should not change   its logic,</li> <li>there is no significant runtime overhead introduced by such a conversion (e.g., no need for dynamic   allocation or copying of huge internal buffers),</li> <li>the target type of the conversion provides the same or better safety to the users,</li> <li>we prefer the simplicity of implicit conversions over safety during the (hopefully short)   transition period of refactoring our code base from the usage of one library to the other.</li> </ul> <p>In all other scenarios, we should probably enforce explicit conversions.</p> <p>The kinds of inter-library conversions can be easily configured in partial specializations of conversion traits in the mp-units library. Conversion traits should provide a static data member convertible to <code>bool</code>. If the value is <code>true</code>, then the conversion is <code>explicit</code>. Otherwise, if the value is <code>false</code>, implicit conversions will be allowed. The names of the flags are as follows:</p> <ul> <li><code>explicit_import</code> to describe conversion from the external entity to the one in this   library (import case),</li> <li><code>explicit_export</code> to describe conversion from the entity in this library to the external one   (export case).</li> </ul>"},{"location":"users_guide/use_cases/interoperability_with_other_libraries/#quantities-conversions","title":"Quantities conversions","text":"<p>For example, let's assume that some company has its own <code>Meter</code> strong-type wrapper:</p> <pre><code>struct Meter {\n  int value;\n};\n</code></pre> <p>As every usage of <code>Meter</code> is at least as good and safe as the usage of <code>quantity&lt;si::metre, int&gt;</code>, and as there is no significant runtime performance penalty, we would like to allow the conversion to <code>mp_units::quantity</code> to happen implicitly.</p> <p>On the other hand, the <code>quantity</code> type is much safer than the <code>Meter</code>, and that is why we would prefer to see the opposite conversions stated explicitly in our code.</p> <p>To enable such interoperability, we must define a partial specialization of the <code>quantity_like_traits&lt;T&gt;</code> type trait. Such specialization should provide:</p> <ul> <li><code>reference</code> static data member that provides the quantity reference (e.g., unit),</li> <li><code>rep</code> type that specifies the underlying storage type,</li> <li><code>explicit_import</code> static data member convertible to <code>bool</code> that specifies that the conversion   from <code>T</code> to a <code>quantity</code> type should happen explicitly (if <code>true</code>),</li> <li><code>explicit_export</code> static data member convertible to <code>bool</code> that specifies that the conversion   from a <code>quantity</code> type to <code>T</code> should happen explicitly (if <code>true</code>),</li> <li><code>to_numerical_value(T)</code> static member function returning a quantity's raw value of <code>rep</code> type,</li> <li><code>from_numerical_value(rep)</code> static member function returning <code>T</code>.</li> </ul> <p>For example, for our <code>Meter</code> type, we could provide the following:</p> <pre><code>template&lt;&gt;\nstruct mp_units::quantity_like_traits&lt;Meter&gt; {\n  static constexpr auto reference = si::metre;\n  static constexpr bool explicit_import = false;\n  static constexpr bool explicit_export = true;\n  using rep = decltype(Meter::value);\n  static constexpr rep to_numerical_value(Meter m) { return m.value; }\n  static constexpr Meter from_numerical_value(rep v) { return Meter{v}; }\n};\n</code></pre> <p>After that, we can check that the <code>QuantityLike</code> concept is satisfied:</p> <pre><code>static_assert(mp_units::QuantityLike&lt;Meter&gt;);\n</code></pre> <p>and we can write the following:</p> <pre><code>void print(Meter m) { std::cout &lt;&lt; m.value &lt;&lt; \" m\\n\"; }\n\nint main()\n{\n  using namespace mp_units;\n  using namespace mp_units::si::unit_symbols;\n\n  Meter height{42};\n\n  // implicit conversions\n  quantity h1 = height;\n  quantity&lt;isq::height[m], int&gt; h2 = height;\n\n  std::cout &lt;&lt; h1 &lt;&lt; \"\\n\";\n  std::cout &lt;&lt; h2 &lt;&lt; \"\\n\";\n\n  // explicit conversions\n  print(Meter(h1));\n  print(Meter(h2));\n}\n</code></pre> <p>Note</p> <p>No matter if we decide to use implicit or explicit conversions, the mp-units will not allow unsafe operations to happen.</p> <p>If we extend the above example with unsafe conversions, the code will not compile, and we will have to fix the issues first before the conversion may be performed:</p> UnsafeFixed <pre><code>quantity&lt;isq::height[m]&gt; h3 = height;\nquantity&lt;isq::height[mm], int&gt; h4 = height;\nquantity&lt;isq::height[km], int&gt; h5 = height;  // Compile-time error (1)\n\nstd::cout &lt;&lt; h3 &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; h4 &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; h5 &lt;&lt; \"\\n\";\n\nprint(Meter(h3));                            // Compile-time error (2)\nprint(Meter(h4));                            // Compile-time error (3)\nprint(Meter(h5));\n</code></pre> <ol> <li>Truncation of value while converting from meters to kilometers.</li> <li>Conversion of <code>double</code> to <code>int</code> is not value-preserving.</li> <li>Truncation of value while converting from millimeters to meters.</li> </ol> <pre><code>quantity&lt;isq::height[m]&gt; h3 = height;\nquantity&lt;isq::height[mm], int&gt; h4 = height;\nquantity&lt;isq::height[km], int&gt; h5 = quantity{height}.force_in(km);\n\nstd::cout &lt;&lt; h3 &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; h4 &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; h5 &lt;&lt; \"\\n\";\n\nprint(Meter(value_cast&lt;int&gt;(h3)));\nprint(Meter(h4.force_in(m)));\nprint(Meter(h5));\n</code></pre>"},{"location":"users_guide/use_cases/interoperability_with_other_libraries/#quantity-points-conversions","title":"Quantity points conversions","text":"<p>To play with quantity point conversions, let's assume that we have a <code>Timestamp</code> strong type in our codebase, and we would like to start using mp-units to work with this abstraction.</p> <pre><code>struct Timestamp {\n  int seconds;\n};\n</code></pre> <p>As we described in The Affine Space chapter, timestamps should be modeled as quantity points rather than regular quantities.</p> <p>To allow the conversion between our custom <code>Timestamp</code> type and the <code>quantity_point</code> class template we need to provide the following in the partial specialization of the <code>quantity_point_like_traits&lt;T&gt;</code> type trait:</p> <ul> <li><code>reference</code> static data member that provides the quantity point reference (e.g., unit),</li> <li><code>point_origin</code> static data member that specifies the absolute point, which is the beginning of   our measurement scale for our points,</li> <li><code>rep</code> type that specifies the underlying storage type,</li> <li><code>explicit_import</code> static data member convertible to <code>bool</code> that specifies that the conversion   from <code>T</code> to a <code>quantity</code> type should happen explicitly (if <code>true</code>),</li> <li><code>explicit_export</code> static data member convertible to <code>bool</code> that specifies that the conversion   from a <code>quantity</code> type to <code>T</code> should happen explicitly (if <code>true</code>),</li> <li><code>to_numerical_value(T)</code> static member function returning a raw value of the <code>quantity</code> being   the offset of the point from the origin,</li> <li><code>from_numerical_value(rep)</code> static member function returning <code>T</code>.</li> </ul> <p>For example, for our <code>Timestamp</code> type, we could provide the following:</p> <pre><code>template&lt;&gt;\nstruct mp_units::quantity_point_like_traits&lt;Timestamp&gt; {\n  static constexpr auto reference = si::second;\n  static constexpr auto point_origin = default_point_origin(reference);\n  static constexpr bool explicit_import = false;\n  static constexpr bool explicit_export = true;\n  using rep = decltype(Timestamp::seconds);\n  static constexpr rep to_numerical_value(Timestamp ts) { return ts.seconds; }\n  static constexpr Timestamp from_numerical_value(rep v) { return Timestamp(v); }\n};\n</code></pre> <p>After that, we can check that the <code>QuantityPointLike</code> concept is satisfied:</p> <pre><code>static_assert(mp_units::QuantityPointLike&lt;Timestamp&gt;);\n</code></pre> <p>and we can write the following:</p> <pre><code>void print(Timestamp ts) { std::cout &lt;&lt; ts.seconds &lt;&lt; \" s\\n\"; }\n\nint main()\n{\n  using namespace mp_units;\n  using namespace mp_units::si::unit_symbols;\n\n  Timestamp ts{42};\n\n  // implicit conversion\n  quantity_point qp = ts;\n\n  std::cout &lt;&lt; qp.quantity_from_zero() &lt;&lt; \"\\n\";\n\n  // explicit conversion\n  print(Timestamp(qp));\n}\n</code></pre>"},{"location":"users_guide/use_cases/interoperability_with_other_libraries/#interoperability-with-the-c-standard-library","title":"Interoperability with the C++ Standard Library","text":"<p>In the C++ standard library, we have two types that handle quantities and model the affine space. Those are:</p> <ul> <li><code>std::chrono::duration</code> - specifies   quantities of time,</li> <li><code>std::chrono::time_point</code> - specifies   quantity points of time.</li> </ul> <p>The mp-units library comes with built-in interoperability with those types. It is enough to include the mp-units/systems/si/chrono.h file to benefit from it. This file provides:</p> <ul> <li>partial specializations of <code>quantity_like_traits</code> and <code>quantity_point_like_traits</code> that provide   support for implicit conversions between <code>std</code> and <code>mp_units</code> types in both directions,</li> <li><code>chrono_point_origin&lt;Clock&gt;</code> point origin for <code>std</code> clocks,</li> <li><code>to_chrono_duration</code> and <code>to_chrono_time_point</code> dedicated conversion functions that result   in types exactly representing mp-units abstractions.</li> </ul> <p>Important</p> <p>Only a <code>quantity_point</code> that uses <code>chrono_point_origin&lt;Clock&gt;</code> as its origin can be converted to the <code>std::chrono</code> abstractions:</p> <pre><code>inline constexpr struct ts_origin final : relative_point_origin&lt;chrono_point_origin&lt;system_clock&gt; + 1 * h&gt; {} ts_origin;\ninline constexpr struct my_origin final : absolute_point_origin&lt;isq::time&gt; {} my_origin;\n\nquantity_point qp1 = sys_seconds{1s};\nauto tp1 = to_chrono_time_point(qp1);  // OK\n\nquantity_point qp2 = chrono_point_origin&lt;system_clock&gt; + 1 * s;\nauto tp2 = to_chrono_time_point(qp2);  // OK\n\nquantity_point qp3 = ts_origin + 1 * s;\nauto tp3 = to_chrono_time_point(qp3);  // OK\n\nquantity_point qp4 = my_origin + 1 * s;\nauto tp4 = to_chrono_time_point(qp4);  // Compile-time Error (1)\n\nquantity_point qp5{1 * s};\nauto tp5 = to_chrono_time_point(qp5);  // Compile-time Error (2)\n</code></pre> <ol> <li><code>my_origin</code> is not defined in terms of <code>chrono_point_origin&lt;Clock&gt;</code>.</li> <li><code>zeroth_point_origin</code> is not defined in terms of <code>chrono_point_origin&lt;Clock&gt;</code>.</li> </ol> <p>Here is an example of how interoperability described in this chapter can be used in practice:</p> <pre><code>using namespace std::chrono;\n\nsys_seconds ts_now = floor&lt;seconds&gt;(system_clock::now());\n\nquantity_point start_time = ts_now;\nquantity speed = 925. * km / h;\nquantity distance = 8111. * km;\nquantity flight_time = distance / speed;\nquantity_point exp_end_time = start_time + flight_time;\n\nsys_seconds ts_end = value_cast&lt;int&gt;(exp_end_time.in(s));\n\nauto curr_time = zoned_time(current_zone(), ts_now);\nauto mst_time = zoned_time(\"America/Denver\", ts_end);\n\nstd::cout &lt;&lt; \"Takeoff: \" &lt;&lt; curr_time &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"Landing: \" &lt;&lt; mst_time &lt;&lt; \"\\n\";\n</code></pre> <p>The above may print the following output:</p> <pre><code>Takeoff: 2023-11-18 13:20:54 UTC\nLanding: 2023-11-18 15:07:01 MST\n</code></pre>"},{"location":"users_guide/use_cases/wide_compatibility/","title":"Wide Compatibility","text":"<p>The mp-units allows us to implement nice and terse code targeting a specific C++ version and configuration. Such code is easy to write and understand but might not be portable to some older environments.</p> <p>However, sometimes, we want to develop code that can be compiled on a wide range of various compilers and configurations. This is why the library also exposes and uses special preprocessor macros that can be used to ensure the wide compatibility of our code.</p> <p>Note</p> <p>Those macros are used in our short example applications as those are meant to be built on all of the supported compilers. Some still do not support <code>std::format</code>, C++ modules, or C++ versions newer than C++20.</p>"},{"location":"users_guide/use_cases/wide_compatibility/#various-compatibility-options","title":"Various compatibility options","text":"<p>Depending on your compiler's conformance, you can choose to use any of the below styles to write your code using mp-units:</p> C++23C++20C++20 with header filesC++20 with header files + libfmtWide Compatibility <pre><code>#include &lt;format&gt;\n#include &lt;iostream&gt;\nimport mp_units;\n\n// ...\n\ninline constexpr struct horizontal_length final : quantity_spec&lt;isq::length&gt; {} horizontal_length;\n\n// ...\n\nstd::cout &lt;&lt; std::format(...) &lt;&lt; \"\\n\";\n</code></pre> <pre><code>#include &lt;format&gt;\n#include &lt;iostream&gt;\nimport mp_units;\n\n// ...\n\ninline constexpr struct horizontal_length final : quantity_spec&lt;horizontal_length, isq::length&gt; {} horizontal_length;\n\n// ...\n\nstd::cout &lt;&lt; std::format(...) &lt;&lt; \"\\n\";\n</code></pre> <pre><code>#include &lt;mp-units/systems/international.h&gt;\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#include &lt;format&gt;\n#include &lt;iostream&gt;\n\n// ...\n\ninline constexpr struct horizontal_length final : quantity_spec&lt;horizontal_length, isq::length&gt; {} horizontal_length;\n\n// ...\n\nstd::cout &lt;&lt; std::format(...) &lt;&lt; \"\\n\";\n</code></pre> <pre><code>#include &lt;mp-units/systems/international.h&gt;\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#include &lt;fmt/format.h&gt;\n#include &lt;iostream&gt;\n\n// ...\n\ninline constexpr struct horizontal_length final : quantity_spec&lt;horizontal_length, isq::length&gt; {} horizontal_length;\n\n// ...\n\nstd::cout &lt;&lt; fmt::format(...) &lt;&lt; \"\\n\";\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;mp-units/ext/format.h&gt;\n#ifdef MP_UNITS_MODULES\n#include &lt;mp-units/compat_macros.h&gt;\nimport mp_units;\n#else\n#include &lt;mp-units/systems/international.h&gt;\n#include &lt;mp-units/systems/isq.h&gt;\n#include &lt;mp-units/systems/si.h&gt;\n#endif\n\n// ...\n\nQUANTITY_SPEC(horizontal_length, isq::length);\n\n// ...\n\nstd::cout &lt;&lt; MP_UNITS_STD_FMT::format(...) &lt;&lt; \"\\n\";\n</code></pre> <p>Tip</p> <p>Depending on your preferences, you can either write:</p> <ul> <li>terse code directly targeting your specific compiler's abilities,</li> <li>verbose code using preprocessor branches and macros that provide the widest compatibility   across various compilers.</li> </ul>"},{"location":"users_guide/use_cases/wide_compatibility/#compatibility-macros","title":"Compatibility macros","text":"<p>This chapter describes only the most essential tools the mp-units users need. All the compatibility macros can be found in the mp-units/compat_macros.h header file.</p> <p>Tip</p> <p>The mp-units/compat_macros.h header file is implicitly included when we use \"legacy\" headers in our translation units. However, it has to be explicitly included when we use C++20 modules, as those do not propagate preprocessor macros.</p>"},{"location":"users_guide/use_cases/wide_compatibility/#QUANTITY_SPEC","title":"<code>QUANTITY_SPEC(name, ...)</code>","text":"<p>Quantity specification definitions benefit from an explicit object parameter added in C++23 to remove the need for CRTP idiom, which significantly simplifies the code.</p> <p>This macro benefits from the new C++23 feature if available. Otherwise, it uses the CRTP idiom under the hood.</p>"},{"location":"users_guide/use_cases/wide_compatibility/#mp_units_std_fmt","title":"<code>MP_UNITS_STD_FMT</code>","text":"<p>Some of the supported compilers do not support std::format and related tools. Also, despite using a conformant compiler, some projects still choose to use fmtlib as their primary formatting facility (e.g., to benefit from additional features provided with the library).</p> <p>This macro resolves to either the <code>std</code> or <code>fmt</code> namespace, depending on the value of MP_UNITS_API_STD_FORMAT CMake option.</p> <p>To include the header files of the underlying text formatting framework, the following include should be used:</p> <pre><code>#include &lt;mp-units/ext/format.h&gt;\n</code></pre>"},{"location":"users_guide/use_cases/wide_compatibility/#contracts","title":"Contracts","text":"<p>The mp-units library internally does contract checking by default. It can be disabled with a Conan or CMake option. However, when enabled, it can use either gsl-lite or ms-gsl. To write a code that is independent from the underlying framework, the following preprocessor macros are exposed:</p> <ul> <li><code>MP_UNITS_EXPECTS(expr)</code></li> <li><code>MP_UNITS_EXPECTS_DEBUG(expr)</code></li> <li><code>MP_UNITS_ASSERT(expr)</code></li> <li><code>MP_UNITS_ASSERT_DEBUG(expr)</code></li> </ul> <p>Their meaning is consistent with respective gsl-lite.</p> <p>Also, to include the header files of the underlying framework, the following include should be used:</p> <pre><code>#include &lt;mp-units/ext/contracts.h&gt;\n</code></pre>"},{"location":"users_guide/use_cases/working_with_legacy_interfaces/","title":"Working with Legacy interfaces","text":"<p>In case we are working with a legacy/unsafe interface, we may need to extract the numerical value of a quantity and pass it to some third-party legacy unsafe interfaces.</p> <p>In such situations we can use <code>.numerical_value_in(Unit)</code> member function:</p> <pre><code>void legacy_check_speed_limit(int speed_in_km_per_h);\n</code></pre> <pre><code>legacy_check_speed_limit((180 * km / (2 * h)).numerical_value_in(km / h));\n</code></pre> <p>Such a getter will explicitly enforce the usage of a correct unit required by the underlying interface, which reduces a significant number of safety-related issues.</p> <p>The above code will not compile in case value truncation may happen. To solve the issue, we need to either use a value-preserving representation type or force the truncating conversion with <code>.force_numerical_value_in(Unit)</code>:</p> <pre><code>legacy_check_speed_limit((140 * mi / (2 * h)).force_numerical_value_in(km / h));\n</code></pre> <p>The getters mentioned above always return by value as a quantity value conversion may be required to adjust it to the target unit. In case a user needs a reference to the underlying storage <code>.numerical_value_ref_in(Unit)</code> should be used:</p> <pre><code>void legacy_set_speed_limit(int* speed_in_km_per_h) { *speed_in_km_per_h = 100; }\n</code></pre> <pre><code>quantity&lt;km / h, int&gt; speed_limit;\nlegacy_set_speed_limit(&amp;speed_limit.numerical_value_ref_in(km / h));\n</code></pre> <p>This member function again requires a target unit to enforce safety. This overload does not participate in overload resolution if the provided unit has a different scaling factor than the current one.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/category/metrology/","title":"Metrology","text":""},{"location":"blog/category/wg21-updates/","title":"WG21 Updates","text":""},{"location":"blog/category/releases/","title":"Releases","text":""},{"location":"blog/page/2/","title":"Blog","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""}]}